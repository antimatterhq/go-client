// Code generated by ogen, DO NOT EDIT.

package spec

import (
	"github.com/go-faster/jx"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestAPIKeyDomainIdentityProviderDetails_EncodeDecode(t *testing.T) {
	var typ APIKeyDomainIdentityProviderDetails
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 APIKeyDomainIdentityProviderDetails
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAWSServiceAccountKeyInfo_EncodeDecode(t *testing.T) {
	var typ AWSServiceAccountKeyInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AWSServiceAccountKeyInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAccessLogEntry_EncodeDecode(t *testing.T) {
	var typ AccessLogEntry
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AccessLogEntry
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAccessLogEntryCreateInfo_EncodeDecode(t *testing.T) {
	var typ AccessLogEntryCreateInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AccessLogEntryCreateInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAccessLogEntryOpenInfo_EncodeDecode(t *testing.T) {
	var typ AccessLogEntryOpenInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AccessLogEntryOpenInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAccessLogEntryOperation_EncodeDecode(t *testing.T) {
	var typ AccessLogEntryOperation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AccessLogEntryOperation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAccessLogEntryReadInfo_EncodeDecode(t *testing.T) {
	var typ AccessLogEntryReadInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AccessLogEntryReadInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAccessLogEntryReadInfoParameters_EncodeDecode(t *testing.T) {
	var typ AccessLogEntryReadInfoParameters
	typ = make(AccessLogEntryReadInfoParameters)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AccessLogEntryReadInfoParameters
	typ2 = make(AccessLogEntryReadInfoParameters)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAccessLogResults_EncodeDecode(t *testing.T) {
	var typ AccessLogResults
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AccessLogResults
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActiveRootEncryptionKeyID_EncodeDecode(t *testing.T) {
	var typ ActiveRootEncryptionKeyID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActiveRootEncryptionKeyID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddCapsuleLogEntryRequest_EncodeDecode(t *testing.T) {
	var typ AddCapsuleLogEntryRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddCapsuleLogEntryRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddReadContext_EncodeDecode(t *testing.T) {
	var typ AddReadContext
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddReadContext
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddWriteContext_EncodeDecode(t *testing.T) {
	var typ AddWriteContext
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddWriteContext
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAntimatterDelegatedAWSKeyInfo_EncodeDecode(t *testing.T) {
	var typ AntimatterDelegatedAWSKeyInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AntimatterDelegatedAWSKeyInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAntimatterDelegatedGCPKeyInfo_EncodeDecode(t *testing.T) {
	var typ AntimatterDelegatedGCPKeyInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AntimatterDelegatedGCPKeyInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAvailableDelegatedRootEncryptionKeyProvider_EncodeDecode(t *testing.T) {
	var typ AvailableDelegatedRootEncryptionKeyProvider
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AvailableDelegatedRootEncryptionKeyProvider
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAvailableRootEncryptionKeyProviders_EncodeDecode(t *testing.T) {
	var typ AvailableRootEncryptionKeyProviders
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AvailableRootEncryptionKeyProviders
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAvailableRootEncryptionKeyProvidersProvidersItem_EncodeDecode(t *testing.T) {
	var typ AvailableRootEncryptionKeyProvidersProvidersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AvailableRootEncryptionKeyProvidersProvidersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAvailableServiceAccountRootEncryptionKeyProvider_EncodeDecode(t *testing.T) {
	var typ AvailableServiceAccountRootEncryptionKeyProvider
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AvailableServiceAccountRootEncryptionKeyProvider
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBYOKKeyInfo_EncodeDecode(t *testing.T) {
	var typ BYOKKeyInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BYOKKeyInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCapability_EncodeDecode(t *testing.T) {
	var typ Capability
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Capability
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCapabilityDefinition_EncodeDecode(t *testing.T) {
	var typ CapabilityDefinition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CapabilityDefinition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCapabilityDefinitionList_EncodeDecode(t *testing.T) {
	var typ CapabilityDefinitionList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CapabilityDefinitionList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCapabilityList_EncodeDecode(t *testing.T) {
	var typ CapabilityList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CapabilityList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCapabilityName_EncodeDecode(t *testing.T) {
	var typ CapabilityName
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CapabilityName
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCapabilityReference_EncodeDecode(t *testing.T) {
	var typ CapabilityReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CapabilityReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCapabilityRule_EncodeDecode(t *testing.T) {
	var typ CapabilityRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CapabilityRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCapabilityRuleMatchExpressionsItem_EncodeDecode(t *testing.T) {
	var typ CapabilityRuleMatchExpressionsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CapabilityRuleMatchExpressionsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCapabilityRuleMatchExpressionsItemOperator_EncodeDecode(t *testing.T) {
	var typ CapabilityRuleMatchExpressionsItemOperator
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CapabilityRuleMatchExpressionsItemOperator
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCapsuleCreateResponse_EncodeDecode(t *testing.T) {
	var typ CapsuleCreateResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CapsuleCreateResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCapsuleID_EncodeDecode(t *testing.T) {
	var typ CapsuleID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CapsuleID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCapsuleInfo_EncodeDecode(t *testing.T) {
	var typ CapsuleInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CapsuleInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCapsuleList_EncodeDecode(t *testing.T) {
	var typ CapsuleList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CapsuleList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCapsuleOpenRequest_EncodeDecode(t *testing.T) {
	var typ CapsuleOpenRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CapsuleOpenRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCapsuleOpenResponse_EncodeDecode(t *testing.T) {
	var typ CapsuleOpenResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CapsuleOpenResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCapsuleOpenResponseReadContextConfiguration_EncodeDecode(t *testing.T) {
	var typ CapsuleOpenResponseReadContextConfiguration
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CapsuleOpenResponseReadContextConfiguration
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCapsuleOperationToken_EncodeDecode(t *testing.T) {
	var typ CapsuleOperationToken
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CapsuleOperationToken
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCapsuleSealRequest_EncodeDecode(t *testing.T) {
	var typ CapsuleSealRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CapsuleSealRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestConflictError_EncodeDecode(t *testing.T) {
	var typ ConflictError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ConflictError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreatePeerDomain_EncodeDecode(t *testing.T) {
	var typ CreatePeerDomain
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreatePeerDomain
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDataTaggingHookInput_EncodeDecode(t *testing.T) {
	var typ DataTaggingHookInput
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DataTaggingHookInput
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDataTaggingHookInputRecordsItem_EncodeDecode(t *testing.T) {
	var typ DataTaggingHookInputRecordsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DataTaggingHookInputRecordsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDataTaggingHookInputRecordsItemElementsItem_EncodeDecode(t *testing.T) {
	var typ DataTaggingHookInputRecordsItemElementsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DataTaggingHookInputRecordsItemElementsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDataTaggingHookResponse_EncodeDecode(t *testing.T) {
	var typ DataTaggingHookResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DataTaggingHookResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDataTaggingHookResponseRecordsItem_EncodeDecode(t *testing.T) {
	var typ DataTaggingHookResponseRecordsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DataTaggingHookResponseRecordsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteTags_EncodeDecode(t *testing.T) {
	var typ DeleteTags
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteTags
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDisasterRecoverySettings_EncodeDecode(t *testing.T) {
	var typ DisasterRecoverySettings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DisasterRecoverySettings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomain_EncodeDecode(t *testing.T) {
	var typ Domain
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Domain
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainAddReadContextRuleOK_EncodeDecode(t *testing.T) {
	var typ DomainAddReadContextRuleOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainAddReadContextRuleOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainAuthenticate_EncodeDecode(t *testing.T) {
	var typ DomainAuthenticate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainAuthenticate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainAuthenticateResponse_EncodeDecode(t *testing.T) {
	var typ DomainAuthenticateResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainAuthenticateResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainContactIssueVerifyReq_EncodeDecode(t *testing.T) {
	var typ DomainContactIssueVerifyReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainContactIssueVerifyReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainControlLogEntry_EncodeDecode(t *testing.T) {
	var typ DomainControlLogEntry
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainControlLogEntry
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainControlLogEntryDescription_EncodeDecode(t *testing.T) {
	var typ DomainControlLogEntryDescription
	typ = make(DomainControlLogEntryDescription)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainControlLogEntryDescription
	typ2 = make(DomainControlLogEntryDescription)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainControlLogResults_EncodeDecode(t *testing.T) {
	var typ DomainControlLogResults
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainControlLogResults
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainCreateCapsuleReq_EncodeDecode(t *testing.T) {
	var typ DomainCreateCapsuleReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainCreateCapsuleReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainExternalRootEncryptionKeyTestReq_EncodeDecode(t *testing.T) {
	var typ DomainExternalRootEncryptionKeyTestReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainExternalRootEncryptionKeyTestReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainFactList_EncodeDecode(t *testing.T) {
	var typ DomainFactList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainFactList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainFlushEncryptionKeysReq_EncodeDecode(t *testing.T) {
	var typ DomainFlushEncryptionKeysReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainFlushEncryptionKeysReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainGetWriteContextRegexRulesOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ DomainGetWriteContextRegexRulesOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainGetWriteContextRegexRulesOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainHooksList_EncodeDecode(t *testing.T) {
	var typ DomainHooksList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainHooksList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainHooksListHooksItem_EncodeDecode(t *testing.T) {
	var typ DomainHooksListHooksItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainHooksListHooksItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainID_EncodeDecode(t *testing.T) {
	var typ DomainID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainIdentityAPIKeyPrincipalParams_EncodeDecode(t *testing.T) {
	var typ DomainIdentityAPIKeyPrincipalParams
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainIdentityAPIKeyPrincipalParams
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainIdentityEmailPrincipalParams_EncodeDecode(t *testing.T) {
	var typ DomainIdentityEmailPrincipalParams
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainIdentityEmailPrincipalParams
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainIdentityHostedDomainPrincipalParams_EncodeDecode(t *testing.T) {
	var typ DomainIdentityHostedDomainPrincipalParams
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainIdentityHostedDomainPrincipalParams
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainIdentityPrincipalDetails_EncodeDecode(t *testing.T) {
	var typ DomainIdentityPrincipalDetails
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainIdentityPrincipalDetails
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainIdentityProviderDetails_EncodeDecode(t *testing.T) {
	var typ DomainIdentityProviderDetails
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainIdentityProviderDetails
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainIdentityProviderInfo_EncodeDecode(t *testing.T) {
	var typ DomainIdentityProviderInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainIdentityProviderInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainIdentityProviderList_EncodeDecode(t *testing.T) {
	var typ DomainIdentityProviderList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainIdentityProviderList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainIdentityProviderPrincipalList_EncodeDecode(t *testing.T) {
	var typ DomainIdentityProviderPrincipalList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainIdentityProviderPrincipalList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainIdentityProviderPrincipalParams_EncodeDecode(t *testing.T) {
	var typ DomainIdentityProviderPrincipalParams
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainIdentityProviderPrincipalParams
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainIdentityProviderPrincipalType_EncodeDecode(t *testing.T) {
	var typ DomainIdentityProviderPrincipalType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainIdentityProviderPrincipalType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainIdentityProviderType_EncodeDecode(t *testing.T) {
	var typ DomainIdentityProviderType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainIdentityProviderType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainInsertIdentityProviderPrincipalOK_EncodeDecode(t *testing.T) {
	var typ DomainInsertIdentityProviderPrincipalOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainInsertIdentityProviderPrincipalOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainInsertWriteContextRegexRuleOK_EncodeDecode(t *testing.T) {
	var typ DomainInsertWriteContextRegexRuleOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainInsertWriteContextRegexRuleOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainPeerConfig_EncodeDecode(t *testing.T) {
	var typ DomainPeerConfig
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainPeerConfig
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainPeerList_EncodeDecode(t *testing.T) {
	var typ DomainPeerList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainPeerList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainPeerListPeersItem_EncodeDecode(t *testing.T) {
	var typ DomainPeerListPeersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainPeerListPeersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainPolicy_EncodeDecode(t *testing.T) {
	var typ DomainPolicy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainPolicy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainPolicyRule_EncodeDecode(t *testing.T) {
	var typ DomainPolicyRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainPolicyRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainPrivateInfo_EncodeDecode(t *testing.T) {
	var typ DomainPrivateInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainPrivateInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainPublicInfo_EncodeDecode(t *testing.T) {
	var typ DomainPublicInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainPublicInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainRenumberPolicyRulesReq_EncodeDecode(t *testing.T) {
	var typ DomainRenumberPolicyRulesReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainRenumberPolicyRulesReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainResourceSummary_EncodeDecode(t *testing.T) {
	var typ DomainResourceSummary
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainResourceSummary
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainResourceSummarySchemaItem_EncodeDecode(t *testing.T) {
	var typ DomainResourceSummarySchemaItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainResourceSummarySchemaItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainResourceSummarySchemaItemOperationsItem_EncodeDecode(t *testing.T) {
	var typ DomainResourceSummarySchemaItemOperationsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainResourceSummarySchemaItemOperationsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainResourceSummarySchemaItemPlaceholderValues_EncodeDecode(t *testing.T) {
	var typ DomainResourceSummarySchemaItemPlaceholderValues
	typ = make(DomainResourceSummarySchemaItemPlaceholderValues)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainResourceSummarySchemaItemPlaceholderValues
	typ2 = make(DomainResourceSummarySchemaItemPlaceholderValues)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainRotateRootEncryptionKeysReq_EncodeDecode(t *testing.T) {
	var typ DomainRotateRootEncryptionKeysReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainRotateRootEncryptionKeysReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainSettings_EncodeDecode(t *testing.T) {
	var typ DomainSettings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainSettings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainSettingsPatch_EncodeDecode(t *testing.T) {
	var typ DomainSettingsPatch
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainSettingsPatch
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainStatus_EncodeDecode(t *testing.T) {
	var typ DomainStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainStatusNotificationsItem_EncodeDecode(t *testing.T) {
	var typ DomainStatusNotificationsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainStatusNotificationsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainStatusNotificationsItemType_EncodeDecode(t *testing.T) {
	var typ DomainStatusNotificationsItemType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainStatusNotificationsItemType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainTagInfoResults_EncodeDecode(t *testing.T) {
	var typ DomainTagInfoResults
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainTagInfoResults
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestError_EncodeDecode(t *testing.T) {
	var typ Error
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Error
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFact_EncodeDecode(t *testing.T) {
	var typ Fact
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Fact
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFactID_EncodeDecode(t *testing.T) {
	var typ FactID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FactID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFactList_EncodeDecode(t *testing.T) {
	var typ FactList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FactList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFactPolicyRules_EncodeDecode(t *testing.T) {
	var typ FactPolicyRules
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FactPolicyRules
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFactPolicyRulesItem_EncodeDecode(t *testing.T) {
	var typ FactPolicyRulesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FactPolicyRulesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFactPolicyRulesItemArgumentsItem_EncodeDecode(t *testing.T) {
	var typ FactPolicyRulesItemArgumentsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FactPolicyRulesItemArgumentsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFactPolicyRulesItemArgumentsItemSource_EncodeDecode(t *testing.T) {
	var typ FactPolicyRulesItemArgumentsItemSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FactPolicyRulesItemArgumentsItemSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFactPolicyRulesItemOperator_EncodeDecode(t *testing.T) {
	var typ FactPolicyRulesItemOperator
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FactPolicyRulesItemOperator
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFactTypeDefinition_EncodeDecode(t *testing.T) {
	var typ FactTypeDefinition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FactTypeDefinition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFactTypeDefinitionArgumentsItem_EncodeDecode(t *testing.T) {
	var typ FactTypeDefinitionArgumentsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FactTypeDefinitionArgumentsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFactTypeName_EncodeDecode(t *testing.T) {
	var typ FactTypeName
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FactTypeName
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFactTypeReference_EncodeDecode(t *testing.T) {
	var typ FactTypeReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FactTypeReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestForbiddenError_EncodeDecode(t *testing.T) {
	var typ ForbiddenError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ForbiddenError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGCPServiceAccountKeyInfo_EncodeDecode(t *testing.T) {
	var typ GCPServiceAccountKeyInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GCPServiceAccountKeyInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGoogleOAuthDomainIdentityProviderDetails_EncodeDecode(t *testing.T) {
	var typ GoogleOAuthDomainIdentityProviderDetails
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GoogleOAuthDomainIdentityProviderDetails
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHookName_EncodeDecode(t *testing.T) {
	var typ HookName
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HookName
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIdentityProviderName_EncodeDecode(t *testing.T) {
	var typ IdentityProviderName
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IdentityProviderName
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIdentityProviderReference_EncodeDecode(t *testing.T) {
	var typ IdentityProviderReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IdentityProviderReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestImportAlias_EncodeDecode(t *testing.T) {
	var typ ImportAlias
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ImportAlias
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInvalidRequestError_EncodeDecode(t *testing.T) {
	var typ InvalidRequestError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InvalidRequestError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestJSONPatchRequestAdd_EncodeDecode(t *testing.T) {
	var typ JSONPatchRequestAdd
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 JSONPatchRequestAdd
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestJSONPatchRequestAddValue_EncodeDecode(t *testing.T) {
	var typ JSONPatchRequestAddValue
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 JSONPatchRequestAddValue
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestJSONPatchRequestCopy_EncodeDecode(t *testing.T) {
	var typ JSONPatchRequestCopy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 JSONPatchRequestCopy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestJSONPatchRequestMove_EncodeDecode(t *testing.T) {
	var typ JSONPatchRequestMove
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 JSONPatchRequestMove
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestJSONPatchRequestRemove_EncodeDecode(t *testing.T) {
	var typ JSONPatchRequestRemove
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 JSONPatchRequestRemove
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestJSONPatchRequestReplace_EncodeDecode(t *testing.T) {
	var typ JSONPatchRequestReplace
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 JSONPatchRequestReplace
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestJSONPatchRequestReplaceValue_EncodeDecode(t *testing.T) {
	var typ JSONPatchRequestReplaceValue
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 JSONPatchRequestReplaceValue
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestJSONPatchRequestTst_EncodeDecode(t *testing.T) {
	var typ JSONPatchRequestTst
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 JSONPatchRequestTst
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestJSONPatchRequestTstValue_EncodeDecode(t *testing.T) {
	var typ JSONPatchRequestTstValue
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 JSONPatchRequestTstValue
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestKeyInfos_EncodeDecode(t *testing.T) {
	var typ KeyInfos
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 KeyInfos
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestKeyInfosKeyInformation_EncodeDecode(t *testing.T) {
	var typ KeyInfosKeyInformation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 KeyInfosKeyInformation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLogEntryID_EncodeDecode(t *testing.T) {
	var typ LogEntryID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LogEntryID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewAccessLogEntry_EncodeDecode(t *testing.T) {
	var typ NewAccessLogEntry
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewAccessLogEntry
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewAccessLogEntryOperation_EncodeDecode(t *testing.T) {
	var typ NewAccessLogEntryOperation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewAccessLogEntryOperation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewAccessLogEntryReadInfo_EncodeDecode(t *testing.T) {
	var typ NewAccessLogEntryReadInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewAccessLogEntryReadInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewAccessLogEntryReadInfoParameters_EncodeDecode(t *testing.T) {
	var typ NewAccessLogEntryReadInfoParameters
	typ = make(NewAccessLogEntryReadInfoParameters)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewAccessLogEntryReadInfoParameters
	typ2 = make(NewAccessLogEntryReadInfoParameters)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewCapabilityDefinition_EncodeDecode(t *testing.T) {
	var typ NewCapabilityDefinition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewCapabilityDefinition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewDomain_EncodeDecode(t *testing.T) {
	var typ NewDomain
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewDomain
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewDomainPolicyRule_EncodeDecode(t *testing.T) {
	var typ NewDomainPolicyRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewDomainPolicyRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewDomainResponse_EncodeDecode(t *testing.T) {
	var typ NewDomainResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewDomainResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewFact_EncodeDecode(t *testing.T) {
	var typ NewFact
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewFact
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewFactTypeDefinition_EncodeDecode(t *testing.T) {
	var typ NewFactTypeDefinition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewFactTypeDefinition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewFactTypeDefinitionArgumentsItem_EncodeDecode(t *testing.T) {
	var typ NewFactTypeDefinitionArgumentsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewFactTypeDefinitionArgumentsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewReadContextConfigRule_EncodeDecode(t *testing.T) {
	var typ NewReadContextConfigRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewReadContextConfigRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewReadContextConfigRuleAction_EncodeDecode(t *testing.T) {
	var typ NewReadContextConfigRuleAction
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewReadContextConfigRuleAction
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewReadContextConfigRuleTokenFormat_EncodeDecode(t *testing.T) {
	var typ NewReadContextConfigRuleTokenFormat
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewReadContextConfigRuleTokenFormat
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNewReadContextConfigRuleTokenScope_EncodeDecode(t *testing.T) {
	var typ NewReadContextConfigRuleTokenScope
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NewReadContextConfigRuleTokenScope
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchRequest_EncodeDecode(t *testing.T) {
	var typ PatchRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPatchRequestItem_EncodeDecode(t *testing.T) {
	var typ PatchRequestItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PatchRequestItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPolicyRuleOperation_EncodeDecode(t *testing.T) {
	var typ PolicyRuleOperation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PolicyRuleOperation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPolicyRuleResult_EncodeDecode(t *testing.T) {
	var typ PolicyRuleResult
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PolicyRuleResult
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPrincipalID_EncodeDecode(t *testing.T) {
	var typ PrincipalID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PrincipalID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPrincipalInfo_EncodeDecode(t *testing.T) {
	var typ PrincipalInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PrincipalInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPrincipalSummary_EncodeDecode(t *testing.T) {
	var typ PrincipalSummary
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PrincipalSummary
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReadContextConfigRule_EncodeDecode(t *testing.T) {
	var typ ReadContextConfigRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReadContextConfigRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReadContextConfigRuleAction_EncodeDecode(t *testing.T) {
	var typ ReadContextConfigRuleAction
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReadContextConfigRuleAction
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReadContextConfigRuleTokenFormat_EncodeDecode(t *testing.T) {
	var typ ReadContextConfigRuleTokenFormat
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReadContextConfigRuleTokenFormat
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReadContextConfigRuleTokenScope_EncodeDecode(t *testing.T) {
	var typ ReadContextConfigRuleTokenScope
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReadContextConfigRuleTokenScope
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReadContextDetails_EncodeDecode(t *testing.T) {
	var typ ReadContextDetails
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReadContextDetails
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReadContextList_EncodeDecode(t *testing.T) {
	var typ ReadContextList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReadContextList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReadContextName_EncodeDecode(t *testing.T) {
	var typ ReadContextName
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReadContextName
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReadContextParameter_EncodeDecode(t *testing.T) {
	var typ ReadContextParameter
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReadContextParameter
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReadContextReference_EncodeDecode(t *testing.T) {
	var typ ReadContextReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReadContextReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReadContextRequiredHook_EncodeDecode(t *testing.T) {
	var typ ReadContextRequiredHook
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReadContextRequiredHook
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReadContextRuleFacts_EncodeDecode(t *testing.T) {
	var typ ReadContextRuleFacts
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReadContextRuleFacts
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReadContextRuleFactsItem_EncodeDecode(t *testing.T) {
	var typ ReadContextRuleFactsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReadContextRuleFactsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReadContextRuleFactsItemArgumentsItem_EncodeDecode(t *testing.T) {
	var typ ReadContextRuleFactsItemArgumentsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReadContextRuleFactsItemArgumentsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReadContextRuleFactsItemArgumentsItemSource_EncodeDecode(t *testing.T) {
	var typ ReadContextRuleFactsItemArgumentsItemSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReadContextRuleFactsItemArgumentsItemSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReadContextRuleFactsItemOperator_EncodeDecode(t *testing.T) {
	var typ ReadContextRuleFactsItemOperator
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReadContextRuleFactsItemOperator
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReadContextRuleMatchExpressions_EncodeDecode(t *testing.T) {
	var typ ReadContextRuleMatchExpressions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReadContextRuleMatchExpressions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReadContextRuleMatchExpressionsItem_EncodeDecode(t *testing.T) {
	var typ ReadContextRuleMatchExpressionsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReadContextRuleMatchExpressionsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReadContextRuleMatchExpressionsItemOperator_EncodeDecode(t *testing.T) {
	var typ ReadContextRuleMatchExpressionsItemOperator
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReadContextRuleMatchExpressionsItemOperator
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReadContextRuleMatchExpressionsItemSource_EncodeDecode(t *testing.T) {
	var typ ReadContextRuleMatchExpressionsItemSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReadContextRuleMatchExpressionsItemSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReadContextShortDetails_EncodeDecode(t *testing.T) {
	var typ ReadContextShortDetails
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReadContextShortDetails
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResourceExhaustedError_EncodeDecode(t *testing.T) {
	var typ ResourceExhaustedError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResourceExhaustedError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResourceNotFoundError_EncodeDecode(t *testing.T) {
	var typ ResourceNotFoundError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResourceNotFoundError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRootEncryptionKeyID_EncodeDecode(t *testing.T) {
	var typ RootEncryptionKeyID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RootEncryptionKeyID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRootEncryptionKeyIDResponse_EncodeDecode(t *testing.T) {
	var typ RootEncryptionKeyIDResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RootEncryptionKeyIDResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRootEncryptionKeyItem_EncodeDecode(t *testing.T) {
	var typ RootEncryptionKeyItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RootEncryptionKeyItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRootEncryptionKeyListResponse_EncodeDecode(t *testing.T) {
	var typ RootEncryptionKeyListResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RootEncryptionKeyListResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRootEncryptionKeyReference_EncodeDecode(t *testing.T) {
	var typ RootEncryptionKeyReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RootEncryptionKeyReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRootEncryptionKeyTestResponse_EncodeDecode(t *testing.T) {
	var typ RootEncryptionKeyTestResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RootEncryptionKeyTestResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRootEncryptionKeyTestResponseStatus_EncodeDecode(t *testing.T) {
	var typ RootEncryptionKeyTestResponseStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RootEncryptionKeyTestResponseStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRotateKeyEncryptionKeyResponse_EncodeDecode(t *testing.T) {
	var typ RotateKeyEncryptionKeyResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RotateKeyEncryptionKeyResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRuleID_EncodeDecode(t *testing.T) {
	var typ RuleID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RuleID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRuleReference_EncodeDecode(t *testing.T) {
	var typ RuleReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RuleReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSessionID_EncodeDecode(t *testing.T) {
	var typ SessionID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SessionID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestStarredDomainAddReq_EncodeDecode(t *testing.T) {
	var typ StarredDomainAddReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StarredDomainAddReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestStarredDomainList_EncodeDecode(t *testing.T) {
	var typ StarredDomainList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StarredDomainList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTag_EncodeDecode(t *testing.T) {
	var typ Tag
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Tag
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTagMeta_EncodeDecode(t *testing.T) {
	var typ TagMeta
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TagMeta
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTagNameField_EncodeDecode(t *testing.T) {
	var typ TagNameField
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TagNameField
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTagSet_EncodeDecode(t *testing.T) {
	var typ TagSet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TagSet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTagSetSpanTagsItem_EncodeDecode(t *testing.T) {
	var typ TagSetSpanTagsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TagSetSpanTagsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTagSummary_EncodeDecode(t *testing.T) {
	var typ TagSummary
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TagSummary
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTagSummaryElidedTagsItem_EncodeDecode(t *testing.T) {
	var typ TagSummaryElidedTagsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TagSummaryElidedTagsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTagSummaryUniqueTagsItem_EncodeDecode(t *testing.T) {
	var typ TagSummaryUniqueTagsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TagSummaryUniqueTagsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTagTypeField_EncodeDecode(t *testing.T) {
	var typ TagTypeField
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TagTypeField
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTagValueField_EncodeDecode(t *testing.T) {
	var typ TagValueField
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TagValueField
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUnauthorizedError_EncodeDecode(t *testing.T) {
	var typ UnauthorizedError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UnauthorizedError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpsertSpanTagsRequest_EncodeDecode(t *testing.T) {
	var typ UpsertSpanTagsRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpsertSpanTagsRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestVendorSettings_EncodeDecode(t *testing.T) {
	var typ VendorSettings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 VendorSettings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestVerifyContactResponse_EncodeDecode(t *testing.T) {
	var typ VerifyContactResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 VerifyContactResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestVersionConstraint_EncodeDecode(t *testing.T) {
	var typ VersionConstraint
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 VersionConstraint
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWriteContextConfigInfo_EncodeDecode(t *testing.T) {
	var typ WriteContextConfigInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WriteContextConfigInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWriteContextConfigInfoRequiredHooksItem_EncodeDecode(t *testing.T) {
	var typ WriteContextConfigInfoRequiredHooksItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WriteContextConfigInfoRequiredHooksItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWriteContextConfigInfoRequiredHooksItemMode_EncodeDecode(t *testing.T) {
	var typ WriteContextConfigInfoRequiredHooksItemMode
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WriteContextConfigInfoRequiredHooksItemMode
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWriteContextDetails_EncodeDecode(t *testing.T) {
	var typ WriteContextDetails
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WriteContextDetails
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWriteContextList_EncodeDecode(t *testing.T) {
	var typ WriteContextList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WriteContextList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWriteContextName_EncodeDecode(t *testing.T) {
	var typ WriteContextName
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WriteContextName
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWriteContextReference_EncodeDecode(t *testing.T) {
	var typ WriteContextReference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WriteContextReference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWriteContextRegexRule_EncodeDecode(t *testing.T) {
	var typ WriteContextRegexRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WriteContextRegexRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWriteContextRegexTag_EncodeDecode(t *testing.T) {
	var typ WriteContextRegexTag
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WriteContextRegexTag
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
