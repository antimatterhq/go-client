// Code generated by ogen, DO NOT EDIT.

package spec

import (
	"net/http"
	"net/url"
	"strings"

	"github.com/ogen-go/ogen/uri"
)

func (s *Server) cutPrefix(path string) (string, bool) {
	prefix := s.cfg.Prefix
	if prefix == "" {
		return path, true
	}
	if !strings.HasPrefix(path, prefix) {
		// Prefix doesn't match.
		return "", false
	}
	// Cut prefix from the path.
	return strings.TrimPrefix(path, prefix), true
}

// ServeHTTP serves http request as defined by OpenAPI v3 specification,
// calling handler that matches the path or returning not found error.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	elem := r.URL.Path
	elemIsEscaped := false
	if rawPath := r.URL.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
			elemIsEscaped = strings.ContainsRune(elem, '%')
		}
	}

	elem, ok := s.cutPrefix(elem)
	if !ok || len(elem) == 0 {
		s.notFound(w, r)
		return
	}
	args := [3]string{}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"
			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'c': // Prefix: "capsules/"
				if l := len("capsules/"); len(elem) >= l && elem[0:l] == "capsules/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "capsuleID"
				// Leaf parameter
				args[0] = elem
				elem = ""

				if len(elem) == 0 {
					// Leaf node.
					switch r.Method {
					case "GET":
						s.handleCapsuleGetByIdRequest([1]string{
							args[0],
						}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET")
					}

					return
				}
			case 'd': // Prefix: "domains"
				if l := len("domains"); len(elem) >= l && elem[0:l] == "domains" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch r.Method {
					case "POST":
						s.handleDomainAddNewRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "POST")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "domainID"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "a"
							if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "ccount/verify"
								if l := len("ccount/verify"); len(elem) >= l && elem[0:l] == "ccount/verify" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleDomainContactVerifyRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "POST":
										s.handleDomainContactIssueVerifyRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,POST")
									}

									return
								}
							case 'u': // Prefix: "uthenticate"
								if l := len("uthenticate"); len(elem) >= l && elem[0:l] == "uthenticate" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleDomainAuthenticateRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}
							}
						case 'c': // Prefix: "c"
							if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "apsules"
								if l := len("apsules"); len(elem) >= l && elem[0:l] == "apsules" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleDomainListCapsulesRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "POST":
										s.handleDomainCreateCapsuleRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "capsuleID"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleDomainGetCapsuleInfoRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'c': // Prefix: "capsule-tags"
											if l := len("capsule-tags"); len(elem) >= l && elem[0:l] == "capsule-tags" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "POST":
													s.handleDomainUpsertCapsuleTagsRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/delete"
												if l := len("/delete"); len(elem) >= l && elem[0:l] == "/delete" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "POST":
														s.handleDomainDeleteCapsuleTagsRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}
											}
										case 'l': // Prefix: "log"
											if l := len("log"); len(elem) >= l && elem[0:l] == "log" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleDomainQueryAccessLogSingleCapsuleRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "POST":
													s.handleDomainAddAccessLogEntryRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET,POST")
												}

												return
											}
										case 'o': // Prefix: "open"
											if l := len("open"); len(elem) >= l && elem[0:l] == "open" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handleDomainOpenCapsuleRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}
										case 's': // Prefix: "s"
											if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'e': // Prefix: "eal"
												if l := len("eal"); len(elem) >= l && elem[0:l] == "eal" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "POST":
														s.handleDomainSealCapsuleRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}
											case 'p': // Prefix: "pan-tags"
												if l := len("pan-tags"); len(elem) >= l && elem[0:l] == "pan-tags" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "PUT":
														s.handleDomainUpsertSpanTagsRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "PUT")
													}

													return
												}
											}
										}
									}
								}
							case 'o': // Prefix: "ontrol/"
								if l := len("ontrol/"); len(elem) >= l && elem[0:l] == "ontrol/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "capabilities"
									if l := len("capabilities"); len(elem) >= l && elem[0:l] == "capabilities" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleDomainGetCapabilitiesRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "capability"
										// Leaf parameter
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "DELETE":
												s.handleDomainDeleteCapabilityRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											case "GET":
												s.handleDomainGetCapabilityRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											case "PUT":
												s.handleDomainPutCapabilityRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "DELETE,GET,PUT")
											}

											return
										}
									}
								case 'f': // Prefix: "facts"
									if l := len("facts"); len(elem) >= l && elem[0:l] == "facts" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleDomainListFactTypesRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "factType"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch r.Method {
											case "DELETE":
												s.handleDomainDeleteFactTypeRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											case "GET":
												s.handleDomainGetFactTypeRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											case "PUT":
												s.handleDomainPutFactTypeRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "DELETE,GET,PUT")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'l': // Prefix: "list"
												if l := len("list"); len(elem) >= l && elem[0:l] == "list" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleDomainListFactsRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
											case 'n': // Prefix: "new"
												if l := len("new"); len(elem) >= l && elem[0:l] == "new" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "POST":
														s.handleDomainUpsertFactRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}
											}
											// Param: "factID"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "DELETE":
													s.handleDomainDeleteFactByIDRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, elemIsEscaped, w, r)
												case "GET":
													s.handleDomainGetFactByIDRequest([3]string{
														args[0],
														args[1],
														args[2],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "DELETE,GET")
												}

												return
											}
										}
									}
								case 'i': // Prefix: "identities"
									if l := len("identities"); len(elem) >= l && elem[0:l] == "identities" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleDomainListIdentityProvidersRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "identityProviderName"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch r.Method {
											case "DELETE":
												s.handleDomainDeleteIdentityProviderRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											case "GET":
												s.handleDomainGetIdentityProviderRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											case "PUT":
												s.handleDomainUpsertIdentityProviderRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "DELETE,GET,PUT")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/principals"
											if l := len("/principals"); len(elem) >= l && elem[0:l] == "/principals" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleDomainGetIdentityProviderPrincipalsRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "POST":
													s.handleDomainInsertIdentityProviderPrincipalRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET,POST")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "principalID"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "DELETE":
														s.handleDomainDeleteIdentityProviderPrincipalRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													case "GET":
														s.handleDomainGetIdentityProviderPrincipalRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													case "PUT":
														s.handleDomainUpdateIdentityProviderPrincipalRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "DELETE,GET,PUT")
													}

													return
												}
											}
										}
									}
								case 'k': // Prefix: "keys"
									if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleDomainListExternalRootEncryptionKeyRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										case "POST":
											s.handleDomainAddExternalRootEncryptionKeyRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET,POST")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "active"
											if l := len("active"); len(elem) >= l && elem[0:l] == "active" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleDomainGetActiveExternalRootEncryptionKeyRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												case "POST":
													s.handleDomainSetActiveExternalRootEncryptionKeyRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET,POST")
												}

												return
											}
										case 'd': // Prefix: "disaster-recovery"
											if l := len("disaster-recovery"); len(elem) >= l && elem[0:l] == "disaster-recovery" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleDomainGetDisasterRecoverySettingsRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												case "PUT":
													s.handleDomainPutDisasterRecoverySettingsRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET,PUT")
												}

												return
											}
										case 'p': // Prefix: "providers"
											if l := len("providers"); len(elem) >= l && elem[0:l] == "providers" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleDomainGetExternalRootEncryptionKeyProvidersRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
										case 'r': // Prefix: "rotate"
											if l := len("rotate"); len(elem) >= l && elem[0:l] == "rotate" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handleDomainRotateRootEncryptionKeysRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}
										}
										// Param: "rootEncryptionKeyID"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch r.Method {
											case "DELETE":
												s.handleDomainDeleteExternalRootEncryptionKeyRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "DELETE")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/test"
											if l := len("/test"); len(elem) >= l && elem[0:l] == "/test" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handleDomainExternalRootEncryptionKeyTestRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}
										}
									}
								case 'l': // Prefix: "log"
									if l := len("log"); len(elem) >= l && elem[0:l] == "log" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleDomainQueryControlLogRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
								case 'p': // Prefix: "p"
									if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'e': // Prefix: "eers"
										if l := len("eers"); len(elem) >= l && elem[0:l] == "eers" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleDomainListPeersRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "peerDomainID"
											// Leaf parameter
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "DELETE":
													s.handleDomainDeletePeerRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "GET":
													s.handleDomainGetPeerConfigRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "PUT":
													s.handleDomainUpdatePeerRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "DELETE,GET,PUT")
												}

												return
											}
										}
									case 'o': // Prefix: "olicy"
										if l := len("olicy"); len(elem) >= l && elem[0:l] == "olicy" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleDomainListPolicyRulesRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											case "POST":
												s.handleDomainCreatePolicyRuleRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET,POST")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'f': // Prefix: "flush"
												if l := len("flush"); len(elem) >= l && elem[0:l] == "flush" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "POST":
														s.handleDomainPolicyFlushRequest([1]string{
															args[0],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}
											case 'r': // Prefix: "renumber"
												if l := len("renumber"); len(elem) >= l && elem[0:l] == "renumber" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "POST":
														s.handleDomainRenumberPolicyRulesRequest([1]string{
															args[0],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}
											}
											// Param: "ruleID"
											// Leaf parameter
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "DELETE":
													s.handleDomainDeletePolicyRuleRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "PUT":
													s.handleDomainUpdatePolicyRuleRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "DELETE,PUT")
												}

												return
											}
										}
									}
								case 'r': // Prefix: "re"
									if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "ad-context"
										if l := len("ad-context"); len(elem) >= l && elem[0:l] == "ad-context" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleDomainListReadContextsRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "contextName"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch r.Method {
												case "DELETE":
													s.handleDomainDeleteReadContextRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "GET":
													s.handleDomainGetReadContextRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												case "PUT":
													s.handleDomainUpsertReadContextRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "DELETE,GET,PUT")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'c': // Prefix: "config"
													if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch r.Method {
														case "POST":
															s.handleDomainAddReadContextRuleRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "ruleID"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "DELETE":
																s.handleDomainDeleteReadContextRuleRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															case "PUT":
																s.handleDomainUpdateReadContextRuleRequest([3]string{
																	args[0],
																	args[1],
																	args[2],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "DELETE,PUT")
															}

															return
														}
													}
												case 'f': // Prefix: "flush"
													if l := len("flush"); len(elem) >= l && elem[0:l] == "flush" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "POST":
															s.handleDomainReadContextFlushRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}
												}
											}
										}
									case 's': // Prefix: "sources"
										if l := len("sources"); len(elem) >= l && elem[0:l] == "sources" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleDomainListResourcesRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}
									}
								case 's': // Prefix: "s"
									if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'e': // Prefix: "ettings"
										if l := len("ettings"); len(elem) >= l && elem[0:l] == "ettings" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleDomainGetSettingsRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											case "PATCH":
												s.handleDomainPatchSettingsRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET,PATCH")
											}

											return
										}
									case 't': // Prefix: "tatus"
										if l := len("tatus"); len(elem) >= l && elem[0:l] == "tatus" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleDomainGetStatusRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}
									}
								case 'v': // Prefix: "vendor/settings"
									if l := len("vendor/settings"); len(elem) >= l && elem[0:l] == "vendor/settings" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleDomainGetVendorSettingsRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										case "PUT":
											s.handleDomainPutVendorSettingsRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET,PUT")
										}

										return
									}
								case 'w': // Prefix: "write-context"
									if l := len("write-context"); len(elem) >= l && elem[0:l] == "write-context" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleDomainListWriteContextsRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "contextName"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch r.Method {
											case "DELETE":
												s.handleDomainDeleteWriteContextRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											case "GET":
												s.handleDomainDescribeWriteContextRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											case "PUT":
												s.handleDomainUpsertWriteContextRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "DELETE,GET,PUT")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'c': // Prefix: "config"
												if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "PUT":
														s.handleDomainUpsertWriteContextConfigurationRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "PUT")
													}

													return
												}
											case 'r': // Prefix: "regex-rule"
												if l := len("regex-rule"); len(elem) >= l && elem[0:l] == "regex-rule" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleDomainGetWriteContextRegexRulesRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													case "POST":
														s.handleDomainInsertWriteContextRegexRuleRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET,POST")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "ruleID"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "DELETE":
															s.handleDomainDeleteWriteContextRegexRuleRequest([3]string{
																args[0],
																args[1],
																args[2],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "DELETE")
														}

														return
													}
												}
											}
										}
									}
								}
							}
						case 'e': // Prefix: "encryption/flush"
							if l := len("encryption/flush"); len(elem) >= l && elem[0:l] == "encryption/flush" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleDomainFlushEncryptionKeysRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}
						case 'h': // Prefix: "hooks"
							if l := len("hooks"); len(elem) >= l && elem[0:l] == "hooks" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleDomainListHooksRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/data-tagging/"
								if l := len("/data-tagging/"); len(elem) >= l && elem[0:l] == "/data-tagging/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "hookName"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/invoke"
									if l := len("/invoke"); len(elem) >= l && elem[0:l] == "/invoke" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleDomainDataTaggingHookInvokeRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}
								}
							}
						case 'i': // Prefix: "info"
							if l := len("info"); len(elem) >= l && elem[0:l] == "info" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleDomainGetPrivateInfoRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						case 'l': // Prefix: "log"
							if l := len("log"); len(elem) >= l && elem[0:l] == "log" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleDomainQueryAccessLogRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						case 'p': // Prefix: "p"
							if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'e': // Prefix: "eer-domain"
								if l := len("eer-domain"); len(elem) >= l && elem[0:l] == "eer-domain" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleDomainGetPeerRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "POST":
										s.handleDomainCreatePeerDomainRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,POST")
									}

									return
								}
							case 'u': // Prefix: "ublic-info"
								if l := len("ublic-info"); len(elem) >= l && elem[0:l] == "ublic-info" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleDomainGetPublicInfoRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							}
						case 't': // Prefix: "tag-info"
							if l := len("tag-info"); len(elem) >= l && elem[0:l] == "tag-info" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleDomainGetTagInfoRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						}
					}
				}
			case 'g': // Prefix: "global/starred-domains"
				if l := len("global/starred-domains"); len(elem) >= l && elem[0:l] == "global/starred-domains" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch r.Method {
					case "GET":
						s.handleStarredDomainListRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "domainID"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "DELETE":
							s.handleStarredDomainRemoveRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "PUT":
							s.handleStarredDomainAddRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "DELETE,PUT")
						}

						return
					}
				}
			}
		}
	}
	s.notFound(w, r)
}

// Route is route object.
type Route struct {
	name        string
	summary     string
	operationID string
	pathPattern string
	count       int
	args        [3]string
}

// Name returns ogen operation name.
//
// It is guaranteed to be unique and not empty.
func (r Route) Name() string {
	return r.name
}

// Summary returns OpenAPI summary.
func (r Route) Summary() string {
	return r.summary
}

// OperationID returns OpenAPI operationId.
func (r Route) OperationID() string {
	return r.operationID
}

// PathPattern returns OpenAPI path.
func (r Route) PathPattern() string {
	return r.pathPattern
}

// Args returns parsed arguments.
func (r Route) Args() []string {
	return r.args[:r.count]
}

// FindRoute finds Route for given method and path.
//
// Note: this method does not unescape path or handle reserved characters in path properly. Use FindPath instead.
func (s *Server) FindRoute(method, path string) (Route, bool) {
	return s.FindPath(method, &url.URL{Path: path})
}

// FindPath finds Route for given method and URL.
func (s *Server) FindPath(method string, u *url.URL) (r Route, _ bool) {
	var (
		elem = u.Path
		args = r.args
	)
	if rawPath := u.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
		}
		defer func() {
			for i, arg := range r.args[:r.count] {
				if unescaped, err := url.PathUnescape(arg); err == nil {
					r.args[i] = unescaped
				}
			}
		}()
	}

	elem, ok := s.cutPrefix(elem)
	if !ok {
		return r, false
	}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"
			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'c': // Prefix: "capsules/"
				if l := len("capsules/"); len(elem) >= l && elem[0:l] == "capsules/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "capsuleID"
				// Leaf parameter
				args[0] = elem
				elem = ""

				if len(elem) == 0 {
					switch method {
					case "GET":
						// Leaf: CapsuleGetById
						r.name = "CapsuleGetById"
						r.summary = "Get a Capsule by ID"
						r.operationID = "capsuleGetById"
						r.pathPattern = "/capsules/{capsuleID}"
						r.args = args
						r.count = 1
						return r, true
					default:
						return
					}
				}
			case 'd': // Prefix: "domains"
				if l := len("domains"); len(elem) >= l && elem[0:l] == "domains" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "POST":
						r.name = "DomainAddNew"
						r.summary = "Add a new domain"
						r.operationID = "domainAddNew"
						r.pathPattern = "/domains"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "domainID"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "a"
							if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "ccount/verify"
								if l := len("ccount/verify"); len(elem) >= l && elem[0:l] == "ccount/verify" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: DomainContactVerify
										r.name = "DomainContactVerify"
										r.summary = "Verify an admin contact email"
										r.operationID = "domainContactVerify"
										r.pathPattern = "/domains/{domainID}/account/verify"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										// Leaf: DomainContactIssueVerify
										r.name = "DomainContactIssueVerify"
										r.summary = "Issue a new verification request"
										r.operationID = "domainContactIssueVerify"
										r.pathPattern = "/domains/{domainID}/account/verify"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							case 'u': // Prefix: "uthenticate"
								if l := len("uthenticate"); len(elem) >= l && elem[0:l] == "uthenticate" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										// Leaf: DomainAuthenticate
										r.name = "DomainAuthenticate"
										r.summary = "Authenticate with a domain"
										r.operationID = "domainAuthenticate"
										r.pathPattern = "/domains/{domainID}/authenticate"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							}
						case 'c': // Prefix: "c"
							if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "apsules"
								if l := len("apsules"); len(elem) >= l && elem[0:l] == "apsules" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = "DomainListCapsules"
										r.summary = "Get capsule list"
										r.operationID = "domainListCapsules"
										r.pathPattern = "/domains/{domainID}/capsules"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										r.name = "DomainCreateCapsule"
										r.summary = "Create a capsule"
										r.operationID = "domainCreateCapsule"
										r.pathPattern = "/domains/{domainID}/capsules"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "capsuleID"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = "DomainGetCapsuleInfo"
											r.summary = "Get capsule info"
											r.operationID = "domainGetCapsuleInfo"
											r.pathPattern = "/domains/{domainID}/capsules/{capsuleID}"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'c': // Prefix: "capsule-tags"
											if l := len("capsule-tags"); len(elem) >= l && elem[0:l] == "capsule-tags" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "POST":
													r.name = "DomainUpsertCapsuleTags"
													r.summary = "Upsert capsule-scope tags"
													r.operationID = "domainUpsertCapsuleTags"
													r.pathPattern = "/domains/{domainID}/capsules/{capsuleID}/capsule-tags"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/delete"
												if l := len("/delete"); len(elem) >= l && elem[0:l] == "/delete" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "POST":
														// Leaf: DomainDeleteCapsuleTags
														r.name = "DomainDeleteCapsuleTags"
														r.summary = "Delete capsule-level tags"
														r.operationID = "domainDeleteCapsuleTags"
														r.pathPattern = "/domains/{domainID}/capsules/{capsuleID}/capsule-tags/delete"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
											}
										case 'l': // Prefix: "log"
											if l := len("log"); len(elem) >= l && elem[0:l] == "log" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													// Leaf: DomainQueryAccessLogSingleCapsule
													r.name = "DomainQueryAccessLogSingleCapsule"
													r.summary = "Get the access log for a single capsule"
													r.operationID = "domainQueryAccessLogSingleCapsule"
													r.pathPattern = "/domains/{domainID}/capsules/{capsuleID}/log"
													r.args = args
													r.count = 2
													return r, true
												case "POST":
													// Leaf: DomainAddAccessLogEntry
													r.name = "DomainAddAccessLogEntry"
													r.summary = "Add a capsule audit log entry"
													r.operationID = "domainAddAccessLogEntry"
													r.pathPattern = "/domains/{domainID}/capsules/{capsuleID}/log"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
										case 'o': // Prefix: "open"
											if l := len("open"); len(elem) >= l && elem[0:l] == "open" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "POST":
													// Leaf: DomainOpenCapsule
													r.name = "DomainOpenCapsule"
													r.summary = "Open a capsule for reading"
													r.operationID = "domainOpenCapsule"
													r.pathPattern = "/domains/{domainID}/capsules/{capsuleID}/open"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
										case 's': // Prefix: "s"
											if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'e': // Prefix: "eal"
												if l := len("eal"); len(elem) >= l && elem[0:l] == "eal" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "POST":
														// Leaf: DomainSealCapsule
														r.name = "DomainSealCapsule"
														r.summary = "Seal a capsule"
														r.operationID = "domainSealCapsule"
														r.pathPattern = "/domains/{domainID}/capsules/{capsuleID}/seal"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
											case 'p': // Prefix: "pan-tags"
												if l := len("pan-tags"); len(elem) >= l && elem[0:l] == "pan-tags" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "PUT":
														// Leaf: DomainUpsertSpanTags
														r.name = "DomainUpsertSpanTags"
														r.summary = "Upsert span-scope tags"
														r.operationID = "domainUpsertSpanTags"
														r.pathPattern = "/domains/{domainID}/capsules/{capsuleID}/span-tags"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
											}
										}
									}
								}
							case 'o': // Prefix: "ontrol/"
								if l := len("ontrol/"); len(elem) >= l && elem[0:l] == "ontrol/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "capabilities"
									if l := len("capabilities"); len(elem) >= l && elem[0:l] == "capabilities" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = "DomainGetCapabilities"
											r.summary = "Get the domain capabilities"
											r.operationID = "domainGetCapabilities"
											r.pathPattern = "/domains/{domainID}/control/capabilities"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "capability"
										// Leaf parameter
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											switch method {
											case "DELETE":
												// Leaf: DomainDeleteCapability
												r.name = "DomainDeleteCapability"
												r.summary = "Delete a capability"
												r.operationID = "domainDeleteCapability"
												r.pathPattern = "/domains/{domainID}/control/capabilities/{capability}"
												r.args = args
												r.count = 2
												return r, true
											case "GET":
												// Leaf: DomainGetCapability
												r.name = "DomainGetCapability"
												r.summary = "Get a single capability"
												r.operationID = "domainGetCapability"
												r.pathPattern = "/domains/{domainID}/control/capabilities/{capability}"
												r.args = args
												r.count = 2
												return r, true
											case "PUT":
												// Leaf: DomainPutCapability
												r.name = "DomainPutCapability"
												r.summary = "Create or update a capability"
												r.operationID = "domainPutCapability"
												r.pathPattern = "/domains/{domainID}/control/capabilities/{capability}"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
									}
								case 'f': // Prefix: "facts"
									if l := len("facts"); len(elem) >= l && elem[0:l] == "facts" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = "DomainListFactTypes"
											r.summary = "List the domain's fact types"
											r.operationID = "domainListFactTypes"
											r.pathPattern = "/domains/{domainID}/control/facts"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "factType"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch method {
											case "DELETE":
												r.name = "DomainDeleteFactType"
												r.summary = "Delete a fact type"
												r.operationID = "domainDeleteFactType"
												r.pathPattern = "/domains/{domainID}/control/facts/{factType}"
												r.args = args
												r.count = 2
												return r, true
											case "GET":
												r.name = "DomainGetFactType"
												r.summary = "Get a fact type definition"
												r.operationID = "domainGetFactType"
												r.pathPattern = "/domains/{domainID}/control/facts/{factType}"
												r.args = args
												r.count = 2
												return r, true
											case "PUT":
												r.name = "DomainPutFactType"
												r.summary = "Create a fact type"
												r.operationID = "domainPutFactType"
												r.pathPattern = "/domains/{domainID}/control/facts/{factType}"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'l': // Prefix: "list"
												if l := len("list"); len(elem) >= l && elem[0:l] == "list" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														// Leaf: DomainListFacts
														r.name = "DomainListFacts"
														r.summary = "Get facts for a type"
														r.operationID = "domainListFacts"
														r.pathPattern = "/domains/{domainID}/control/facts/{factType}/list"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
											case 'n': // Prefix: "new"
												if l := len("new"); len(elem) >= l && elem[0:l] == "new" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "POST":
														// Leaf: DomainUpsertFact
														r.name = "DomainUpsertFact"
														r.summary = "Upsert a fact"
														r.operationID = "domainUpsertFact"
														r.pathPattern = "/domains/{domainID}/control/facts/{factType}/new"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
											}
											// Param: "factID"
											// Leaf parameter
											args[2] = elem
											elem = ""

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													// Leaf: DomainDeleteFactByID
													r.name = "DomainDeleteFactByID"
													r.summary = "Delete a fact"
													r.operationID = "domainDeleteFactByID"
													r.pathPattern = "/domains/{domainID}/control/facts/{factType}/{factID}"
													r.args = args
													r.count = 3
													return r, true
												case "GET":
													// Leaf: DomainGetFactByID
													r.name = "DomainGetFactByID"
													r.summary = "Get a fact by ID"
													r.operationID = "domainGetFactByID"
													r.pathPattern = "/domains/{domainID}/control/facts/{factType}/{factID}"
													r.args = args
													r.count = 3
													return r, true
												default:
													return
												}
											}
										}
									}
								case 'i': // Prefix: "identities"
									if l := len("identities"); len(elem) >= l && elem[0:l] == "identities" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = "DomainListIdentityProviders"
											r.summary = "Get a summary of the domain's Identity Providers"
											r.operationID = "domainListIdentityProviders"
											r.pathPattern = "/domains/{domainID}/control/identities"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "identityProviderName"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch method {
											case "DELETE":
												r.name = "DomainDeleteIdentityProvider"
												r.summary = "Delete an identity provider"
												r.operationID = "domainDeleteIdentityProvider"
												r.pathPattern = "/domains/{domainID}/control/identities/{identityProviderName}"
												r.args = args
												r.count = 2
												return r, true
											case "GET":
												r.name = "DomainGetIdentityProvider"
												r.summary = "Get an identity provider's details"
												r.operationID = "domainGetIdentityProvider"
												r.pathPattern = "/domains/{domainID}/control/identities/{identityProviderName}"
												r.args = args
												r.count = 2
												return r, true
											case "PUT":
												r.name = "DomainUpsertIdentityProvider"
												r.summary = "Create/Update an identity provider"
												r.operationID = "domainUpsertIdentityProvider"
												r.pathPattern = "/domains/{domainID}/control/identities/{identityProviderName}"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/principals"
											if l := len("/principals"); len(elem) >= l && elem[0:l] == "/principals" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = "DomainGetIdentityProviderPrincipals"
													r.summary = "Get an identity provider's principals"
													r.operationID = "domainGetIdentityProviderPrincipals"
													r.pathPattern = "/domains/{domainID}/control/identities/{identityProviderName}/principals"
													r.args = args
													r.count = 2
													return r, true
												case "POST":
													r.name = "DomainInsertIdentityProviderPrincipal"
													r.summary = "Create a new principal for the provider"
													r.operationID = "domainInsertIdentityProviderPrincipal"
													r.pathPattern = "/domains/{domainID}/control/identities/{identityProviderName}/principals"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "principalID"
												// Leaf parameter
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													switch method {
													case "DELETE":
														// Leaf: DomainDeleteIdentityProviderPrincipal
														r.name = "DomainDeleteIdentityProviderPrincipal"
														r.summary = "Delete identity provider principal"
														r.operationID = "domainDeleteIdentityProviderPrincipal"
														r.pathPattern = "/domains/{domainID}/control/identities/{identityProviderName}/principals/{principalID}"
														r.args = args
														r.count = 3
														return r, true
													case "GET":
														// Leaf: DomainGetIdentityProviderPrincipal
														r.name = "DomainGetIdentityProviderPrincipal"
														r.summary = "Get identity provider principal details"
														r.operationID = "domainGetIdentityProviderPrincipal"
														r.pathPattern = "/domains/{domainID}/control/identities/{identityProviderName}/principals/{principalID}"
														r.args = args
														r.count = 3
														return r, true
													case "PUT":
														// Leaf: DomainUpdateIdentityProviderPrincipal
														r.name = "DomainUpdateIdentityProviderPrincipal"
														r.summary = "Update identity provider principal capabilities"
														r.operationID = "domainUpdateIdentityProviderPrincipal"
														r.pathPattern = "/domains/{domainID}/control/identities/{identityProviderName}/principals/{principalID}"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}
											}
										}
									}
								case 'k': // Prefix: "keys"
									if l := len("keys"); len(elem) >= l && elem[0:l] == "keys" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = "DomainListExternalRootEncryptionKey"
											r.summary = "List all external root encryption keys."
											r.operationID = "domainListExternalRootEncryptionKey"
											r.pathPattern = "/domains/{domainID}/control/keys"
											r.args = args
											r.count = 1
											return r, true
										case "POST":
											r.name = "DomainAddExternalRootEncryptionKey"
											r.summary = "Add a new external root encryption key."
											r.operationID = "domainAddExternalRootEncryptionKey"
											r.pathPattern = "/domains/{domainID}/control/keys"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "active"
											if l := len("active"); len(elem) >= l && elem[0:l] == "active" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													// Leaf: DomainGetActiveExternalRootEncryptionKey
													r.name = "DomainGetActiveExternalRootEncryptionKey"
													r.summary = "Get the active root encryption key's information."
													r.operationID = "domainGetActiveExternalRootEncryptionKey"
													r.pathPattern = "/domains/{domainID}/control/keys/active"
													r.args = args
													r.count = 1
													return r, true
												case "POST":
													// Leaf: DomainSetActiveExternalRootEncryptionKey
													r.name = "DomainSetActiveExternalRootEncryptionKey"
													r.summary = "Set the active root encryption key"
													r.operationID = "domainSetActiveExternalRootEncryptionKey"
													r.pathPattern = "/domains/{domainID}/control/keys/active"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}
										case 'd': // Prefix: "disaster-recovery"
											if l := len("disaster-recovery"); len(elem) >= l && elem[0:l] == "disaster-recovery" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													// Leaf: DomainGetDisasterRecoverySettings
													r.name = "DomainGetDisasterRecoverySettings"
													r.summary = "Get a domain's disaster recovery settings."
													r.operationID = "domainGetDisasterRecoverySettings"
													r.pathPattern = "/domains/{domainID}/control/keys/disaster-recovery"
													r.args = args
													r.count = 1
													return r, true
												case "PUT":
													// Leaf: DomainPutDisasterRecoverySettings
													r.name = "DomainPutDisasterRecoverySettings"
													r.summary = "Create or update a domain's disaster recovery settings."
													r.operationID = "domainPutDisasterRecoverySettings"
													r.pathPattern = "/domains/{domainID}/control/keys/disaster-recovery"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}
										case 'p': // Prefix: "providers"
											if l := len("providers"); len(elem) >= l && elem[0:l] == "providers" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													// Leaf: DomainGetExternalRootEncryptionKeyProviders
													r.name = "DomainGetExternalRootEncryptionKeyProviders"
													r.summary = "Returns a list of available root encryption key providers."
													r.operationID = "domainGetExternalRootEncryptionKeyProviders"
													r.pathPattern = "/domains/{domainID}/control/keys/providers"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}
										case 'r': // Prefix: "rotate"
											if l := len("rotate"); len(elem) >= l && elem[0:l] == "rotate" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "POST":
													// Leaf: DomainRotateRootEncryptionKeys
													r.name = "DomainRotateRootEncryptionKeys"
													r.summary = "Re-encrypt key encryption keys."
													r.operationID = "domainRotateRootEncryptionKeys"
													r.pathPattern = "/domains/{domainID}/control/keys/rotate"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}
										}
										// Param: "rootEncryptionKeyID"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch method {
											case "DELETE":
												r.name = "DomainDeleteExternalRootEncryptionKey"
												r.summary = "Delete an external root encryption key by ID."
												r.operationID = "domainDeleteExternalRootEncryptionKey"
												r.pathPattern = "/domains/{domainID}/control/keys/{rootEncryptionKeyID}"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/test"
											if l := len("/test"); len(elem) >= l && elem[0:l] == "/test" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "POST":
													// Leaf: DomainExternalRootEncryptionKeyTest
													r.name = "DomainExternalRootEncryptionKeyTest"
													r.summary = "Test the health of a root encryption key"
													r.operationID = "domainExternalRootEncryptionKeyTest"
													r.pathPattern = "/domains/{domainID}/control/keys/{rootEncryptionKeyID}/test"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
										}
									}
								case 'l': // Prefix: "log"
									if l := len("log"); len(elem) >= l && elem[0:l] == "log" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											// Leaf: DomainQueryControlLog
											r.name = "DomainQueryControlLog"
											r.summary = "Get the domain control-plane audit log"
											r.operationID = "domainQueryControlLog"
											r.pathPattern = "/domains/{domainID}/control/log"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								case 'p': // Prefix: "p"
									if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'e': // Prefix: "eers"
										if l := len("eers"); len(elem) >= l && elem[0:l] == "eers" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = "DomainListPeers"
												r.summary = "List domain peers"
												r.operationID = "domainListPeers"
												r.pathPattern = "/domains/{domainID}/control/peers"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "peerDomainID"
											// Leaf parameter
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													// Leaf: DomainDeletePeer
													r.name = "DomainDeletePeer"
													r.summary = "Delete a peer domain"
													r.operationID = "domainDeletePeer"
													r.pathPattern = "/domains/{domainID}/control/peers/{peerDomainID}"
													r.args = args
													r.count = 2
													return r, true
												case "GET":
													// Leaf: DomainGetPeerConfig
													r.name = "DomainGetPeerConfig"
													r.summary = "Get peer configuration"
													r.operationID = "domainGetPeerConfig"
													r.pathPattern = "/domains/{domainID}/control/peers/{peerDomainID}"
													r.args = args
													r.count = 2
													return r, true
												case "PUT":
													// Leaf: DomainUpdatePeer
													r.name = "DomainUpdatePeer"
													r.summary = "Update peer configuration"
													r.operationID = "domainUpdatePeer"
													r.pathPattern = "/domains/{domainID}/control/peers/{peerDomainID}"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
										}
									case 'o': // Prefix: "olicy"
										if l := len("olicy"); len(elem) >= l && elem[0:l] == "olicy" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = "DomainListPolicyRules"
												r.summary = "Get the domain policy rules"
												r.operationID = "domainListPolicyRules"
												r.pathPattern = "/domains/{domainID}/control/policy"
												r.args = args
												r.count = 1
												return r, true
											case "POST":
												r.name = "DomainCreatePolicyRule"
												r.summary = "Create a domain policy rule"
												r.operationID = "domainCreatePolicyRule"
												r.pathPattern = "/domains/{domainID}/control/policy"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'f': // Prefix: "flush"
												if l := len("flush"); len(elem) >= l && elem[0:l] == "flush" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "POST":
														// Leaf: DomainPolicyFlush
														r.name = "DomainPolicyFlush"
														r.summary = "Flush the policy cache"
														r.operationID = "domainPolicyFlush"
														r.pathPattern = "/domains/{domainID}/control/policy/flush"
														r.args = args
														r.count = 1
														return r, true
													default:
														return
													}
												}
											case 'r': // Prefix: "renumber"
												if l := len("renumber"); len(elem) >= l && elem[0:l] == "renumber" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "POST":
														// Leaf: DomainRenumberPolicyRules
														r.name = "DomainRenumberPolicyRules"
														r.summary = "Re-assign rule numbers"
														r.operationID = "domainRenumberPolicyRules"
														r.pathPattern = "/domains/{domainID}/control/policy/renumber"
														r.args = args
														r.count = 1
														return r, true
													default:
														return
													}
												}
											}
											// Param: "ruleID"
											// Leaf parameter
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													// Leaf: DomainDeletePolicyRule
													r.name = "DomainDeletePolicyRule"
													r.summary = "Delete a domain policy rule"
													r.operationID = "domainDeletePolicyRule"
													r.pathPattern = "/domains/{domainID}/control/policy/{ruleID}"
													r.args = args
													r.count = 2
													return r, true
												case "PUT":
													// Leaf: DomainUpdatePolicyRule
													r.name = "DomainUpdatePolicyRule"
													r.summary = "Update a domain policy rule"
													r.operationID = "domainUpdatePolicyRule"
													r.pathPattern = "/domains/{domainID}/control/policy/{ruleID}"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
										}
									}
								case 'r': // Prefix: "re"
									if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "ad-context"
										if l := len("ad-context"); len(elem) >= l && elem[0:l] == "ad-context" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = "DomainListReadContexts"
												r.summary = "List domain read contexts"
												r.operationID = "domainListReadContexts"
												r.pathPattern = "/domains/{domainID}/control/read-context"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "contextName"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													r.name = "DomainDeleteReadContext"
													r.summary = "Delete a read context"
													r.operationID = "domainDeleteReadContext"
													r.pathPattern = "/domains/{domainID}/control/read-context/{contextName}"
													r.args = args
													r.count = 2
													return r, true
												case "GET":
													r.name = "DomainGetReadContext"
													r.summary = "Get a read context"
													r.operationID = "domainGetReadContext"
													r.pathPattern = "/domains/{domainID}/control/read-context/{contextName}"
													r.args = args
													r.count = 2
													return r, true
												case "PUT":
													r.name = "DomainUpsertReadContext"
													r.summary = "Update or create a read context"
													r.operationID = "domainUpsertReadContext"
													r.pathPattern = "/domains/{domainID}/control/read-context/{contextName}"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'c': // Prefix: "config"
													if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "POST":
															r.name = "DomainAddReadContextRule"
															r.summary = "Add a read context configuration rule"
															r.operationID = "domainAddReadContextRule"
															r.pathPattern = "/domains/{domainID}/control/read-context/{contextName}/config"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"
														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														// Param: "ruleID"
														// Leaf parameter
														args[2] = elem
														elem = ""

														if len(elem) == 0 {
															switch method {
															case "DELETE":
																// Leaf: DomainDeleteReadContextRule
																r.name = "DomainDeleteReadContextRule"
																r.summary = "Delete a read context configuration rule"
																r.operationID = "domainDeleteReadContextRule"
																r.pathPattern = "/domains/{domainID}/control/read-context/{contextName}/config/{ruleID}"
																r.args = args
																r.count = 3
																return r, true
															case "PUT":
																// Leaf: DomainUpdateReadContextRule
																r.name = "DomainUpdateReadContextRule"
																r.summary = "Update a read context configuration rule"
																r.operationID = "domainUpdateReadContextRule"
																r.pathPattern = "/domains/{domainID}/control/read-context/{contextName}/config/{ruleID}"
																r.args = args
																r.count = 3
																return r, true
															default:
																return
															}
														}
													}
												case 'f': // Prefix: "flush"
													if l := len("flush"); len(elem) >= l && elem[0:l] == "flush" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														switch method {
														case "POST":
															// Leaf: DomainReadContextFlush
															r.name = "DomainReadContextFlush"
															r.summary = "Flush the read context cache"
															r.operationID = "domainReadContextFlush"
															r.pathPattern = "/domains/{domainID}/control/read-context/{contextName}/flush"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
												}
											}
										}
									case 's': // Prefix: "sources"
										if l := len("sources"); len(elem) >= l && elem[0:l] == "sources" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												// Leaf: DomainListResources
												r.name = "DomainListResources"
												r.summary = "Get a summary of access control resource paths"
												r.operationID = "domainListResources"
												r.pathPattern = "/domains/{domainID}/control/resources"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
									}
								case 's': // Prefix: "s"
									if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'e': // Prefix: "ettings"
										if l := len("ettings"); len(elem) >= l && elem[0:l] == "ettings" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												// Leaf: DomainGetSettings
												r.name = "DomainGetSettings"
												r.summary = "Get the domain settings"
												r.operationID = "domainGetSettings"
												r.pathPattern = "/domains/{domainID}/control/settings"
												r.args = args
												r.count = 1
												return r, true
											case "PATCH":
												// Leaf: DomainPatchSettings
												r.name = "DomainPatchSettings"
												r.summary = "Update the domain settings"
												r.operationID = "domainPatchSettings"
												r.pathPattern = "/domains/{domainID}/control/settings"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
									case 't': // Prefix: "tatus"
										if l := len("tatus"); len(elem) >= l && elem[0:l] == "tatus" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												// Leaf: DomainGetStatus
												r.name = "DomainGetStatus"
												r.summary = "Get the domain status"
												r.operationID = "domainGetStatus"
												r.pathPattern = "/domains/{domainID}/control/status"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
									}
								case 'v': // Prefix: "vendor/settings"
									if l := len("vendor/settings"); len(elem) >= l && elem[0:l] == "vendor/settings" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											// Leaf: DomainGetVendorSettings
											r.name = "DomainGetVendorSettings"
											r.summary = "Get vendor settings for the domain"
											r.operationID = "domainGetVendorSettings"
											r.pathPattern = "/domains/{domainID}/control/vendor/settings"
											r.args = args
											r.count = 1
											return r, true
										case "PUT":
											// Leaf: DomainPutVendorSettings
											r.name = "DomainPutVendorSettings"
											r.summary = "Create or update vendor settings"
											r.operationID = "domainPutVendorSettings"
											r.pathPattern = "/domains/{domainID}/control/vendor/settings"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								case 'w': // Prefix: "write-context"
									if l := len("write-context"); len(elem) >= l && elem[0:l] == "write-context" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = "DomainListWriteContexts"
											r.summary = "List domain write contexts"
											r.operationID = "domainListWriteContexts"
											r.pathPattern = "/domains/{domainID}/control/write-context"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "contextName"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch method {
											case "DELETE":
												r.name = "DomainDeleteWriteContext"
												r.summary = "Delete a write context"
												r.operationID = "domainDeleteWriteContext"
												r.pathPattern = "/domains/{domainID}/control/write-context/{contextName}"
												r.args = args
												r.count = 2
												return r, true
											case "GET":
												r.name = "DomainDescribeWriteContext"
												r.summary = "Describe a write context"
												r.operationID = "domainDescribeWriteContext"
												r.pathPattern = "/domains/{domainID}/control/write-context/{contextName}"
												r.args = args
												r.count = 2
												return r, true
											case "PUT":
												r.name = "DomainUpsertWriteContext"
												r.summary = "Upsert a write context"
												r.operationID = "domainUpsertWriteContext"
												r.pathPattern = "/domains/{domainID}/control/write-context/{contextName}"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"
											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'c': // Prefix: "config"
												if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "PUT":
														// Leaf: DomainUpsertWriteContextConfiguration
														r.name = "DomainUpsertWriteContextConfiguration"
														r.summary = "Update a write context configuration"
														r.operationID = "domainUpsertWriteContextConfiguration"
														r.pathPattern = "/domains/{domainID}/control/write-context/{contextName}/config"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
											case 'r': // Prefix: "regex-rule"
												if l := len("regex-rule"); len(elem) >= l && elem[0:l] == "regex-rule" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = "DomainGetWriteContextRegexRules"
														r.summary = ""
														r.operationID = "domainGetWriteContextRegexRules"
														r.pathPattern = "/domains/{domainID}/control/write-context/{contextName}/regex-rule"
														r.args = args
														r.count = 2
														return r, true
													case "POST":
														r.name = "DomainInsertWriteContextRegexRule"
														r.summary = "Insert a write context regex rule"
														r.operationID = "domainInsertWriteContextRegexRule"
														r.pathPattern = "/domains/{domainID}/control/write-context/{contextName}/regex-rule"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"
													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "ruleID"
													// Leaf parameter
													args[2] = elem
													elem = ""

													if len(elem) == 0 {
														switch method {
														case "DELETE":
															// Leaf: DomainDeleteWriteContextRegexRule
															r.name = "DomainDeleteWriteContextRegexRule"
															r.summary = ""
															r.operationID = "domainDeleteWriteContextRegexRule"
															r.pathPattern = "/domains/{domainID}/control/write-context/{contextName}/regex-rule/{ruleID}"
															r.args = args
															r.count = 3
															return r, true
														default:
															return
														}
													}
												}
											}
										}
									}
								}
							}
						case 'e': // Prefix: "encryption/flush"
							if l := len("encryption/flush"); len(elem) >= l && elem[0:l] == "encryption/flush" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "POST":
									// Leaf: DomainFlushEncryptionKeys
									r.name = "DomainFlushEncryptionKeys"
									r.summary = "Flush all encryption keys"
									r.operationID = "domainFlushEncryptionKeys"
									r.pathPattern = "/domains/{domainID}/encryption/flush"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						case 'h': // Prefix: "hooks"
							if l := len("hooks"); len(elem) >= l && elem[0:l] == "hooks" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "DomainListHooks"
									r.summary = "Lists available hooks"
									r.operationID = "domainListHooks"
									r.pathPattern = "/domains/{domainID}/hooks"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/data-tagging/"
								if l := len("/data-tagging/"); len(elem) >= l && elem[0:l] == "/data-tagging/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "hookName"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/invoke"
									if l := len("/invoke"); len(elem) >= l && elem[0:l] == "/invoke" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "POST":
											// Leaf: DomainDataTaggingHookInvoke
											r.name = "DomainDataTaggingHookInvoke"
											r.summary = "Invoke a hook"
											r.operationID = "domainDataTaggingHookInvoke"
											r.pathPattern = "/domains/{domainID}/hooks/data-tagging/{hookName}/invoke"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}
								}
							}
						case 'i': // Prefix: "info"
							if l := len("info"); len(elem) >= l && elem[0:l] == "info" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: DomainGetPrivateInfo
									r.name = "DomainGetPrivateInfo"
									r.summary = "Get the summary info for a Domain"
									r.operationID = "domainGetPrivateInfo"
									r.pathPattern = "/domains/{domainID}/info"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						case 'l': // Prefix: "log"
							if l := len("log"); len(elem) >= l && elem[0:l] == "log" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: DomainQueryAccessLog
									r.name = "DomainQueryAccessLog"
									r.summary = "Get the domain data-plane audit log"
									r.operationID = "domainQueryAccessLog"
									r.pathPattern = "/domains/{domainID}/log"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						case 'p': // Prefix: "p"
							if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'e': // Prefix: "eer-domain"
								if l := len("eer-domain"); len(elem) >= l && elem[0:l] == "eer-domain" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: DomainGetPeer
										r.name = "DomainGetPeer"
										r.summary = "Get a peer domain by nickname or alias"
										r.operationID = "domainGetPeer"
										r.pathPattern = "/domains/{domainID}/peer-domain"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										// Leaf: DomainCreatePeerDomain
										r.name = "DomainCreatePeerDomain"
										r.summary = "Create a peer domain"
										r.operationID = "domainCreatePeerDomain"
										r.pathPattern = "/domains/{domainID}/peer-domain"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							case 'u': // Prefix: "ublic-info"
								if l := len("ublic-info"); len(elem) >= l && elem[0:l] == "ublic-info" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: DomainGetPublicInfo
										r.name = "DomainGetPublicInfo"
										r.summary = "Get the public info for a Domain"
										r.operationID = "domainGetPublicInfo"
										r.pathPattern = "/domains/{domainID}/public-info"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							}
						case 't': // Prefix: "tag-info"
							if l := len("tag-info"); len(elem) >= l && elem[0:l] == "tag-info" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: DomainGetTagInfo
									r.name = "DomainGetTagInfo"
									r.summary = "Get an ordered list of the top 100 tags."
									r.operationID = "domainGetTagInfo"
									r.pathPattern = "/domains/{domainID}/tag-info"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						}
					}
				}
			case 'g': // Prefix: "global/starred-domains"
				if l := len("global/starred-domains"); len(elem) >= l && elem[0:l] == "global/starred-domains" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "GET":
						r.name = "StarredDomainList"
						r.summary = "List the user's starred domains"
						r.operationID = "starredDomainList"
						r.pathPattern = "/global/starred-domains"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "domainID"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						switch method {
						case "DELETE":
							// Leaf: StarredDomainRemove
							r.name = "StarredDomainRemove"
							r.summary = "Removes from starred domains"
							r.operationID = "starredDomainRemove"
							r.pathPattern = "/global/starred-domains/{domainID}"
							r.args = args
							r.count = 1
							return r, true
						case "PUT":
							// Leaf: StarredDomainAdd
							r.name = "StarredDomainAdd"
							r.summary = "Adds to starred domains"
							r.operationID = "starredDomainAdd"
							r.pathPattern = "/global/starred-domains/{domainID}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}
				}
			}
		}
	}
	return r, false
}
