// Code generated by ogen, DO NOT EDIT.

package spec

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *APIKeyDomainIdentityProviderDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIKeyDomainIdentityProviderDetails) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAPIKeyDomainIdentityProviderDetails = [0]string{}

// Decode decodes APIKeyDomainIdentityProviderDetails from json.
func (s *APIKeyDomainIdentityProviderDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIKeyDomainIdentityProviderDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			return d.Skip()
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode APIKeyDomainIdentityProviderDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIKeyDomainIdentityProviderDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIKeyDomainIdentityProviderDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AWSServiceAccountKeyInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AWSServiceAccountKeyInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("accessKeyID")
		e.Str(s.AccessKeyID)
	}
	{
		e.FieldStart("secretAccessKey")
		e.Str(s.SecretAccessKey)
	}
	{
		e.FieldStart("keyARN")
		e.Str(s.KeyARN)
	}
}

var jsonFieldsNameOfAWSServiceAccountKeyInfo = [3]string{
	0: "accessKeyID",
	1: "secretAccessKey",
	2: "keyARN",
}

// Decode decodes AWSServiceAccountKeyInfo from json.
func (s *AWSServiceAccountKeyInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AWSServiceAccountKeyInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accessKeyID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccessKeyID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accessKeyID\"")
			}
		case "secretAccessKey":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SecretAccessKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretAccessKey\"")
			}
		case "keyARN":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.KeyARN = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keyARN\"")
			}
		case "providerName":
			return d.Skip()
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AWSServiceAccountKeyInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAWSServiceAccountKeyInfo) {
					name = jsonFieldsNameOfAWSServiceAccountKeyInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AWSServiceAccountKeyInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AWSServiceAccountKeyInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AccessLogEntry) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AccessLogEntry) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	{
		e.FieldStart("time")
		json.EncodeDateTime(e, s.Time)
	}
	{
		e.FieldStart("domain")
		s.Domain.Encode(e)
	}
	{
		e.FieldStart("capsule")
		s.Capsule.Encode(e)
	}
	{
		e.FieldStart("operation")
		s.Operation.Encode(e)
	}
	{
		e.FieldStart("session")
		s.Session.Encode(e)
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
	{
		if s.CreateInfo.Set {
			e.FieldStart("createInfo")
			s.CreateInfo.Encode(e)
		}
	}
	{
		if s.OpenInfo.Set {
			e.FieldStart("openInfo")
			s.OpenInfo.Encode(e)
		}
	}
	{
		if s.ReadInfo.Set {
			e.FieldStart("readInfo")
			s.ReadInfo.Encode(e)
		}
	}
}

var jsonFieldsNameOfAccessLogEntry = [10]string{
	0: "id",
	1: "time",
	2: "domain",
	3: "capsule",
	4: "operation",
	5: "session",
	6: "location",
	7: "createInfo",
	8: "openInfo",
	9: "readInfo",
}

// Decode decodes AccessLogEntry from json.
func (s *AccessLogEntry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccessLogEntry to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "time":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Time = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		case "domain":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "capsule":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Capsule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capsule\"")
			}
		case "operation":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Operation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operation\"")
			}
		case "session":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Session.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "createInfo":
			if err := func() error {
				s.CreateInfo.Reset()
				if err := s.CreateInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createInfo\"")
			}
		case "openInfo":
			if err := func() error {
				s.OpenInfo.Reset()
				if err := s.OpenInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"openInfo\"")
			}
		case "readInfo":
			if err := func() error {
				s.ReadInfo.Reset()
				if err := s.ReadInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readInfo\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AccessLogEntry")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAccessLogEntry) {
					name = jsonFieldsNameOfAccessLogEntry[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AccessLogEntry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccessLogEntry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AccessLogEntryCreateInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AccessLogEntryCreateInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("writeContext")
		s.WriteContext.Encode(e)
	}
}

var jsonFieldsNameOfAccessLogEntryCreateInfo = [1]string{
	0: "writeContext",
}

// Decode decodes AccessLogEntryCreateInfo from json.
func (s *AccessLogEntryCreateInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccessLogEntryCreateInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "writeContext":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.WriteContext.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"writeContext\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AccessLogEntryCreateInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAccessLogEntryCreateInfo) {
					name = jsonFieldsNameOfAccessLogEntryCreateInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AccessLogEntryCreateInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccessLogEntryCreateInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AccessLogEntryOpenInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AccessLogEntryOpenInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("readContext")
		s.ReadContext.Encode(e)
	}
}

var jsonFieldsNameOfAccessLogEntryOpenInfo = [1]string{
	0: "readContext",
}

// Decode decodes AccessLogEntryOpenInfo from json.
func (s *AccessLogEntryOpenInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccessLogEntryOpenInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "readContext":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ReadContext.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readContext\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AccessLogEntryOpenInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAccessLogEntryOpenInfo) {
					name = jsonFieldsNameOfAccessLogEntryOpenInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AccessLogEntryOpenInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccessLogEntryOpenInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccessLogEntryOperation as json.
func (s AccessLogEntryOperation) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AccessLogEntryOperation from json.
func (s *AccessLogEntryOperation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccessLogEntryOperation to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AccessLogEntryOperation(v) {
	case AccessLogEntryOperationOpen:
		*s = AccessLogEntryOperationOpen
	case AccessLogEntryOperationRead:
		*s = AccessLogEntryOperationRead
	case AccessLogEntryOperationCreate:
		*s = AccessLogEntryOperationCreate
	default:
		*s = AccessLogEntryOperation(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AccessLogEntryOperation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccessLogEntryOperation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AccessLogEntryReadInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AccessLogEntryReadInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("parameters")
		s.Parameters.Encode(e)
	}
	{
		e.FieldStart("readContext")
		s.ReadContext.Encode(e)
	}
	{
		e.FieldStart("allowedTags")
		s.AllowedTags.Encode(e)
	}
	{
		e.FieldStart("redactedTags")
		s.RedactedTags.Encode(e)
	}
	{
		e.FieldStart("tokenizedTags")
		s.TokenizedTags.Encode(e)
	}
	{
		e.FieldStart("returnedRecords")
		e.Int(s.ReturnedRecords)
	}
	{
		e.FieldStart("filteredRecords")
		e.Int(s.FilteredRecords)
	}
}

var jsonFieldsNameOfAccessLogEntryReadInfo = [7]string{
	0: "parameters",
	1: "readContext",
	2: "allowedTags",
	3: "redactedTags",
	4: "tokenizedTags",
	5: "returnedRecords",
	6: "filteredRecords",
}

// Decode decodes AccessLogEntryReadInfo from json.
func (s *AccessLogEntryReadInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccessLogEntryReadInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "parameters":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		case "readContext":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ReadContext.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readContext\"")
			}
		case "allowedTags":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.AllowedTags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedTags\"")
			}
		case "redactedTags":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.RedactedTags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"redactedTags\"")
			}
		case "tokenizedTags":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.TokenizedTags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokenizedTags\"")
			}
		case "returnedRecords":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.ReturnedRecords = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"returnedRecords\"")
			}
		case "filteredRecords":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FilteredRecords = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filteredRecords\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AccessLogEntryReadInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAccessLogEntryReadInfo) {
					name = jsonFieldsNameOfAccessLogEntryReadInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AccessLogEntryReadInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccessLogEntryReadInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s AccessLogEntryReadInfoParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s AccessLogEntryReadInfoParameters) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes AccessLogEntryReadInfoParameters from json.
func (s *AccessLogEntryReadInfoParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccessLogEntryReadInfoParameters to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AccessLogEntryReadInfoParameters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AccessLogEntryReadInfoParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccessLogEntryReadInfoParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AccessLogResults) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AccessLogResults) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("results")
		e.ArrStart()
		for _, elem := range s.Results {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("has_more")
		e.Bool(s.HasMore)
	}
}

var jsonFieldsNameOfAccessLogResults = [2]string{
	0: "results",
	1: "has_more",
}

// Decode decodes AccessLogResults from json.
func (s *AccessLogResults) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccessLogResults to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "results":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Results = make([]AccessLogEntry, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AccessLogEntry
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		case "has_more":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_more\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AccessLogResults")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAccessLogResults) {
					name = jsonFieldsNameOfAccessLogResults[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AccessLogResults) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccessLogResults) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActiveRootEncryptionKeyID) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActiveRootEncryptionKeyID) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("keyID")
		s.KeyID.Encode(e)
	}
}

var jsonFieldsNameOfActiveRootEncryptionKeyID = [1]string{
	0: "keyID",
}

// Decode decodes ActiveRootEncryptionKeyID from json.
func (s *ActiveRootEncryptionKeyID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActiveRootEncryptionKeyID to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "keyID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.KeyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keyID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActiveRootEncryptionKeyID")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActiveRootEncryptionKeyID) {
					name = jsonFieldsNameOfActiveRootEncryptionKeyID[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActiveRootEncryptionKeyID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActiveRootEncryptionKeyID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddCapsuleLogEntryRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddCapsuleLogEntryRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("openToken")
		s.OpenToken.Encode(e)
	}
	{
		e.FieldStart("entry")
		s.Entry.Encode(e)
	}
}

var jsonFieldsNameOfAddCapsuleLogEntryRequest = [2]string{
	0: "openToken",
	1: "entry",
}

// Decode decodes AddCapsuleLogEntryRequest from json.
func (s *AddCapsuleLogEntryRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddCapsuleLogEntryRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "openToken":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.OpenToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"openToken\"")
			}
		case "entry":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Entry.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entry\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddCapsuleLogEntryRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddCapsuleLogEntryRequest) {
					name = jsonFieldsNameOfAddCapsuleLogEntryRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddCapsuleLogEntryRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddCapsuleLogEntryRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddReadContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddReadContext) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("summary")
		e.Str(s.Summary)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.DisableReadLogging.Set {
			e.FieldStart("disableReadLogging")
			s.DisableReadLogging.Encode(e)
		}
	}
	{
		if s.KeyCacheTTL.Set {
			e.FieldStart("keyCacheTTL")
			s.KeyCacheTTL.Encode(e)
		}
	}
	{
		if s.RequiredHooks != nil {
			e.FieldStart("requiredHooks")
			e.ArrStart()
			for _, elem := range s.RequiredHooks {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReadParameters != nil {
			e.FieldStart("readParameters")
			e.ArrStart()
			for _, elem := range s.ReadParameters {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAddReadContext = [6]string{
	0: "summary",
	1: "description",
	2: "disableReadLogging",
	3: "keyCacheTTL",
	4: "requiredHooks",
	5: "readParameters",
}

// Decode decodes AddReadContext from json.
func (s *AddReadContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddReadContext to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "summary":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Summary = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "disableReadLogging":
			if err := func() error {
				s.DisableReadLogging.Reset()
				if err := s.DisableReadLogging.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disableReadLogging\"")
			}
		case "keyCacheTTL":
			if err := func() error {
				s.KeyCacheTTL.Reset()
				if err := s.KeyCacheTTL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keyCacheTTL\"")
			}
		case "requiredHooks":
			if err := func() error {
				s.RequiredHooks = make([]ReadContextRequiredHook, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReadContextRequiredHook
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RequiredHooks = append(s.RequiredHooks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requiredHooks\"")
			}
		case "readParameters":
			if err := func() error {
				s.ReadParameters = make([]ReadContextParameter, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReadContextParameter
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ReadParameters = append(s.ReadParameters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readParameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddReadContext")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddReadContext) {
					name = jsonFieldsNameOfAddReadContext[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddReadContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddReadContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddWriteContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddWriteContext) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("summary")
		e.Str(s.Summary)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
}

var jsonFieldsNameOfAddWriteContext = [3]string{
	0: "summary",
	1: "description",
	2: "config",
}

// Decode decodes AddWriteContext from json.
func (s *AddWriteContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddWriteContext to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "summary":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Summary = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "config":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddWriteContext")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddWriteContext) {
					name = jsonFieldsNameOfAddWriteContext[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddWriteContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddWriteContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AntimatterDelegatedAWSKeyInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AntimatterDelegatedAWSKeyInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("keyARN")
		e.Str(s.KeyARN)
	}
}

var jsonFieldsNameOfAntimatterDelegatedAWSKeyInfo = [1]string{
	0: "keyARN",
}

// Decode decodes AntimatterDelegatedAWSKeyInfo from json.
func (s *AntimatterDelegatedAWSKeyInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AntimatterDelegatedAWSKeyInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "keyARN":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.KeyARN = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keyARN\"")
			}
		case "providerName":
			return d.Skip()
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AntimatterDelegatedAWSKeyInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAntimatterDelegatedAWSKeyInfo) {
					name = jsonFieldsNameOfAntimatterDelegatedAWSKeyInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AntimatterDelegatedAWSKeyInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AntimatterDelegatedAWSKeyInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AntimatterDelegatedGCPKeyInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AntimatterDelegatedGCPKeyInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("projectID")
		e.Str(s.ProjectID)
	}
	{
		e.FieldStart("location")
		e.Str(s.Location)
	}
	{
		e.FieldStart("keyringID")
		e.Str(s.KeyringID)
	}
	{
		e.FieldStart("keyID")
		e.Str(s.KeyID)
	}
}

var jsonFieldsNameOfAntimatterDelegatedGCPKeyInfo = [4]string{
	0: "projectID",
	1: "location",
	2: "keyringID",
	3: "keyID",
}

// Decode decodes AntimatterDelegatedGCPKeyInfo from json.
func (s *AntimatterDelegatedGCPKeyInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AntimatterDelegatedGCPKeyInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "projectID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ProjectID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectID\"")
			}
		case "location":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Location = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "keyringID":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.KeyringID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keyringID\"")
			}
		case "keyID":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.KeyID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keyID\"")
			}
		case "providerName":
			return d.Skip()
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AntimatterDelegatedGCPKeyInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAntimatterDelegatedGCPKeyInfo) {
					name = jsonFieldsNameOfAntimatterDelegatedGCPKeyInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AntimatterDelegatedGCPKeyInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AntimatterDelegatedGCPKeyInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AvailableDelegatedRootEncryptionKeyProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AvailableDelegatedRootEncryptionKeyProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("shortName")
		e.Str(s.ShortName)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("accountDetails")
		e.Str(s.AccountDetails)
	}
}

var jsonFieldsNameOfAvailableDelegatedRootEncryptionKeyProvider = [4]string{
	0: "name",
	1: "shortName",
	2: "description",
	3: "accountDetails",
}

// Decode decodes AvailableDelegatedRootEncryptionKeyProvider from json.
func (s *AvailableDelegatedRootEncryptionKeyProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AvailableDelegatedRootEncryptionKeyProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "shortName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ShortName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortName\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "accountDetails":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.AccountDetails = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountDetails\"")
			}
		case "type":
			return d.Skip()
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AvailableDelegatedRootEncryptionKeyProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAvailableDelegatedRootEncryptionKeyProvider) {
					name = jsonFieldsNameOfAvailableDelegatedRootEncryptionKeyProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AvailableDelegatedRootEncryptionKeyProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AvailableDelegatedRootEncryptionKeyProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AvailableRootEncryptionKeyProviders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AvailableRootEncryptionKeyProviders) encodeFields(e *jx.Encoder) {
	{
		if s.Providers != nil {
			e.FieldStart("providers")
			e.ArrStart()
			for _, elem := range s.Providers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAvailableRootEncryptionKeyProviders = [1]string{
	0: "providers",
}

// Decode decodes AvailableRootEncryptionKeyProviders from json.
func (s *AvailableRootEncryptionKeyProviders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AvailableRootEncryptionKeyProviders to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "providers":
			if err := func() error {
				s.Providers = make([]AvailableRootEncryptionKeyProvidersProvidersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AvailableRootEncryptionKeyProvidersProvidersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Providers = append(s.Providers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AvailableRootEncryptionKeyProviders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AvailableRootEncryptionKeyProviders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AvailableRootEncryptionKeyProviders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AvailableRootEncryptionKeyProvidersProvidersItem as json.
func (s AvailableRootEncryptionKeyProvidersProvidersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s AvailableRootEncryptionKeyProvidersProvidersItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case AvailableDelegatedRootEncryptionKeyProviderAvailableRootEncryptionKeyProvidersProvidersItem:
		e.FieldStart("type")
		e.Str("DelegatedRootEncryptionKeyProvider")
		s.AvailableDelegatedRootEncryptionKeyProvider.encodeFields(e)
	case AvailableServiceAccountRootEncryptionKeyProviderAvailableRootEncryptionKeyProvidersProvidersItem:
		e.FieldStart("type")
		e.Str("ServiceAccountRootEncryptionKeyProvider")
		s.AvailableServiceAccountRootEncryptionKeyProvider.encodeFields(e)
	}
}

// Decode decodes AvailableRootEncryptionKeyProvidersProvidersItem from json.
func (s *AvailableRootEncryptionKeyProvidersProvidersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AvailableRootEncryptionKeyProvidersProvidersItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "DelegatedRootEncryptionKeyProvider":
					s.Type = AvailableDelegatedRootEncryptionKeyProviderAvailableRootEncryptionKeyProvidersProvidersItem
					found = true
				case "ServiceAccountRootEncryptionKeyProvider":
					s.Type = AvailableServiceAccountRootEncryptionKeyProviderAvailableRootEncryptionKeyProvidersProvidersItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case AvailableDelegatedRootEncryptionKeyProviderAvailableRootEncryptionKeyProvidersProvidersItem:
		if err := s.AvailableDelegatedRootEncryptionKeyProvider.Decode(d); err != nil {
			return err
		}
	case AvailableServiceAccountRootEncryptionKeyProviderAvailableRootEncryptionKeyProvidersProvidersItem:
		if err := s.AvailableServiceAccountRootEncryptionKeyProvider.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AvailableRootEncryptionKeyProvidersProvidersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AvailableRootEncryptionKeyProvidersProvidersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AvailableServiceAccountRootEncryptionKeyProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AvailableServiceAccountRootEncryptionKeyProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("shortName")
		e.Str(s.ShortName)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
}

var jsonFieldsNameOfAvailableServiceAccountRootEncryptionKeyProvider = [3]string{
	0: "name",
	1: "shortName",
	2: "description",
}

// Decode decodes AvailableServiceAccountRootEncryptionKeyProvider from json.
func (s *AvailableServiceAccountRootEncryptionKeyProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AvailableServiceAccountRootEncryptionKeyProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "shortName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ShortName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortName\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "type":
			return d.Skip()
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AvailableServiceAccountRootEncryptionKeyProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAvailableServiceAccountRootEncryptionKeyProvider) {
					name = jsonFieldsNameOfAvailableServiceAccountRootEncryptionKeyProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AvailableServiceAccountRootEncryptionKeyProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AvailableServiceAccountRootEncryptionKeyProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BYOKKeyInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BYOKKeyInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Base64(s.Key)
	}
}

var jsonFieldsNameOfBYOKKeyInfo = [1]string{
	0: "key",
}

// Decode decodes BYOKKeyInfo from json.
func (s *BYOKKeyInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BYOKKeyInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Base64()
				s.Key = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "providerName":
			return d.Skip()
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BYOKKeyInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBYOKKeyInfo) {
					name = jsonFieldsNameOfBYOKKeyInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BYOKKeyInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BYOKKeyInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Capability) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Capability) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfCapability = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes Capability from json.
func (s *Capability) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Capability to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Capability")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCapability) {
					name = jsonFieldsNameOfCapability[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Capability) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Capability) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CapabilityDefinition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CapabilityDefinition) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("unary")
		e.Bool(s.Unary)
	}
	{
		e.FieldStart("summary")
		e.Str(s.Summary)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("imported")
		e.Bool(s.Imported)
	}
	{
		if s.SourceDomainID.Set {
			e.FieldStart("sourceDomainID")
			s.SourceDomainID.Encode(e)
		}
	}
	{
		if s.SourceDomainName.Set {
			e.FieldStart("sourceDomainName")
			s.SourceDomainName.Encode(e)
		}
	}
}

var jsonFieldsNameOfCapabilityDefinition = [7]string{
	0: "name",
	1: "unary",
	2: "summary",
	3: "description",
	4: "imported",
	5: "sourceDomainID",
	6: "sourceDomainName",
}

// Decode decodes CapabilityDefinition from json.
func (s *CapabilityDefinition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CapabilityDefinition to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "unary":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Unary = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unary\"")
			}
		case "summary":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Summary = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "imported":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Imported = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imported\"")
			}
		case "sourceDomainID":
			if err := func() error {
				s.SourceDomainID.Reset()
				if err := s.SourceDomainID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sourceDomainID\"")
			}
		case "sourceDomainName":
			if err := func() error {
				s.SourceDomainName.Reset()
				if err := s.SourceDomainName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sourceDomainName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CapabilityDefinition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCapabilityDefinition) {
					name = jsonFieldsNameOfCapabilityDefinition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CapabilityDefinition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CapabilityDefinition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CapabilityDefinitionList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CapabilityDefinitionList) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("capabilities")
		e.ArrStart()
		for _, elem := range s.Capabilities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCapabilityDefinitionList = [1]string{
	0: "capabilities",
}

// Decode decodes CapabilityDefinitionList from json.
func (s *CapabilityDefinitionList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CapabilityDefinitionList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "capabilities":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Capabilities = make([]CapabilityDefinition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CapabilityDefinition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Capabilities = append(s.Capabilities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capabilities\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CapabilityDefinitionList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCapabilityDefinitionList) {
					name = jsonFieldsNameOfCapabilityDefinitionList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CapabilityDefinitionList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CapabilityDefinitionList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CapabilityList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CapabilityList) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("capabilities")
		e.ArrStart()
		for _, elem := range s.Capabilities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCapabilityList = [1]string{
	0: "capabilities",
}

// Decode decodes CapabilityList from json.
func (s *CapabilityList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CapabilityList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "capabilities":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Capabilities = make([]Capability, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Capability
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Capabilities = append(s.Capabilities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capabilities\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CapabilityList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCapabilityList) {
					name = jsonFieldsNameOfCapabilityList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CapabilityList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CapabilityList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CapabilityName as json.
func (s CapabilityName) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes CapabilityName from json.
func (s *CapabilityName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CapabilityName to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CapabilityName(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CapabilityName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CapabilityName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CapabilityReference as json.
func (s CapabilityReference) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes CapabilityReference from json.
func (s *CapabilityReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CapabilityReference to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CapabilityReference(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CapabilityReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CapabilityReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CapabilityRule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CapabilityRule) encodeFields(e *jx.Encoder) {
	{
		if s.MatchExpressions != nil {
			e.FieldStart("matchExpressions")
			e.ArrStart()
			for _, elem := range s.MatchExpressions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCapabilityRule = [1]string{
	0: "matchExpressions",
}

// Decode decodes CapabilityRule from json.
func (s *CapabilityRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CapabilityRule to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchExpressions":
			if err := func() error {
				s.MatchExpressions = make([]CapabilityRuleMatchExpressionsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CapabilityRuleMatchExpressionsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchExpressions = append(s.MatchExpressions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchExpressions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CapabilityRule")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CapabilityRule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CapabilityRule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CapabilityRuleMatchExpressionsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CapabilityRuleMatchExpressionsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("operator")
		s.Operator.Encode(e)
	}
	{
		e.FieldStart("values")
		e.ArrStart()
		for _, elem := range s.Values {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCapabilityRuleMatchExpressionsItem = [3]string{
	0: "name",
	1: "operator",
	2: "values",
}

// Decode decodes CapabilityRuleMatchExpressionsItem from json.
func (s *CapabilityRuleMatchExpressionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CapabilityRuleMatchExpressionsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Operator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "values":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Values = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CapabilityRuleMatchExpressionsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCapabilityRuleMatchExpressionsItem) {
					name = jsonFieldsNameOfCapabilityRuleMatchExpressionsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CapabilityRuleMatchExpressionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CapabilityRuleMatchExpressionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CapabilityRuleMatchExpressionsItemOperator as json.
func (s CapabilityRuleMatchExpressionsItemOperator) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CapabilityRuleMatchExpressionsItemOperator from json.
func (s *CapabilityRuleMatchExpressionsItemOperator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CapabilityRuleMatchExpressionsItemOperator to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CapabilityRuleMatchExpressionsItemOperator(v) {
	case CapabilityRuleMatchExpressionsItemOperatorIn:
		*s = CapabilityRuleMatchExpressionsItemOperatorIn
	case CapabilityRuleMatchExpressionsItemOperatorNotIn:
		*s = CapabilityRuleMatchExpressionsItemOperatorNotIn
	case CapabilityRuleMatchExpressionsItemOperatorExists:
		*s = CapabilityRuleMatchExpressionsItemOperatorExists
	case CapabilityRuleMatchExpressionsItemOperatorNotExists:
		*s = CapabilityRuleMatchExpressionsItemOperatorNotExists
	default:
		*s = CapabilityRuleMatchExpressionsItemOperator(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CapabilityRuleMatchExpressionsItemOperator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CapabilityRuleMatchExpressionsItemOperator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CapsuleCreateResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CapsuleCreateResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	{
		e.FieldStart("dataKey")
		e.Base64(s.DataKey)
	}
	{
		e.FieldStart("encryptedDataKey")
		e.Base64(s.EncryptedDataKey)
	}
	{
		e.FieldStart("keyEncryptionKeyID")
		e.Int64(s.KeyEncryptionKeyID)
	}
	{
		e.FieldStart("createToken")
		s.CreateToken.Encode(e)
	}
	{
		e.FieldStart("writeContextConfiguration")
		s.WriteContextConfiguration.Encode(e)
	}
}

var jsonFieldsNameOfCapsuleCreateResponse = [6]string{
	0: "id",
	1: "dataKey",
	2: "encryptedDataKey",
	3: "keyEncryptionKeyID",
	4: "createToken",
	5: "writeContextConfiguration",
}

// Decode decodes CapsuleCreateResponse from json.
func (s *CapsuleCreateResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CapsuleCreateResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "dataKey":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Base64()
				s.DataKey = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataKey\"")
			}
		case "encryptedDataKey":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Base64()
				s.EncryptedDataKey = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encryptedDataKey\"")
			}
		case "keyEncryptionKeyID":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int64()
				s.KeyEncryptionKeyID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keyEncryptionKeyID\"")
			}
		case "createToken":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.CreateToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createToken\"")
			}
		case "writeContextConfiguration":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.WriteContextConfiguration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"writeContextConfiguration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CapsuleCreateResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCapsuleCreateResponse) {
					name = jsonFieldsNameOfCapsuleCreateResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CapsuleCreateResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CapsuleCreateResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CapsuleID as json.
func (s CapsuleID) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes CapsuleID from json.
func (s *CapsuleID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CapsuleID to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CapsuleID(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CapsuleID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CapsuleID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CapsuleInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CapsuleInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	{
		e.FieldStart("domain")
		s.Domain.Encode(e)
	}
	{
		e.FieldStart("capsuleTags")
		e.ArrStart()
		for _, elem := range s.CapsuleTags {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("spanTags")
		s.SpanTags.Encode(e)
	}
	{
		e.FieldStart("size")
		e.Int64(s.Size)
	}
	{
		e.FieldStart("created")
		json.EncodeDateTime(e, s.Created)
	}
	{
		if s.PageKey.Set {
			e.FieldStart("pageKey")
			s.PageKey.Encode(e)
		}
	}
}

var jsonFieldsNameOfCapsuleInfo = [7]string{
	0: "id",
	1: "domain",
	2: "capsuleTags",
	3: "spanTags",
	4: "size",
	5: "created",
	6: "pageKey",
}

// Decode decodes CapsuleInfo from json.
func (s *CapsuleInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CapsuleInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "domain":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "capsuleTags":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.CapsuleTags = make([]Tag, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Tag
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CapsuleTags = append(s.CapsuleTags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capsuleTags\"")
			}
		case "spanTags":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.SpanTags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spanTags\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int64()
				s.Size = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "created":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Created = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created\"")
			}
		case "pageKey":
			if err := func() error {
				s.PageKey.Reset()
				if err := s.PageKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageKey\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CapsuleInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCapsuleInfo) {
					name = jsonFieldsNameOfCapsuleInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CapsuleInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CapsuleInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CapsuleList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CapsuleList) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("results")
		e.ArrStart()
		for _, elem := range s.Results {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("has_more")
		e.Bool(s.HasMore)
	}
}

var jsonFieldsNameOfCapsuleList = [2]string{
	0: "results",
	1: "has_more",
}

// Decode decodes CapsuleList from json.
func (s *CapsuleList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CapsuleList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "results":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Results = make([]CapsuleInfo, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CapsuleInfo
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		case "has_more":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_more\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CapsuleList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCapsuleList) {
					name = jsonFieldsNameOfCapsuleList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CapsuleList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CapsuleList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CapsuleOpenRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CapsuleOpenRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("encryptedDek")
		e.Base64(s.EncryptedDek)
	}
	{
		e.FieldStart("keyID")
		e.Int64(s.KeyID)
	}
}

var jsonFieldsNameOfCapsuleOpenRequest = [2]string{
	0: "encryptedDek",
	1: "keyID",
}

// Decode decodes CapsuleOpenRequest from json.
func (s *CapsuleOpenRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CapsuleOpenRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "encryptedDek":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Base64()
				s.EncryptedDek = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encryptedDek\"")
			}
		case "keyID":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.KeyID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keyID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CapsuleOpenRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCapsuleOpenRequest) {
					name = jsonFieldsNameOfCapsuleOpenRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CapsuleOpenRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CapsuleOpenRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CapsuleOpenResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CapsuleOpenResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("decryptionKey")
		e.Base64(s.DecryptionKey)
	}
	{
		e.FieldStart("readContextConfiguration")
		s.ReadContextConfiguration.Encode(e)
	}
	{
		e.FieldStart("openToken")
		s.OpenToken.Encode(e)
	}
	{
		e.FieldStart("capsuleTags")
		e.ArrStart()
		for _, elem := range s.CapsuleTags {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCapsuleOpenResponse = [4]string{
	0: "decryptionKey",
	1: "readContextConfiguration",
	2: "openToken",
	3: "capsuleTags",
}

// Decode decodes CapsuleOpenResponse from json.
func (s *CapsuleOpenResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CapsuleOpenResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "decryptionKey":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Base64()
				s.DecryptionKey = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"decryptionKey\"")
			}
		case "readContextConfiguration":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ReadContextConfiguration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readContextConfiguration\"")
			}
		case "openToken":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.OpenToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"openToken\"")
			}
		case "capsuleTags":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.CapsuleTags = make([]Tag, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Tag
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CapsuleTags = append(s.CapsuleTags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capsuleTags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CapsuleOpenResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCapsuleOpenResponse) {
					name = jsonFieldsNameOfCapsuleOpenResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CapsuleOpenResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CapsuleOpenResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CapsuleOpenResponseReadContextConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CapsuleOpenResponseReadContextConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.DisableReadLogging.Set {
			e.FieldStart("disableReadLogging")
			s.DisableReadLogging.Encode(e)
		}
	}
	{
		if s.KeyCacheTTL.Set {
			e.FieldStart("keyCacheTTL")
			s.KeyCacheTTL.Encode(e)
		}
	}
	{
		e.FieldStart("policyAssembly")
		e.Base64(s.PolicyAssembly)
	}
}

var jsonFieldsNameOfCapsuleOpenResponseReadContextConfiguration = [3]string{
	0: "disableReadLogging",
	1: "keyCacheTTL",
	2: "policyAssembly",
}

// Decode decodes CapsuleOpenResponseReadContextConfiguration from json.
func (s *CapsuleOpenResponseReadContextConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CapsuleOpenResponseReadContextConfiguration to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "disableReadLogging":
			if err := func() error {
				s.DisableReadLogging.Reset()
				if err := s.DisableReadLogging.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disableReadLogging\"")
			}
		case "keyCacheTTL":
			if err := func() error {
				s.KeyCacheTTL.Reset()
				if err := s.KeyCacheTTL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keyCacheTTL\"")
			}
		case "policyAssembly":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Base64()
				s.PolicyAssembly = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"policyAssembly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CapsuleOpenResponseReadContextConfiguration")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCapsuleOpenResponseReadContextConfiguration) {
					name = jsonFieldsNameOfCapsuleOpenResponseReadContextConfiguration[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CapsuleOpenResponseReadContextConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CapsuleOpenResponseReadContextConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CapsuleOperationToken as json.
func (s CapsuleOperationToken) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes CapsuleOperationToken from json.
func (s *CapsuleOperationToken) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CapsuleOperationToken to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CapsuleOperationToken(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CapsuleOperationToken) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CapsuleOperationToken) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CapsuleSealRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CapsuleSealRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("capsuleTags")
		e.ArrStart()
		for _, elem := range s.CapsuleTags {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("spanTags")
		s.SpanTags.Encode(e)
	}
	{
		e.FieldStart("size")
		e.Int64(s.Size)
	}
	{
		e.FieldStart("createToken")
		s.CreateToken.Encode(e)
	}
}

var jsonFieldsNameOfCapsuleSealRequest = [4]string{
	0: "capsuleTags",
	1: "spanTags",
	2: "size",
	3: "createToken",
}

// Decode decodes CapsuleSealRequest from json.
func (s *CapsuleSealRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CapsuleSealRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "capsuleTags":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.CapsuleTags = make([]Tag, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Tag
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CapsuleTags = append(s.CapsuleTags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capsuleTags\"")
			}
		case "spanTags":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.SpanTags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spanTags\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Size = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "createToken":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.CreateToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createToken\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CapsuleSealRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCapsuleSealRequest) {
					name = jsonFieldsNameOfCapsuleSealRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CapsuleSealRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CapsuleSealRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConflictError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConflictError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("resourceType")
		e.Str(s.ResourceType)
	}
	{
		e.FieldStart("identifier")
		e.Str(s.Identifier)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfConflictError = [3]string{
	0: "resourceType",
	1: "identifier",
	2: "message",
}

// Decode decodes ConflictError from json.
func (s *ConflictError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConflictError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ResourceType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "identifier":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Identifier = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identifier\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConflictError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConflictError) {
					name = jsonFieldsNameOfConflictError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConflictError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConflictError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreatePeerDomain) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreatePeerDomain) encodeFields(e *jx.Encoder) {
	{
		if s.Nicknames != nil {
			e.FieldStart("nicknames")
			e.ArrStart()
			for _, elem := range s.Nicknames {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ImportAliasForParent.Set {
			e.FieldStart("importAliasForParent")
			s.ImportAliasForParent.Encode(e)
		}
	}
	{
		e.FieldStart("importAliasForChild")
		s.ImportAliasForChild.Encode(e)
	}
	{
		if s.DisplayNameForParent.Set {
			e.FieldStart("displayNameForParent")
			s.DisplayNameForParent.Encode(e)
		}
	}
	{
		e.FieldStart("displayNameForChild")
		e.Str(s.DisplayNameForChild)
	}
	{
		if s.LinkAll.Set {
			e.FieldStart("linkAll")
			s.LinkAll.Encode(e)
		}
	}
	{
		if s.LinkIdentityProviders.Set {
			e.FieldStart("linkIdentityProviders")
			s.LinkIdentityProviders.Encode(e)
		}
	}
	{
		if s.LinkFacts.Set {
			e.FieldStart("linkFacts")
			s.LinkFacts.Encode(e)
		}
	}
	{
		if s.LinkReadContexts.Set {
			e.FieldStart("linkReadContexts")
			s.LinkReadContexts.Encode(e)
		}
	}
	{
		if s.LinkWriteContexts.Set {
			e.FieldStart("linkWriteContexts")
			s.LinkWriteContexts.Encode(e)
		}
	}
	{
		if s.LinkCapabilities.Set {
			e.FieldStart("linkCapabilities")
			s.LinkCapabilities.Encode(e)
		}
	}
	{
		if s.LinkDomainPolicy.Set {
			e.FieldStart("linkDomainPolicy")
			s.LinkDomainPolicy.Encode(e)
		}
	}
	{
		if s.LinkCapsuleAccessLog.Set {
			e.FieldStart("linkCapsuleAccessLog")
			s.LinkCapsuleAccessLog.Encode(e)
		}
	}
	{
		if s.LinkControlLog.Set {
			e.FieldStart("linkControlLog")
			s.LinkControlLog.Encode(e)
		}
	}
	{
		if s.LinkCapsuleManifest.Set {
			e.FieldStart("linkCapsuleManifest")
			s.LinkCapsuleManifest.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreatePeerDomain = [15]string{
	0:  "nicknames",
	1:  "importAliasForParent",
	2:  "importAliasForChild",
	3:  "displayNameForParent",
	4:  "displayNameForChild",
	5:  "linkAll",
	6:  "linkIdentityProviders",
	7:  "linkFacts",
	8:  "linkReadContexts",
	9:  "linkWriteContexts",
	10: "linkCapabilities",
	11: "linkDomainPolicy",
	12: "linkCapsuleAccessLog",
	13: "linkControlLog",
	14: "linkCapsuleManifest",
}

// Decode decodes CreatePeerDomain from json.
func (s *CreatePeerDomain) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreatePeerDomain to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nicknames":
			if err := func() error {
				s.Nicknames = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Nicknames = append(s.Nicknames, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nicknames\"")
			}
		case "importAliasForParent":
			if err := func() error {
				s.ImportAliasForParent.Reset()
				if err := s.ImportAliasForParent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importAliasForParent\"")
			}
		case "importAliasForChild":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ImportAliasForChild.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importAliasForChild\"")
			}
		case "displayNameForParent":
			if err := func() error {
				s.DisplayNameForParent.Reset()
				if err := s.DisplayNameForParent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayNameForParent\"")
			}
		case "displayNameForChild":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.DisplayNameForChild = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayNameForChild\"")
			}
		case "linkAll":
			if err := func() error {
				s.LinkAll.Reset()
				if err := s.LinkAll.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"linkAll\"")
			}
		case "linkIdentityProviders":
			if err := func() error {
				s.LinkIdentityProviders.Reset()
				if err := s.LinkIdentityProviders.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"linkIdentityProviders\"")
			}
		case "linkFacts":
			if err := func() error {
				s.LinkFacts.Reset()
				if err := s.LinkFacts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"linkFacts\"")
			}
		case "linkReadContexts":
			if err := func() error {
				s.LinkReadContexts.Reset()
				if err := s.LinkReadContexts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"linkReadContexts\"")
			}
		case "linkWriteContexts":
			if err := func() error {
				s.LinkWriteContexts.Reset()
				if err := s.LinkWriteContexts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"linkWriteContexts\"")
			}
		case "linkCapabilities":
			if err := func() error {
				s.LinkCapabilities.Reset()
				if err := s.LinkCapabilities.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"linkCapabilities\"")
			}
		case "linkDomainPolicy":
			if err := func() error {
				s.LinkDomainPolicy.Reset()
				if err := s.LinkDomainPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"linkDomainPolicy\"")
			}
		case "linkCapsuleAccessLog":
			if err := func() error {
				s.LinkCapsuleAccessLog.Reset()
				if err := s.LinkCapsuleAccessLog.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"linkCapsuleAccessLog\"")
			}
		case "linkControlLog":
			if err := func() error {
				s.LinkControlLog.Reset()
				if err := s.LinkControlLog.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"linkControlLog\"")
			}
		case "linkCapsuleManifest":
			if err := func() error {
				s.LinkCapsuleManifest.Reset()
				if err := s.LinkCapsuleManifest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"linkCapsuleManifest\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreatePeerDomain")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010100,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreatePeerDomain) {
					name = jsonFieldsNameOfCreatePeerDomain[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreatePeerDomain) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreatePeerDomain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataTaggingHookInput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataTaggingHookInput) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("records")
		e.ArrStart()
		for _, elem := range s.Records {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDataTaggingHookInput = [1]string{
	0: "records",
}

// Decode decodes DataTaggingHookInput from json.
func (s *DataTaggingHookInput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataTaggingHookInput to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "records":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Records = make([]DataTaggingHookInputRecordsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DataTaggingHookInputRecordsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Records = append(s.Records, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"records\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataTaggingHookInput")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataTaggingHookInput) {
					name = jsonFieldsNameOfDataTaggingHookInput[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataTaggingHookInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataTaggingHookInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataTaggingHookInputRecordsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataTaggingHookInputRecordsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("elements")
		e.ArrStart()
		for _, elem := range s.Elements {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDataTaggingHookInputRecordsItem = [1]string{
	0: "elements",
}

// Decode decodes DataTaggingHookInputRecordsItem from json.
func (s *DataTaggingHookInputRecordsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataTaggingHookInputRecordsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Elements = make([]DataTaggingHookInputRecordsItemElementsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DataTaggingHookInputRecordsItemElementsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataTaggingHookInputRecordsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataTaggingHookInputRecordsItem) {
					name = jsonFieldsNameOfDataTaggingHookInputRecordsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataTaggingHookInputRecordsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataTaggingHookInputRecordsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataTaggingHookInputRecordsItemElementsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataTaggingHookInputRecordsItemElementsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("content")
		e.Str(s.Content)
	}
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
}

var jsonFieldsNameOfDataTaggingHookInputRecordsItemElementsItem = [2]string{
	0: "content",
	1: "path",
}

// Decode decodes DataTaggingHookInputRecordsItemElementsItem from json.
func (s *DataTaggingHookInputRecordsItemElementsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataTaggingHookInputRecordsItemElementsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Content = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataTaggingHookInputRecordsItemElementsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataTaggingHookInputRecordsItemElementsItem) {
					name = jsonFieldsNameOfDataTaggingHookInputRecordsItemElementsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataTaggingHookInputRecordsItemElementsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataTaggingHookInputRecordsItemElementsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataTaggingHookResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataTaggingHookResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("records")
		e.ArrStart()
		for _, elem := range s.Records {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDataTaggingHookResponse = [2]string{
	0: "version",
	1: "records",
}

// Decode decodes DataTaggingHookResponse from json.
func (s *DataTaggingHookResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataTaggingHookResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "records":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Records = make([]DataTaggingHookResponseRecordsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DataTaggingHookResponseRecordsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Records = append(s.Records, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"records\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataTaggingHookResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataTaggingHookResponse) {
					name = jsonFieldsNameOfDataTaggingHookResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataTaggingHookResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataTaggingHookResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataTaggingHookResponseRecordsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataTaggingHookResponseRecordsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("elements")
		e.ArrStart()
		for _, elem := range s.Elements {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDataTaggingHookResponseRecordsItem = [1]string{
	0: "elements",
}

// Decode decodes DataTaggingHookResponseRecordsItem from json.
func (s *DataTaggingHookResponseRecordsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataTaggingHookResponseRecordsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elements":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Elements = make([]TagSet, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TagSet
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Elements = append(s.Elements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elements\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataTaggingHookResponseRecordsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataTaggingHookResponseRecordsItem) {
					name = jsonFieldsNameOfDataTaggingHookResponseRecordsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataTaggingHookResponseRecordsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataTaggingHookResponseRecordsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteTags) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteTags) encodeFields(e *jx.Encoder) {
	{
		if s.Names != nil {
			e.FieldStart("names")
			e.ArrStart()
			for _, elem := range s.Names {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDeleteTags = [1]string{
	0: "names",
}

// Decode decodes DeleteTags from json.
func (s *DeleteTags) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteTags to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "names":
			if err := func() error {
				s.Names = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Names = append(s.Names, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"names\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteTags")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteTags) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteTags) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Domain) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Domain) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		s.ID.Encode(e)
	}
}

var jsonFieldsNameOfDomain = [1]string{
	0: "id",
}

// Decode decodes Domain from json.
func (s *Domain) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Domain to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Domain")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomain) {
					name = jsonFieldsNameOfDomain[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Domain) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Domain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainAddReadContextRuleOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainAddReadContextRuleOK) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
}

var jsonFieldsNameOfDomainAddReadContextRuleOK = [1]string{
	0: "id",
}

// Decode decodes DomainAddReadContextRuleOK from json.
func (s *DomainAddReadContextRuleOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainAddReadContextRuleOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainAddReadContextRuleOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainAddReadContextRuleOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainAddReadContextRuleOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainAuthenticate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainAuthenticate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("token")
		e.Str(s.Token)
	}
}

var jsonFieldsNameOfDomainAuthenticate = [1]string{
	0: "token",
}

// Decode decodes DomainAuthenticate from json.
func (s *DomainAuthenticate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainAuthenticate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainAuthenticate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainAuthenticate) {
					name = jsonFieldsNameOfDomainAuthenticate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainAuthenticate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainAuthenticate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainAuthenticateResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainAuthenticateResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("token")
		e.Str(s.Token)
	}
	{
		if s.Expiry.Set {
			e.FieldStart("expiry")
			s.Expiry.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfDomainAuthenticateResponse = [2]string{
	0: "token",
	1: "expiry",
}

// Decode decodes DomainAuthenticateResponse from json.
func (s *DomainAuthenticateResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainAuthenticateResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "expiry":
			if err := func() error {
				s.Expiry.Reset()
				if err := s.Expiry.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiry\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainAuthenticateResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainAuthenticateResponse) {
					name = jsonFieldsNameOfDomainAuthenticateResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainAuthenticateResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainAuthenticateResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainContactIssueVerifyReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainContactIssueVerifyReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("adminEmail")
		e.Str(s.AdminEmail)
	}
}

var jsonFieldsNameOfDomainContactIssueVerifyReq = [1]string{
	0: "adminEmail",
}

// Decode decodes DomainContactIssueVerifyReq from json.
func (s *DomainContactIssueVerifyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainContactIssueVerifyReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "adminEmail":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AdminEmail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"adminEmail\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainContactIssueVerifyReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainContactIssueVerifyReq) {
					name = jsonFieldsNameOfDomainContactIssueVerifyReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainContactIssueVerifyReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainContactIssueVerifyReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainControlLogEntry) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainControlLogEntry) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("domain")
		s.Domain.Encode(e)
	}
	{
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	{
		e.FieldStart("time")
		json.EncodeDateTime(e, s.Time)
	}
	{
		e.FieldStart("session")
		s.Session.Encode(e)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("summary")
		e.Str(s.Summary)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
}

var jsonFieldsNameOfDomainControlLogEntry = [7]string{
	0: "domain",
	1: "id",
	2: "time",
	3: "session",
	4: "url",
	5: "summary",
	6: "description",
}

// Decode decodes DomainControlLogEntry from json.
func (s *DomainControlLogEntry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainControlLogEntry to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domain":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "time":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Time = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		case "session":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Session.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "summary":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Summary = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainControlLogEntry")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainControlLogEntry) {
					name = jsonFieldsNameOfDomainControlLogEntry[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainControlLogEntry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainControlLogEntry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DomainControlLogEntryDescription) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DomainControlLogEntryDescription) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes DomainControlLogEntryDescription from json.
func (s *DomainControlLogEntryDescription) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainControlLogEntryDescription to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainControlLogEntryDescription")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DomainControlLogEntryDescription) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainControlLogEntryDescription) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainControlLogResults) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainControlLogResults) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("results")
		e.ArrStart()
		for _, elem := range s.Results {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("has_more")
		e.Bool(s.HasMore)
	}
}

var jsonFieldsNameOfDomainControlLogResults = [2]string{
	0: "results",
	1: "has_more",
}

// Decode decodes DomainControlLogResults from json.
func (s *DomainControlLogResults) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainControlLogResults to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "results":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Results = make([]DomainControlLogEntry, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DomainControlLogEntry
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		case "has_more":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_more\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainControlLogResults")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainControlLogResults) {
					name = jsonFieldsNameOfDomainControlLogResults[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainControlLogResults) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainControlLogResults) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainCreateCapsuleReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainCreateCapsuleReq) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDomainCreateCapsuleReq = [0]string{}

// Decode decodes DomainCreateCapsuleReq from json.
func (s *DomainCreateCapsuleReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainCreateCapsuleReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode DomainCreateCapsuleReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainCreateCapsuleReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainCreateCapsuleReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainExternalRootEncryptionKeyTestReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainExternalRootEncryptionKeyTestReq) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDomainExternalRootEncryptionKeyTestReq = [0]string{}

// Decode decodes DomainExternalRootEncryptionKeyTestReq from json.
func (s *DomainExternalRootEncryptionKeyTestReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainExternalRootEncryptionKeyTestReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode DomainExternalRootEncryptionKeyTestReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainExternalRootEncryptionKeyTestReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainExternalRootEncryptionKeyTestReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainFactList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainFactList) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("factTypes")
		e.ArrStart()
		for _, elem := range s.FactTypes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDomainFactList = [1]string{
	0: "factTypes",
}

// Decode decodes DomainFactList from json.
func (s *DomainFactList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainFactList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "factTypes":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.FactTypes = make([]FactTypeDefinition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FactTypeDefinition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FactTypes = append(s.FactTypes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"factTypes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainFactList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainFactList) {
					name = jsonFieldsNameOfDomainFactList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainFactList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainFactList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainFlushEncryptionKeysReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainFlushEncryptionKeysReq) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDomainFlushEncryptionKeysReq = [0]string{}

// Decode decodes DomainFlushEncryptionKeysReq from json.
func (s *DomainFlushEncryptionKeysReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainFlushEncryptionKeysReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode DomainFlushEncryptionKeysReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainFlushEncryptionKeysReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainFlushEncryptionKeysReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DomainGetWriteContextRegexRulesOKApplicationJSON as json.
func (s DomainGetWriteContextRegexRulesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []WriteContextRegexRule(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes DomainGetWriteContextRegexRulesOKApplicationJSON from json.
func (s *DomainGetWriteContextRegexRulesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainGetWriteContextRegexRulesOKApplicationJSON to nil")
	}
	var unwrapped []WriteContextRegexRule
	if err := func() error {
		unwrapped = make([]WriteContextRegexRule, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem WriteContextRegexRule
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DomainGetWriteContextRegexRulesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DomainGetWriteContextRegexRulesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainGetWriteContextRegexRulesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainHooksList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainHooksList) encodeFields(e *jx.Encoder) {
	{
		if s.Hooks != nil {
			e.FieldStart("hooks")
			e.ArrStart()
			for _, elem := range s.Hooks {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDomainHooksList = [1]string{
	0: "hooks",
}

// Decode decodes DomainHooksList from json.
func (s *DomainHooksList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainHooksList to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hooks":
			if err := func() error {
				s.Hooks = make([]DomainHooksListHooksItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DomainHooksListHooksItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Hooks = append(s.Hooks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainHooksList")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainHooksList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainHooksList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainHooksListHooksItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainHooksListHooksItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("summary")
		e.Str(s.Summary)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("outputSpanTags")
		e.ArrStart()
		for _, elem := range s.OutputSpanTags {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("outputCapsuleTags")
		e.ArrStart()
		for _, elem := range s.OutputCapsuleTags {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDomainHooksListHooksItem = [7]string{
	0: "name",
	1: "url",
	2: "version",
	3: "summary",
	4: "description",
	5: "outputSpanTags",
	6: "outputCapsuleTags",
}

// Decode decodes DomainHooksListHooksItem from json.
func (s *DomainHooksListHooksItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainHooksListHooksItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "summary":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Summary = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "outputSpanTags":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.OutputSpanTags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.OutputSpanTags = append(s.OutputSpanTags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outputSpanTags\"")
			}
		case "outputCapsuleTags":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.OutputCapsuleTags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.OutputCapsuleTags = append(s.OutputCapsuleTags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outputCapsuleTags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainHooksListHooksItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainHooksListHooksItem) {
					name = jsonFieldsNameOfDomainHooksListHooksItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainHooksListHooksItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainHooksListHooksItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DomainID as json.
func (s DomainID) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes DomainID from json.
func (s *DomainID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainID to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DomainID(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DomainID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainIdentityAPIKeyPrincipalParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainIdentityAPIKeyPrincipalParams) encodeFields(e *jx.Encoder) {
	{
		if s.ApiKeyID.Set {
			e.FieldStart("apiKeyID")
			s.ApiKeyID.Encode(e)
		}
	}
	{
		if s.Comment.Set {
			e.FieldStart("comment")
			s.Comment.Encode(e)
		}
	}
}

var jsonFieldsNameOfDomainIdentityAPIKeyPrincipalParams = [2]string{
	0: "apiKeyID",
	1: "comment",
}

// Decode decodes DomainIdentityAPIKeyPrincipalParams from json.
func (s *DomainIdentityAPIKeyPrincipalParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainIdentityAPIKeyPrincipalParams to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiKeyID":
			if err := func() error {
				s.ApiKeyID.Reset()
				if err := s.ApiKeyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiKeyID\"")
			}
		case "comment":
			if err := func() error {
				s.Comment.Reset()
				if err := s.Comment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comment\"")
			}
		case "type":
			return d.Skip()
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainIdentityAPIKeyPrincipalParams")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainIdentityAPIKeyPrincipalParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainIdentityAPIKeyPrincipalParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainIdentityEmailPrincipalParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainIdentityEmailPrincipalParams) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		if s.Comment.Set {
			e.FieldStart("comment")
			s.Comment.Encode(e)
		}
	}
}

var jsonFieldsNameOfDomainIdentityEmailPrincipalParams = [2]string{
	0: "email",
	1: "comment",
}

// Decode decodes DomainIdentityEmailPrincipalParams from json.
func (s *DomainIdentityEmailPrincipalParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainIdentityEmailPrincipalParams to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "comment":
			if err := func() error {
				s.Comment.Reset()
				if err := s.Comment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comment\"")
			}
		case "type":
			return d.Skip()
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainIdentityEmailPrincipalParams")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainIdentityEmailPrincipalParams) {
					name = jsonFieldsNameOfDomainIdentityEmailPrincipalParams[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainIdentityEmailPrincipalParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainIdentityEmailPrincipalParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainIdentityHostedDomainPrincipalParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainIdentityHostedDomainPrincipalParams) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hostedDomain")
		e.Str(s.HostedDomain)
	}
	{
		if s.Comment.Set {
			e.FieldStart("comment")
			s.Comment.Encode(e)
		}
	}
}

var jsonFieldsNameOfDomainIdentityHostedDomainPrincipalParams = [2]string{
	0: "hostedDomain",
	1: "comment",
}

// Decode decodes DomainIdentityHostedDomainPrincipalParams from json.
func (s *DomainIdentityHostedDomainPrincipalParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainIdentityHostedDomainPrincipalParams to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hostedDomain":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HostedDomain = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostedDomain\"")
			}
		case "comment":
			if err := func() error {
				s.Comment.Reset()
				if err := s.Comment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comment\"")
			}
		case "type":
			return d.Skip()
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainIdentityHostedDomainPrincipalParams")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainIdentityHostedDomainPrincipalParams) {
					name = jsonFieldsNameOfDomainIdentityHostedDomainPrincipalParams[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainIdentityHostedDomainPrincipalParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainIdentityHostedDomainPrincipalParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DomainIdentityPrincipalDetails as json.
func (s DomainIdentityPrincipalDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s DomainIdentityPrincipalDetails) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case DomainIdentityAPIKeyPrincipalParamsDomainIdentityPrincipalDetails:
		e.FieldStart("type")
		e.Str("APIKey")
		s.DomainIdentityAPIKeyPrincipalParams.encodeFields(e)
	case DomainIdentityEmailPrincipalParamsDomainIdentityPrincipalDetails:
		e.FieldStart("type")
		e.Str("Email")
		s.DomainIdentityEmailPrincipalParams.encodeFields(e)
	case DomainIdentityHostedDomainPrincipalParamsDomainIdentityPrincipalDetails:
		e.FieldStart("type")
		e.Str("HostedDomain")
		s.DomainIdentityHostedDomainPrincipalParams.encodeFields(e)
	}
}

// Decode decodes DomainIdentityPrincipalDetails from json.
func (s *DomainIdentityPrincipalDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainIdentityPrincipalDetails to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "APIKey":
					s.Type = DomainIdentityAPIKeyPrincipalParamsDomainIdentityPrincipalDetails
					found = true
				case "Email":
					s.Type = DomainIdentityEmailPrincipalParamsDomainIdentityPrincipalDetails
					found = true
				case "HostedDomain":
					s.Type = DomainIdentityHostedDomainPrincipalParamsDomainIdentityPrincipalDetails
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case DomainIdentityAPIKeyPrincipalParamsDomainIdentityPrincipalDetails:
		if err := s.DomainIdentityAPIKeyPrincipalParams.Decode(d); err != nil {
			return err
		}
	case DomainIdentityEmailPrincipalParamsDomainIdentityPrincipalDetails:
		if err := s.DomainIdentityEmailPrincipalParams.Decode(d); err != nil {
			return err
		}
	case DomainIdentityHostedDomainPrincipalParamsDomainIdentityPrincipalDetails:
		if err := s.DomainIdentityHostedDomainPrincipalParams.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DomainIdentityPrincipalDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainIdentityPrincipalDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DomainIdentityProviderDetails as json.
func (s DomainIdentityProviderDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s DomainIdentityProviderDetails) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case APIKeyDomainIdentityProviderDetailsDomainIdentityProviderDetails:
		e.FieldStart("type")
		e.Str("APIKey")
		s.APIKeyDomainIdentityProviderDetails.encodeFields(e)
	case GoogleOAuthDomainIdentityProviderDetailsDomainIdentityProviderDetails:
		e.FieldStart("type")
		e.Str("GoogleOAuth")
		s.GoogleOAuthDomainIdentityProviderDetails.encodeFields(e)
	}
}

// Decode decodes DomainIdentityProviderDetails from json.
func (s *DomainIdentityProviderDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainIdentityProviderDetails to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "APIKey":
					s.Type = APIKeyDomainIdentityProviderDetailsDomainIdentityProviderDetails
					found = true
				case "GoogleOAuth":
					s.Type = GoogleOAuthDomainIdentityProviderDetailsDomainIdentityProviderDetails
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case GoogleOAuthDomainIdentityProviderDetailsDomainIdentityProviderDetails:
		if err := s.GoogleOAuthDomainIdentityProviderDetails.Decode(d); err != nil {
			return err
		}
	case APIKeyDomainIdentityProviderDetailsDomainIdentityProviderDetails:
		if err := s.APIKeyDomainIdentityProviderDetails.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DomainIdentityProviderDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainIdentityProviderDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainIdentityProviderInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainIdentityProviderInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("imported")
		e.Bool(s.Imported)
	}
	{
		if s.SourceDomainID.Set {
			e.FieldStart("sourceDomainID")
			s.SourceDomainID.Encode(e)
		}
	}
	{
		if s.SourceDomainName.Set {
			e.FieldStart("sourceDomainName")
			s.SourceDomainName.Encode(e)
		}
	}
	{
		e.FieldStart("supportedPrincipals")
		e.ArrStart()
		for _, elem := range s.SupportedPrincipals {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Details.Set {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfDomainIdentityProviderInfo = [7]string{
	0: "name",
	1: "type",
	2: "imported",
	3: "sourceDomainID",
	4: "sourceDomainName",
	5: "supportedPrincipals",
	6: "details",
}

// Decode decodes DomainIdentityProviderInfo from json.
func (s *DomainIdentityProviderInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainIdentityProviderInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "imported":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Imported = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imported\"")
			}
		case "sourceDomainID":
			if err := func() error {
				s.SourceDomainID.Reset()
				if err := s.SourceDomainID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sourceDomainID\"")
			}
		case "sourceDomainName":
			if err := func() error {
				s.SourceDomainName.Reset()
				if err := s.SourceDomainName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sourceDomainName\"")
			}
		case "supportedPrincipals":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.SupportedPrincipals = make([]DomainIdentityProviderPrincipalType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DomainIdentityProviderPrincipalType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SupportedPrincipals = append(s.SupportedPrincipals, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supportedPrincipals\"")
			}
		case "details":
			if err := func() error {
				s.Details.Reset()
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainIdentityProviderInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainIdentityProviderInfo) {
					name = jsonFieldsNameOfDomainIdentityProviderInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainIdentityProviderInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainIdentityProviderInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainIdentityProviderList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainIdentityProviderList) encodeFields(e *jx.Encoder) {
	{
		if s.IdentityProviders != nil {
			e.FieldStart("identityProviders")
			e.ArrStart()
			for _, elem := range s.IdentityProviders {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDomainIdentityProviderList = [1]string{
	0: "identityProviders",
}

// Decode decodes DomainIdentityProviderList from json.
func (s *DomainIdentityProviderList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainIdentityProviderList to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "identityProviders":
			if err := func() error {
				s.IdentityProviders = make([]DomainIdentityProviderInfo, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DomainIdentityProviderInfo
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.IdentityProviders = append(s.IdentityProviders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identityProviders\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainIdentityProviderList")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainIdentityProviderList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainIdentityProviderList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainIdentityProviderPrincipalList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainIdentityProviderPrincipalList) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("principals")
		e.ArrStart()
		for _, elem := range s.Principals {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDomainIdentityProviderPrincipalList = [1]string{
	0: "principals",
}

// Decode decodes DomainIdentityProviderPrincipalList from json.
func (s *DomainIdentityProviderPrincipalList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainIdentityProviderPrincipalList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "principals":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Principals = make([]PrincipalSummary, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PrincipalSummary
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Principals = append(s.Principals, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"principals\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainIdentityProviderPrincipalList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainIdentityProviderPrincipalList) {
					name = jsonFieldsNameOfDomainIdentityProviderPrincipalList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainIdentityProviderPrincipalList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainIdentityProviderPrincipalList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainIdentityProviderPrincipalParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainIdentityProviderPrincipalParams) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("capabilities")
		e.ArrStart()
		for _, elem := range s.Capabilities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("details")
		s.Details.Encode(e)
	}
}

var jsonFieldsNameOfDomainIdentityProviderPrincipalParams = [2]string{
	0: "capabilities",
	1: "details",
}

// Decode decodes DomainIdentityProviderPrincipalParams from json.
func (s *DomainIdentityProviderPrincipalParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainIdentityProviderPrincipalParams to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "capabilities":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Capabilities = make([]Capability, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Capability
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Capabilities = append(s.Capabilities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capabilities\"")
			}
		case "details":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainIdentityProviderPrincipalParams")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainIdentityProviderPrincipalParams) {
					name = jsonFieldsNameOfDomainIdentityProviderPrincipalParams[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainIdentityProviderPrincipalParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainIdentityProviderPrincipalParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DomainIdentityProviderPrincipalType as json.
func (s DomainIdentityProviderPrincipalType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DomainIdentityProviderPrincipalType from json.
func (s *DomainIdentityProviderPrincipalType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainIdentityProviderPrincipalType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DomainIdentityProviderPrincipalType(v) {
	case DomainIdentityProviderPrincipalTypeAPIKey:
		*s = DomainIdentityProviderPrincipalTypeAPIKey
	case DomainIdentityProviderPrincipalTypeEmail:
		*s = DomainIdentityProviderPrincipalTypeEmail
	case DomainIdentityProviderPrincipalTypeHostedDomain:
		*s = DomainIdentityProviderPrincipalTypeHostedDomain
	default:
		*s = DomainIdentityProviderPrincipalType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DomainIdentityProviderPrincipalType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainIdentityProviderPrincipalType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DomainIdentityProviderType as json.
func (s DomainIdentityProviderType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DomainIdentityProviderType from json.
func (s *DomainIdentityProviderType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainIdentityProviderType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DomainIdentityProviderType(v) {
	case DomainIdentityProviderTypeGoogleOAuth:
		*s = DomainIdentityProviderTypeGoogleOAuth
	case DomainIdentityProviderTypeGCPServiceAccount:
		*s = DomainIdentityProviderTypeGCPServiceAccount
	case DomainIdentityProviderTypeAPIKey:
		*s = DomainIdentityProviderTypeAPIKey
	default:
		*s = DomainIdentityProviderType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DomainIdentityProviderType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainIdentityProviderType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainInsertIdentityProviderPrincipalOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainInsertIdentityProviderPrincipalOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("principalID")
		s.PrincipalID.Encode(e)
	}
	{
		if s.ApiKey.Set {
			e.FieldStart("apiKey")
			s.ApiKey.Encode(e)
		}
	}
}

var jsonFieldsNameOfDomainInsertIdentityProviderPrincipalOK = [2]string{
	0: "principalID",
	1: "apiKey",
}

// Decode decodes DomainInsertIdentityProviderPrincipalOK from json.
func (s *DomainInsertIdentityProviderPrincipalOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainInsertIdentityProviderPrincipalOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "principalID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.PrincipalID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"principalID\"")
			}
		case "apiKey":
			if err := func() error {
				s.ApiKey.Reset()
				if err := s.ApiKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiKey\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainInsertIdentityProviderPrincipalOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainInsertIdentityProviderPrincipalOK) {
					name = jsonFieldsNameOfDomainInsertIdentityProviderPrincipalOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainInsertIdentityProviderPrincipalOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainInsertIdentityProviderPrincipalOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainInsertWriteContextRegexRuleOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainInsertWriteContextRegexRuleOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ruleID")
		s.RuleID.Encode(e)
	}
}

var jsonFieldsNameOfDomainInsertWriteContextRegexRuleOK = [1]string{
	0: "ruleID",
}

// Decode decodes DomainInsertWriteContextRegexRuleOK from json.
func (s *DomainInsertWriteContextRegexRuleOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainInsertWriteContextRegexRuleOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ruleID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.RuleID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ruleID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainInsertWriteContextRegexRuleOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainInsertWriteContextRegexRuleOK) {
					name = jsonFieldsNameOfDomainInsertWriteContextRegexRuleOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainInsertWriteContextRegexRuleOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainInsertWriteContextRegexRuleOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainPeerConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainPeerConfig) encodeFields(e *jx.Encoder) {
	{
		if s.ExportIdentityProviders != nil {
			e.FieldStart("exportIdentityProviders")
			e.ArrStart()
			for _, elem := range s.ExportIdentityProviders {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExportAllIdentityProviders.Set {
			e.FieldStart("exportAllIdentityProviders")
			s.ExportAllIdentityProviders.Encode(e)
		}
	}
	{
		if s.ExportFacts != nil {
			e.FieldStart("exportFacts")
			e.ArrStart()
			for _, elem := range s.ExportFacts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExportAllFacts.Set {
			e.FieldStart("exportAllFacts")
			s.ExportAllFacts.Encode(e)
		}
	}
	{
		if s.ExportReadContexts != nil {
			e.FieldStart("exportReadContexts")
			e.ArrStart()
			for _, elem := range s.ExportReadContexts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExportAllReadContexts.Set {
			e.FieldStart("exportAllReadContexts")
			s.ExportAllReadContexts.Encode(e)
		}
	}
	{
		if s.ExportWriteContexts != nil {
			e.FieldStart("exportWriteContexts")
			e.ArrStart()
			for _, elem := range s.ExportWriteContexts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExportAllWriteContexts.Set {
			e.FieldStart("exportAllWriteContexts")
			s.ExportAllWriteContexts.Encode(e)
		}
	}
	{
		if s.ExportCapabilities != nil {
			e.FieldStart("exportCapabilities")
			e.ArrStart()
			for _, elem := range s.ExportCapabilities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExportAllCapabilities.Set {
			e.FieldStart("exportAllCapabilities")
			s.ExportAllCapabilities.Encode(e)
		}
	}
	{
		if s.ExportDomainPolicy.Set {
			e.FieldStart("exportDomainPolicy")
			s.ExportDomainPolicy.Encode(e)
		}
	}
	{
		if s.ExportCapsuleAccessLog.Set {
			e.FieldStart("exportCapsuleAccessLog")
			s.ExportCapsuleAccessLog.Encode(e)
		}
	}
	{
		if s.ExportControlLog.Set {
			e.FieldStart("exportControlLog")
			s.ExportControlLog.Encode(e)
		}
	}
	{
		if s.ExportCapsuleManifest.Set {
			e.FieldStart("exportCapsuleManifest")
			s.ExportCapsuleManifest.Encode(e)
		}
	}
	{
		if s.ExportBilling.Set {
			e.FieldStart("exportBilling")
			s.ExportBilling.Encode(e)
		}
	}
	{
		if s.ExportAdminContact.Set {
			e.FieldStart("exportAdminContact")
			s.ExportAdminContact.Encode(e)
		}
	}
	{
		if s.Nicknames != nil {
			e.FieldStart("nicknames")
			e.ArrStart()
			for _, elem := range s.Nicknames {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ImportAlias.Set {
			e.FieldStart("importAlias")
			s.ImportAlias.Encode(e)
		}
	}
	{
		if s.ForwardBilling.Set {
			e.FieldStart("forwardBilling")
			s.ForwardBilling.Encode(e)
		}
	}
	{
		if s.ForwardAdminCommunications.Set {
			e.FieldStart("forwardAdminCommunications")
			s.ForwardAdminCommunications.Encode(e)
		}
	}
	{
		if s.ImportIdentityProviders != nil {
			e.FieldStart("importIdentityProviders")
			e.ArrStart()
			for _, elem := range s.ImportIdentityProviders {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ImportAllIdentityProviders.Set {
			e.FieldStart("importAllIdentityProviders")
			s.ImportAllIdentityProviders.Encode(e)
		}
	}
	{
		if s.ImportFacts != nil {
			e.FieldStart("importFacts")
			e.ArrStart()
			for _, elem := range s.ImportFacts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ImportAllFacts.Set {
			e.FieldStart("importAllFacts")
			s.ImportAllFacts.Encode(e)
		}
	}
	{
		if s.ImportReadContexts != nil {
			e.FieldStart("importReadContexts")
			e.ArrStart()
			for _, elem := range s.ImportReadContexts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ImportAllReadContexts.Set {
			e.FieldStart("importAllReadContexts")
			s.ImportAllReadContexts.Encode(e)
		}
	}
	{
		if s.ImportWriteContexts != nil {
			e.FieldStart("importWriteContexts")
			e.ArrStart()
			for _, elem := range s.ImportWriteContexts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ImportAllWriteContexts.Set {
			e.FieldStart("importAllWriteContexts")
			s.ImportAllWriteContexts.Encode(e)
		}
	}
	{
		if s.ImportCapabilities != nil {
			e.FieldStart("importCapabilities")
			e.ArrStart()
			for _, elem := range s.ImportCapabilities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ImportAllCapabilities.Set {
			e.FieldStart("importAllCapabilities")
			s.ImportAllCapabilities.Encode(e)
		}
	}
	{
		if s.ImportDomainPolicy.Set {
			e.FieldStart("importDomainPolicy")
			s.ImportDomainPolicy.Encode(e)
		}
	}
	{
		if s.ImportPrecedence.Set {
			e.FieldStart("importPrecedence")
			s.ImportPrecedence.Encode(e)
		}
	}
	{
		if s.ImportCapsuleAccessLog.Set {
			e.FieldStart("importCapsuleAccessLog")
			s.ImportCapsuleAccessLog.Encode(e)
		}
	}
	{
		if s.ImportControlLog.Set {
			e.FieldStart("importControlLog")
			s.ImportControlLog.Encode(e)
		}
	}
	{
		if s.ImportCapsuleManifest.Set {
			e.FieldStart("importCapsuleManifest")
			s.ImportCapsuleManifest.Encode(e)
		}
	}
	{
		e.FieldStart("displayName")
		e.Str(s.DisplayName)
	}
}

var jsonFieldsNameOfDomainPeerConfig = [36]string{
	0:  "exportIdentityProviders",
	1:  "exportAllIdentityProviders",
	2:  "exportFacts",
	3:  "exportAllFacts",
	4:  "exportReadContexts",
	5:  "exportAllReadContexts",
	6:  "exportWriteContexts",
	7:  "exportAllWriteContexts",
	8:  "exportCapabilities",
	9:  "exportAllCapabilities",
	10: "exportDomainPolicy",
	11: "exportCapsuleAccessLog",
	12: "exportControlLog",
	13: "exportCapsuleManifest",
	14: "exportBilling",
	15: "exportAdminContact",
	16: "nicknames",
	17: "importAlias",
	18: "forwardBilling",
	19: "forwardAdminCommunications",
	20: "importIdentityProviders",
	21: "importAllIdentityProviders",
	22: "importFacts",
	23: "importAllFacts",
	24: "importReadContexts",
	25: "importAllReadContexts",
	26: "importWriteContexts",
	27: "importAllWriteContexts",
	28: "importCapabilities",
	29: "importAllCapabilities",
	30: "importDomainPolicy",
	31: "importPrecedence",
	32: "importCapsuleAccessLog",
	33: "importControlLog",
	34: "importCapsuleManifest",
	35: "displayName",
}

// Decode decodes DomainPeerConfig from json.
func (s *DomainPeerConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainPeerConfig to nil")
	}
	var requiredBitSet [5]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "exportIdentityProviders":
			if err := func() error {
				s.ExportIdentityProviders = make([]IdentityProviderName, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IdentityProviderName
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExportIdentityProviders = append(s.ExportIdentityProviders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exportIdentityProviders\"")
			}
		case "exportAllIdentityProviders":
			if err := func() error {
				s.ExportAllIdentityProviders.Reset()
				if err := s.ExportAllIdentityProviders.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exportAllIdentityProviders\"")
			}
		case "exportFacts":
			if err := func() error {
				s.ExportFacts = make([]FactTypeName, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FactTypeName
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExportFacts = append(s.ExportFacts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exportFacts\"")
			}
		case "exportAllFacts":
			if err := func() error {
				s.ExportAllFacts.Reset()
				if err := s.ExportAllFacts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exportAllFacts\"")
			}
		case "exportReadContexts":
			if err := func() error {
				s.ExportReadContexts = make([]ReadContextName, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReadContextName
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExportReadContexts = append(s.ExportReadContexts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exportReadContexts\"")
			}
		case "exportAllReadContexts":
			if err := func() error {
				s.ExportAllReadContexts.Reset()
				if err := s.ExportAllReadContexts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exportAllReadContexts\"")
			}
		case "exportWriteContexts":
			if err := func() error {
				s.ExportWriteContexts = make([]WriteContextName, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WriteContextName
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExportWriteContexts = append(s.ExportWriteContexts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exportWriteContexts\"")
			}
		case "exportAllWriteContexts":
			if err := func() error {
				s.ExportAllWriteContexts.Reset()
				if err := s.ExportAllWriteContexts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exportAllWriteContexts\"")
			}
		case "exportCapabilities":
			if err := func() error {
				s.ExportCapabilities = make([]CapabilityName, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CapabilityName
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExportCapabilities = append(s.ExportCapabilities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exportCapabilities\"")
			}
		case "exportAllCapabilities":
			if err := func() error {
				s.ExportAllCapabilities.Reset()
				if err := s.ExportAllCapabilities.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exportAllCapabilities\"")
			}
		case "exportDomainPolicy":
			if err := func() error {
				s.ExportDomainPolicy.Reset()
				if err := s.ExportDomainPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exportDomainPolicy\"")
			}
		case "exportCapsuleAccessLog":
			if err := func() error {
				s.ExportCapsuleAccessLog.Reset()
				if err := s.ExportCapsuleAccessLog.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exportCapsuleAccessLog\"")
			}
		case "exportControlLog":
			if err := func() error {
				s.ExportControlLog.Reset()
				if err := s.ExportControlLog.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exportControlLog\"")
			}
		case "exportCapsuleManifest":
			if err := func() error {
				s.ExportCapsuleManifest.Reset()
				if err := s.ExportCapsuleManifest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exportCapsuleManifest\"")
			}
		case "exportBilling":
			if err := func() error {
				s.ExportBilling.Reset()
				if err := s.ExportBilling.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exportBilling\"")
			}
		case "exportAdminContact":
			if err := func() error {
				s.ExportAdminContact.Reset()
				if err := s.ExportAdminContact.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exportAdminContact\"")
			}
		case "nicknames":
			if err := func() error {
				s.Nicknames = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Nicknames = append(s.Nicknames, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nicknames\"")
			}
		case "importAlias":
			if err := func() error {
				s.ImportAlias.Reset()
				if err := s.ImportAlias.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importAlias\"")
			}
		case "forwardBilling":
			if err := func() error {
				s.ForwardBilling.Reset()
				if err := s.ForwardBilling.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forwardBilling\"")
			}
		case "forwardAdminCommunications":
			if err := func() error {
				s.ForwardAdminCommunications.Reset()
				if err := s.ForwardAdminCommunications.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forwardAdminCommunications\"")
			}
		case "importIdentityProviders":
			if err := func() error {
				s.ImportIdentityProviders = make([]IdentityProviderName, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IdentityProviderName
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ImportIdentityProviders = append(s.ImportIdentityProviders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importIdentityProviders\"")
			}
		case "importAllIdentityProviders":
			if err := func() error {
				s.ImportAllIdentityProviders.Reset()
				if err := s.ImportAllIdentityProviders.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importAllIdentityProviders\"")
			}
		case "importFacts":
			if err := func() error {
				s.ImportFacts = make([]FactTypeName, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FactTypeName
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ImportFacts = append(s.ImportFacts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importFacts\"")
			}
		case "importAllFacts":
			if err := func() error {
				s.ImportAllFacts.Reset()
				if err := s.ImportAllFacts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importAllFacts\"")
			}
		case "importReadContexts":
			if err := func() error {
				s.ImportReadContexts = make([]ReadContextName, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReadContextName
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ImportReadContexts = append(s.ImportReadContexts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importReadContexts\"")
			}
		case "importAllReadContexts":
			if err := func() error {
				s.ImportAllReadContexts.Reset()
				if err := s.ImportAllReadContexts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importAllReadContexts\"")
			}
		case "importWriteContexts":
			if err := func() error {
				s.ImportWriteContexts = make([]WriteContextName, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WriteContextName
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ImportWriteContexts = append(s.ImportWriteContexts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importWriteContexts\"")
			}
		case "importAllWriteContexts":
			if err := func() error {
				s.ImportAllWriteContexts.Reset()
				if err := s.ImportAllWriteContexts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importAllWriteContexts\"")
			}
		case "importCapabilities":
			if err := func() error {
				s.ImportCapabilities = make([]CapabilityName, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CapabilityName
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ImportCapabilities = append(s.ImportCapabilities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importCapabilities\"")
			}
		case "importAllCapabilities":
			if err := func() error {
				s.ImportAllCapabilities.Reset()
				if err := s.ImportAllCapabilities.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importAllCapabilities\"")
			}
		case "importDomainPolicy":
			if err := func() error {
				s.ImportDomainPolicy.Reset()
				if err := s.ImportDomainPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importDomainPolicy\"")
			}
		case "importPrecedence":
			if err := func() error {
				s.ImportPrecedence.Reset()
				if err := s.ImportPrecedence.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importPrecedence\"")
			}
		case "importCapsuleAccessLog":
			if err := func() error {
				s.ImportCapsuleAccessLog.Reset()
				if err := s.ImportCapsuleAccessLog.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importCapsuleAccessLog\"")
			}
		case "importControlLog":
			if err := func() error {
				s.ImportControlLog.Reset()
				if err := s.ImportControlLog.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importControlLog\"")
			}
		case "importCapsuleManifest":
			if err := func() error {
				s.ImportCapsuleManifest.Reset()
				if err := s.ImportCapsuleManifest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importCapsuleManifest\"")
			}
		case "displayName":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainPeerConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [5]uint8{
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainPeerConfig) {
					name = jsonFieldsNameOfDomainPeerConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainPeerConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainPeerConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainPeerList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainPeerList) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("peers")
		e.ArrStart()
		for _, elem := range s.Peers {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDomainPeerList = [1]string{
	0: "peers",
}

// Decode decodes DomainPeerList from json.
func (s *DomainPeerList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainPeerList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "peers":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Peers = make([]DomainPeerListPeersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DomainPeerListPeersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Peers = append(s.Peers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"peers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainPeerList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainPeerList) {
					name = jsonFieldsNameOfDomainPeerList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainPeerList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainPeerList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainPeerListPeersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainPeerListPeersItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	{
		e.FieldStart("alias")
		s.Alias.Encode(e)
	}
}

var jsonFieldsNameOfDomainPeerListPeersItem = [2]string{
	0: "id",
	1: "alias",
}

// Decode decodes DomainPeerListPeersItem from json.
func (s *DomainPeerListPeersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainPeerListPeersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "alias":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Alias.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alias\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainPeerListPeersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainPeerListPeersItem) {
					name = jsonFieldsNameOfDomainPeerListPeersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainPeerListPeersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainPeerListPeersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainPolicy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainPolicy) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("rules")
		e.ArrStart()
		for _, elem := range s.Rules {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDomainPolicy = [1]string{
	0: "rules",
}

// Decode decodes DomainPolicy from json.
func (s *DomainPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainPolicy to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rules":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Rules = make([]DomainPolicyRule, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DomainPolicyRule
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rules = append(s.Rules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainPolicy")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainPolicy) {
					name = jsonFieldsNameOfDomainPolicy[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainPolicyRule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainPolicyRule) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	{
		if s.DomainIdentity.Set {
			e.FieldStart("domainIdentity")
			s.DomainIdentity.Encode(e)
		}
	}
	{
		if s.Facts != nil {
			e.FieldStart("facts")
			s.Facts.Encode(e)
		}
	}
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
	{
		e.FieldStart("operation")
		s.Operation.Encode(e)
	}
	{
		e.FieldStart("result")
		s.Result.Encode(e)
	}
	{
		e.FieldStart("priority")
		e.Int(s.Priority)
	}
	{
		e.FieldStart("disabled")
		e.Bool(s.Disabled)
	}
	{
		e.FieldStart("imported")
		e.Bool(s.Imported)
	}
	{
		if s.SourceDomainID.Set {
			e.FieldStart("sourceDomainID")
			s.SourceDomainID.Encode(e)
		}
	}
	{
		if s.SourceDomainName.Set {
			e.FieldStart("sourceDomainName")
			s.SourceDomainName.Encode(e)
		}
	}
	{
		e.FieldStart("precedence")
		e.Int(s.Precedence)
	}
	{
		if s.Invalid.Set {
			e.FieldStart("invalid")
			s.Invalid.Encode(e)
		}
	}
}

var jsonFieldsNameOfDomainPolicyRule = [13]string{
	0:  "id",
	1:  "domainIdentity",
	2:  "facts",
	3:  "path",
	4:  "operation",
	5:  "result",
	6:  "priority",
	7:  "disabled",
	8:  "imported",
	9:  "sourceDomainID",
	10: "sourceDomainName",
	11: "precedence",
	12: "invalid",
}

// Decode decodes DomainPolicyRule from json.
func (s *DomainPolicyRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainPolicyRule to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "domainIdentity":
			if err := func() error {
				s.DomainIdentity.Reset()
				if err := s.DomainIdentity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainIdentity\"")
			}
		case "facts":
			if err := func() error {
				if err := s.Facts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"facts\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "operation":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Operation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operation\"")
			}
		case "result":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "priority":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Priority = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "disabled":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.Disabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled\"")
			}
		case "imported":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Imported = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imported\"")
			}
		case "sourceDomainID":
			if err := func() error {
				s.SourceDomainID.Reset()
				if err := s.SourceDomainID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sourceDomainID\"")
			}
		case "sourceDomainName":
			if err := func() error {
				s.SourceDomainName.Reset()
				if err := s.SourceDomainName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sourceDomainName\"")
			}
		case "precedence":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Precedence = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"precedence\"")
			}
		case "invalid":
			if err := func() error {
				s.Invalid.Reset()
				if err := s.Invalid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invalid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainPolicyRule")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111001,
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainPolicyRule) {
					name = jsonFieldsNameOfDomainPolicyRule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainPolicyRule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainPolicyRule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainPrivateInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainPrivateInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("defaultDisplayName")
		e.Str(s.DefaultDisplayName)
	}
	{
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	{
		e.FieldStart("identityProviders")
		e.ArrStart()
		for _, elem := range s.IdentityProviders {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDomainPrivateInfo = [3]string{
	0: "defaultDisplayName",
	1: "id",
	2: "identityProviders",
}

// Decode decodes DomainPrivateInfo from json.
func (s *DomainPrivateInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainPrivateInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "defaultDisplayName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DefaultDisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultDisplayName\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "identityProviders":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.IdentityProviders = make([]DomainIdentityProviderInfo, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DomainIdentityProviderInfo
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.IdentityProviders = append(s.IdentityProviders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identityProviders\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainPrivateInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainPrivateInfo) {
					name = jsonFieldsNameOfDomainPrivateInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainPrivateInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainPrivateInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainPublicInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainPublicInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("defaultDisplayName")
		e.Str(s.DefaultDisplayName)
	}
	{
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	{
		e.FieldStart("identityProviders")
		e.ArrStart()
		for _, elem := range s.IdentityProviders {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDomainPublicInfo = [3]string{
	0: "defaultDisplayName",
	1: "id",
	2: "identityProviders",
}

// Decode decodes DomainPublicInfo from json.
func (s *DomainPublicInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainPublicInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "defaultDisplayName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DefaultDisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultDisplayName\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "identityProviders":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.IdentityProviders = make([]DomainIdentityProviderInfo, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DomainIdentityProviderInfo
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.IdentityProviders = append(s.IdentityProviders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identityProviders\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainPublicInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainPublicInfo) {
					name = jsonFieldsNameOfDomainPublicInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainPublicInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainPublicInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainResourceSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainResourceSummary) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("schema")
		e.ArrStart()
		for _, elem := range s.Schema {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDomainResourceSummary = [1]string{
	0: "schema",
}

// Decode decodes DomainResourceSummary from json.
func (s *DomainResourceSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainResourceSummary to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schema":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Schema = make([]DomainResourceSummarySchemaItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DomainResourceSummarySchemaItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Schema = append(s.Schema, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schema\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainResourceSummary")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainResourceSummary) {
					name = jsonFieldsNameOfDomainResourceSummary[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainResourceSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainResourceSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainResourceSummarySchemaItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainResourceSummarySchemaItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("resource")
		e.Str(s.Resource)
	}
	{
		e.FieldStart("operations")
		e.ArrStart()
		for _, elem := range s.Operations {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("placeholderValues")
		s.PlaceholderValues.Encode(e)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
}

var jsonFieldsNameOfDomainResourceSummarySchemaItem = [4]string{
	0: "resource",
	1: "operations",
	2: "placeholderValues",
	3: "description",
}

// Decode decodes DomainResourceSummarySchemaItem from json.
func (s *DomainResourceSummarySchemaItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainResourceSummarySchemaItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resource":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Resource = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource\"")
			}
		case "operations":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Operations = make([]DomainResourceSummarySchemaItemOperationsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DomainResourceSummarySchemaItemOperationsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Operations = append(s.Operations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operations\"")
			}
		case "placeholderValues":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.PlaceholderValues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"placeholderValues\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainResourceSummarySchemaItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainResourceSummarySchemaItem) {
					name = jsonFieldsNameOfDomainResourceSummarySchemaItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainResourceSummarySchemaItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainResourceSummarySchemaItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DomainResourceSummarySchemaItemOperationsItem as json.
func (s DomainResourceSummarySchemaItemOperationsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DomainResourceSummarySchemaItemOperationsItem from json.
func (s *DomainResourceSummarySchemaItemOperationsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainResourceSummarySchemaItemOperationsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DomainResourceSummarySchemaItemOperationsItem(v) {
	case DomainResourceSummarySchemaItemOperationsItemEdit:
		*s = DomainResourceSummarySchemaItemOperationsItemEdit
	case DomainResourceSummarySchemaItemOperationsItemView:
		*s = DomainResourceSummarySchemaItemOperationsItemView
	case DomainResourceSummarySchemaItemOperationsItemUse:
		*s = DomainResourceSummarySchemaItemOperationsItemUse
	default:
		*s = DomainResourceSummarySchemaItemOperationsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DomainResourceSummarySchemaItemOperationsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainResourceSummarySchemaItemOperationsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DomainResourceSummarySchemaItemPlaceholderValues) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DomainResourceSummarySchemaItemPlaceholderValues) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes DomainResourceSummarySchemaItemPlaceholderValues from json.
func (s *DomainResourceSummarySchemaItemPlaceholderValues) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainResourceSummarySchemaItemPlaceholderValues to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []string
		if err := func() error {
			elem = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem string
				v, err := d.Str()
				elemElem = string(v)
				if err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainResourceSummarySchemaItemPlaceholderValues")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DomainResourceSummarySchemaItemPlaceholderValues) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainResourceSummarySchemaItemPlaceholderValues) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainRotateRootEncryptionKeysReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainRotateRootEncryptionKeysReq) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDomainRotateRootEncryptionKeysReq = [0]string{}

// Decode decodes DomainRotateRootEncryptionKeysReq from json.
func (s *DomainRotateRootEncryptionKeysReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainRotateRootEncryptionKeysReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode DomainRotateRootEncryptionKeysReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainRotateRootEncryptionKeysReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainRotateRootEncryptionKeysReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainSettings) encodeFields(e *jx.Encoder) {
	{
		if s.DisasterRecovery.Set {
			e.FieldStart("disasterRecovery")
			s.DisasterRecovery.Encode(e)
		}
	}
	{
		e.FieldStart("adminContacts")
		e.ArrStart()
		for _, elem := range s.AdminContacts {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.ActiveAdminContacts != nil {
			e.FieldStart("activeAdminContacts")
			e.ArrStart()
			for _, elem := range s.ActiveAdminContacts {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PendingAdminContacts != nil {
			e.FieldStart("pendingAdminContacts")
			e.ArrStart()
			for _, elem := range s.PendingAdminContacts {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("defaultDisplayName")
		e.Str(s.DefaultDisplayName)
	}
}

var jsonFieldsNameOfDomainSettings = [5]string{
	0: "disasterRecovery",
	1: "adminContacts",
	2: "activeAdminContacts",
	3: "pendingAdminContacts",
	4: "defaultDisplayName",
}

// Decode decodes DomainSettings from json.
func (s *DomainSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainSettings to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "disasterRecovery":
			if err := func() error {
				s.DisasterRecovery.Reset()
				if err := s.DisasterRecovery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disasterRecovery\"")
			}
		case "adminContacts":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.AdminContacts = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AdminContacts = append(s.AdminContacts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"adminContacts\"")
			}
		case "activeAdminContacts":
			if err := func() error {
				s.ActiveAdminContacts = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ActiveAdminContacts = append(s.ActiveAdminContacts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeAdminContacts\"")
			}
		case "pendingAdminContacts":
			if err := func() error {
				s.PendingAdminContacts = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PendingAdminContacts = append(s.PendingAdminContacts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pendingAdminContacts\"")
			}
		case "defaultDisplayName":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.DefaultDisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultDisplayName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainSettings")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainSettings) {
					name = jsonFieldsNameOfDomainSettings[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainSettingsDisasterRecovery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainSettingsDisasterRecovery) encodeFields(e *jx.Encoder) {
	{
		if s.Enable.Set {
			e.FieldStart("enable")
			s.Enable.Encode(e)
		}
	}
	{
		if s.PublicKey.Set {
			e.FieldStart("publicKey")
			s.PublicKey.Encode(e)
		}
	}
}

var jsonFieldsNameOfDomainSettingsDisasterRecovery = [2]string{
	0: "enable",
	1: "publicKey",
}

// Decode decodes DomainSettingsDisasterRecovery from json.
func (s *DomainSettingsDisasterRecovery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainSettingsDisasterRecovery to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enable":
			if err := func() error {
				s.Enable.Reset()
				if err := s.Enable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable\"")
			}
		case "publicKey":
			if err := func() error {
				s.PublicKey.Reset()
				if err := s.PublicKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publicKey\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainSettingsDisasterRecovery")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainSettingsDisasterRecovery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainSettingsDisasterRecovery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainSettingsPatch) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainSettingsPatch) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("patch")
		s.Patch.Encode(e)
	}
}

var jsonFieldsNameOfDomainSettingsPatch = [1]string{
	0: "patch",
}

// Decode decodes DomainSettingsPatch from json.
func (s *DomainSettingsPatch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainSettingsPatch to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "patch":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Patch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patch\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainSettingsPatch")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainSettingsPatch) {
					name = jsonFieldsNameOfDomainSettingsPatch[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainSettingsPatch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainSettingsPatch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Notifications != nil {
			e.FieldStart("notifications")
			e.ArrStart()
			for _, elem := range s.Notifications {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDomainStatus = [1]string{
	0: "notifications",
}

// Decode decodes DomainStatus from json.
func (s *DomainStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "notifications":
			if err := func() error {
				s.Notifications = make([]DomainStatusNotificationsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DomainStatusNotificationsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Notifications = append(s.Notifications, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainStatusNotificationsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainStatusNotificationsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("summary")
		e.Str(s.Summary)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfDomainStatusNotificationsItem = [3]string{
	0: "summary",
	1: "description",
	2: "type",
}

// Decode decodes DomainStatusNotificationsItem from json.
func (s *DomainStatusNotificationsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainStatusNotificationsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "summary":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Summary = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainStatusNotificationsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainStatusNotificationsItem) {
					name = jsonFieldsNameOfDomainStatusNotificationsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainStatusNotificationsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainStatusNotificationsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DomainStatusNotificationsItemType as json.
func (s DomainStatusNotificationsItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DomainStatusNotificationsItemType from json.
func (s *DomainStatusNotificationsItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainStatusNotificationsItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DomainStatusNotificationsItemType(v) {
	case DomainStatusNotificationsItemTypeInfo:
		*s = DomainStatusNotificationsItemTypeInfo
	case DomainStatusNotificationsItemTypeAlert:
		*s = DomainStatusNotificationsItemTypeAlert
	default:
		*s = DomainStatusNotificationsItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DomainStatusNotificationsItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainStatusNotificationsItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainTagInfoResults) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainTagInfoResults) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tags")
		e.ArrStart()
		for _, elem := range s.Tags {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("has_more")
		e.Bool(s.HasMore)
	}
}

var jsonFieldsNameOfDomainTagInfoResults = [2]string{
	0: "tags",
	1: "has_more",
}

// Decode decodes DomainTagInfoResults from json.
func (s *DomainTagInfoResults) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainTagInfoResults to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tags":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Tags = make([]TagMeta, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TagMeta
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "has_more":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_more\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainTagInfoResults")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomainTagInfoResults) {
					name = jsonFieldsNameOfDomainTagInfoResults[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainTagInfoResults) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainTagInfoResults) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("traceID")
		e.Str(s.TraceID)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfError = [2]string{
	0: "traceID",
	1: "message",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "traceID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TraceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"traceID\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Fact) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Fact) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("arguments")
		e.ArrStart()
		for _, elem := range s.Arguments {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfFact = [3]string{
	0: "id",
	1: "name",
	2: "arguments",
}

// Decode decodes Fact from json.
func (s *Fact) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Fact to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "arguments":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Arguments = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Arguments = append(s.Arguments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arguments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Fact")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFact) {
					name = jsonFieldsNameOfFact[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Fact) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Fact) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FactID as json.
func (s FactID) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes FactID from json.
func (s *FactID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FactID to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FactID(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FactID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FactID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FactList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FactList) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("facts")
		e.ArrStart()
		for _, elem := range s.Facts {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfFactList = [1]string{
	0: "facts",
}

// Decode decodes FactList from json.
func (s *FactList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FactList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "facts":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Facts = make([]Fact, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Fact
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Facts = append(s.Facts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"facts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FactList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFactList) {
					name = jsonFieldsNameOfFactList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FactList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FactList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FactPolicyRules as json.
func (s FactPolicyRules) Encode(e *jx.Encoder) {
	unwrapped := []FactPolicyRulesItem(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes FactPolicyRules from json.
func (s *FactPolicyRules) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FactPolicyRules to nil")
	}
	var unwrapped []FactPolicyRulesItem
	if err := func() error {
		unwrapped = make([]FactPolicyRulesItem, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem FactPolicyRulesItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FactPolicyRules(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FactPolicyRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FactPolicyRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FactPolicyRulesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FactPolicyRulesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("operator")
		s.Operator.Encode(e)
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("arguments")
		e.ArrStart()
		for _, elem := range s.Arguments {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfFactPolicyRulesItem = [3]string{
	0: "operator",
	1: "name",
	2: "arguments",
}

// Decode decodes FactPolicyRulesItem from json.
func (s *FactPolicyRulesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FactPolicyRulesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "operator":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Operator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "arguments":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Arguments = make([]FactPolicyRulesItemArgumentsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FactPolicyRulesItemArgumentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Arguments = append(s.Arguments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arguments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FactPolicyRulesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFactPolicyRulesItem) {
					name = jsonFieldsNameOfFactPolicyRulesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FactPolicyRulesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FactPolicyRulesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FactPolicyRulesItemArgumentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FactPolicyRulesItemArgumentsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Any.Set {
			e.FieldStart("any")
			s.Any.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		if s.Capability.Set {
			e.FieldStart("capability")
			s.Capability.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfFactPolicyRulesItemArgumentsItem = [4]string{
	0: "any",
	1: "source",
	2: "capability",
	3: "value",
}

// Decode decodes FactPolicyRulesItemArgumentsItem from json.
func (s *FactPolicyRulesItemArgumentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FactPolicyRulesItemArgumentsItem to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "any":
			if err := func() error {
				s.Any.Reset()
				if err := s.Any.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"any\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "capability":
			if err := func() error {
				s.Capability.Reset()
				if err := s.Capability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capability\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FactPolicyRulesItemArgumentsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FactPolicyRulesItemArgumentsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FactPolicyRulesItemArgumentsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FactPolicyRulesItemArgumentsItemSource as json.
func (s FactPolicyRulesItemArgumentsItemSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FactPolicyRulesItemArgumentsItemSource from json.
func (s *FactPolicyRulesItemArgumentsItemSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FactPolicyRulesItemArgumentsItemSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FactPolicyRulesItemArgumentsItemSource(v) {
	case FactPolicyRulesItemArgumentsItemSourceDomainIdentity:
		*s = FactPolicyRulesItemArgumentsItemSourceDomainIdentity
	case FactPolicyRulesItemArgumentsItemSourceLiteral:
		*s = FactPolicyRulesItemArgumentsItemSourceLiteral
	default:
		*s = FactPolicyRulesItemArgumentsItemSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FactPolicyRulesItemArgumentsItemSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FactPolicyRulesItemArgumentsItemSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FactPolicyRulesItemOperator as json.
func (s FactPolicyRulesItemOperator) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FactPolicyRulesItemOperator from json.
func (s *FactPolicyRulesItemOperator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FactPolicyRulesItemOperator to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FactPolicyRulesItemOperator(v) {
	case FactPolicyRulesItemOperatorExists:
		*s = FactPolicyRulesItemOperatorExists
	case FactPolicyRulesItemOperatorNotExists:
		*s = FactPolicyRulesItemOperatorNotExists
	default:
		*s = FactPolicyRulesItemOperator(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FactPolicyRulesItemOperator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FactPolicyRulesItemOperator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FactTypeDefinition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FactTypeDefinition) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("arguments")
		e.ArrStart()
		for _, elem := range s.Arguments {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("imported")
		e.Bool(s.Imported)
	}
	{
		if s.SourceDomainID.Set {
			e.FieldStart("sourceDomainID")
			s.SourceDomainID.Encode(e)
		}
	}
	{
		if s.SourceDomainName.Set {
			e.FieldStart("sourceDomainName")
			s.SourceDomainName.Encode(e)
		}
	}
}

var jsonFieldsNameOfFactTypeDefinition = [6]string{
	0: "name",
	1: "description",
	2: "arguments",
	3: "imported",
	4: "sourceDomainID",
	5: "sourceDomainName",
}

// Decode decodes FactTypeDefinition from json.
func (s *FactTypeDefinition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FactTypeDefinition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "arguments":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Arguments = make([]FactTypeDefinitionArgumentsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FactTypeDefinitionArgumentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Arguments = append(s.Arguments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arguments\"")
			}
		case "imported":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Imported = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imported\"")
			}
		case "sourceDomainID":
			if err := func() error {
				s.SourceDomainID.Reset()
				if err := s.SourceDomainID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sourceDomainID\"")
			}
		case "sourceDomainName":
			if err := func() error {
				s.SourceDomainName.Reset()
				if err := s.SourceDomainName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sourceDomainName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FactTypeDefinition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFactTypeDefinition) {
					name = jsonFieldsNameOfFactTypeDefinition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FactTypeDefinition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FactTypeDefinition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FactTypeDefinitionArgumentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FactTypeDefinitionArgumentsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
}

var jsonFieldsNameOfFactTypeDefinitionArgumentsItem = [2]string{
	0: "name",
	1: "description",
}

// Decode decodes FactTypeDefinitionArgumentsItem from json.
func (s *FactTypeDefinitionArgumentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FactTypeDefinitionArgumentsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FactTypeDefinitionArgumentsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFactTypeDefinitionArgumentsItem) {
					name = jsonFieldsNameOfFactTypeDefinitionArgumentsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FactTypeDefinitionArgumentsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FactTypeDefinitionArgumentsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FactTypeName as json.
func (s FactTypeName) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes FactTypeName from json.
func (s *FactTypeName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FactTypeName to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FactTypeName(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FactTypeName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FactTypeName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FactTypeReference as json.
func (s FactTypeReference) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes FactTypeReference from json.
func (s *FactTypeReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FactTypeReference to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FactTypeReference(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FactTypeReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FactTypeReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ForbiddenError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ForbiddenError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfForbiddenError = [1]string{
	0: "message",
}

// Decode decodes ForbiddenError from json.
func (s *ForbiddenError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ForbiddenError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ForbiddenError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfForbiddenError) {
					name = jsonFieldsNameOfForbiddenError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ForbiddenError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ForbiddenError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GCPServiceAccountKeyInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GCPServiceAccountKeyInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("serviceAccountCredentials")
		e.Base64(s.ServiceAccountCredentials)
	}
	{
		e.FieldStart("projectID")
		e.Str(s.ProjectID)
	}
	{
		e.FieldStart("location")
		e.Str(s.Location)
	}
	{
		e.FieldStart("keyringID")
		e.Str(s.KeyringID)
	}
	{
		e.FieldStart("keyID")
		e.Str(s.KeyID)
	}
}

var jsonFieldsNameOfGCPServiceAccountKeyInfo = [5]string{
	0: "serviceAccountCredentials",
	1: "projectID",
	2: "location",
	3: "keyringID",
	4: "keyID",
}

// Decode decodes GCPServiceAccountKeyInfo from json.
func (s *GCPServiceAccountKeyInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GCPServiceAccountKeyInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "serviceAccountCredentials":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Base64()
				s.ServiceAccountCredentials = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceAccountCredentials\"")
			}
		case "projectID":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ProjectID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectID\"")
			}
		case "location":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Location = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "keyringID":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.KeyringID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keyringID\"")
			}
		case "keyID":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.KeyID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keyID\"")
			}
		case "providerName":
			return d.Skip()
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GCPServiceAccountKeyInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGCPServiceAccountKeyInfo) {
					name = jsonFieldsNameOfGCPServiceAccountKeyInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GCPServiceAccountKeyInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GCPServiceAccountKeyInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GoogleOAuthDomainIdentityProviderDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GoogleOAuthDomainIdentityProviderDetails) encodeFields(e *jx.Encoder) {
	{
		if s.ClientID.Set {
			e.FieldStart("clientID")
			s.ClientID.Encode(e)
		}
	}
}

var jsonFieldsNameOfGoogleOAuthDomainIdentityProviderDetails = [1]string{
	0: "clientID",
}

// Decode decodes GoogleOAuthDomainIdentityProviderDetails from json.
func (s *GoogleOAuthDomainIdentityProviderDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GoogleOAuthDomainIdentityProviderDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clientID":
			if err := func() error {
				s.ClientID.Reset()
				if err := s.ClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientID\"")
			}
		case "type":
			return d.Skip()
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GoogleOAuthDomainIdentityProviderDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GoogleOAuthDomainIdentityProviderDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GoogleOAuthDomainIdentityProviderDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HookName as json.
func (s HookName) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes HookName from json.
func (s *HookName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HookName to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = HookName(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HookName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HookName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IdentityProviderName as json.
func (s IdentityProviderName) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes IdentityProviderName from json.
func (s *IdentityProviderName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IdentityProviderName to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IdentityProviderName(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IdentityProviderName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IdentityProviderName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IdentityProviderReference as json.
func (s IdentityProviderReference) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes IdentityProviderReference from json.
func (s *IdentityProviderReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IdentityProviderReference to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IdentityProviderReference(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IdentityProviderReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IdentityProviderReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ImportAlias as json.
func (s ImportAlias) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes ImportAlias from json.
func (s *ImportAlias) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ImportAlias to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ImportAlias(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ImportAlias) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ImportAlias) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InvalidRequestError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InvalidRequestError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("field")
		e.Str(s.Field)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfInvalidRequestError = [2]string{
	0: "field",
	1: "message",
}

// Decode decodes InvalidRequestError from json.
func (s *InvalidRequestError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InvalidRequestError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "field":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Field = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"field\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InvalidRequestError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInvalidRequestError) {
					name = jsonFieldsNameOfInvalidRequestError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InvalidRequestError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InvalidRequestError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *JSONPatchRequestAdd) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *JSONPatchRequestAdd) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
	{
		e.FieldStart("value")
		s.Value.Encode(e)
	}
}

var jsonFieldsNameOfJSONPatchRequestAdd = [2]string{
	0: "path",
	1: "value",
}

// Decode decodes JSONPatchRequestAdd from json.
func (s *JSONPatchRequestAdd) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JSONPatchRequestAdd to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "op":
			return d.Skip()
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JSONPatchRequestAdd")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfJSONPatchRequestAdd) {
					name = jsonFieldsNameOfJSONPatchRequestAdd[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *JSONPatchRequestAdd) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JSONPatchRequestAdd) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JSONPatchRequestAddValue as json.
func (s JSONPatchRequestAddValue) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringJSONPatchRequestAddValue:
		e.Str(s.String)
	case Float64JSONPatchRequestAddValue:
		e.Float64(s.Float64)
	case BoolJSONPatchRequestAddValue:
		e.Bool(s.Bool)
	}
}

// Decode decodes JSONPatchRequestAddValue from json.
func (s *JSONPatchRequestAddValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JSONPatchRequestAddValue to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolJSONPatchRequestAddValue
	case jx.Number:
		v, err := d.Float64()
		s.Float64 = float64(v)
		if err != nil {
			return err
		}
		s.Type = Float64JSONPatchRequestAddValue
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringJSONPatchRequestAddValue
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JSONPatchRequestAddValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JSONPatchRequestAddValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *JSONPatchRequestCopy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *JSONPatchRequestCopy) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
}

var jsonFieldsNameOfJSONPatchRequestCopy = [1]string{
	0: "path",
}

// Decode decodes JSONPatchRequestCopy from json.
func (s *JSONPatchRequestCopy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JSONPatchRequestCopy to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "op":
			return d.Skip()
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JSONPatchRequestCopy")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfJSONPatchRequestCopy) {
					name = jsonFieldsNameOfJSONPatchRequestCopy[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *JSONPatchRequestCopy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JSONPatchRequestCopy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *JSONPatchRequestMove) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *JSONPatchRequestMove) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
}

var jsonFieldsNameOfJSONPatchRequestMove = [1]string{
	0: "path",
}

// Decode decodes JSONPatchRequestMove from json.
func (s *JSONPatchRequestMove) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JSONPatchRequestMove to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "op":
			return d.Skip()
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JSONPatchRequestMove")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfJSONPatchRequestMove) {
					name = jsonFieldsNameOfJSONPatchRequestMove[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *JSONPatchRequestMove) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JSONPatchRequestMove) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *JSONPatchRequestRemove) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *JSONPatchRequestRemove) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
}

var jsonFieldsNameOfJSONPatchRequestRemove = [1]string{
	0: "path",
}

// Decode decodes JSONPatchRequestRemove from json.
func (s *JSONPatchRequestRemove) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JSONPatchRequestRemove to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "op":
			return d.Skip()
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JSONPatchRequestRemove")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfJSONPatchRequestRemove) {
					name = jsonFieldsNameOfJSONPatchRequestRemove[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *JSONPatchRequestRemove) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JSONPatchRequestRemove) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *JSONPatchRequestReplace) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *JSONPatchRequestReplace) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
	{
		e.FieldStart("value")
		s.Value.Encode(e)
	}
}

var jsonFieldsNameOfJSONPatchRequestReplace = [2]string{
	0: "path",
	1: "value",
}

// Decode decodes JSONPatchRequestReplace from json.
func (s *JSONPatchRequestReplace) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JSONPatchRequestReplace to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "op":
			return d.Skip()
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JSONPatchRequestReplace")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfJSONPatchRequestReplace) {
					name = jsonFieldsNameOfJSONPatchRequestReplace[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *JSONPatchRequestReplace) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JSONPatchRequestReplace) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JSONPatchRequestReplaceValue as json.
func (s JSONPatchRequestReplaceValue) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringJSONPatchRequestReplaceValue:
		e.Str(s.String)
	case Float64JSONPatchRequestReplaceValue:
		e.Float64(s.Float64)
	case BoolJSONPatchRequestReplaceValue:
		e.Bool(s.Bool)
	}
}

// Decode decodes JSONPatchRequestReplaceValue from json.
func (s *JSONPatchRequestReplaceValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JSONPatchRequestReplaceValue to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolJSONPatchRequestReplaceValue
	case jx.Number:
		v, err := d.Float64()
		s.Float64 = float64(v)
		if err != nil {
			return err
		}
		s.Type = Float64JSONPatchRequestReplaceValue
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringJSONPatchRequestReplaceValue
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JSONPatchRequestReplaceValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JSONPatchRequestReplaceValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *JSONPatchRequestTst) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *JSONPatchRequestTst) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
	{
		e.FieldStart("value")
		s.Value.Encode(e)
	}
}

var jsonFieldsNameOfJSONPatchRequestTst = [2]string{
	0: "path",
	1: "value",
}

// Decode decodes JSONPatchRequestTst from json.
func (s *JSONPatchRequestTst) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JSONPatchRequestTst to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "op":
			return d.Skip()
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JSONPatchRequestTst")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfJSONPatchRequestTst) {
					name = jsonFieldsNameOfJSONPatchRequestTst[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *JSONPatchRequestTst) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JSONPatchRequestTst) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JSONPatchRequestTstValue as json.
func (s JSONPatchRequestTstValue) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringJSONPatchRequestTstValue:
		e.Str(s.String)
	case Float64JSONPatchRequestTstValue:
		e.Float64(s.Float64)
	case BoolJSONPatchRequestTstValue:
		e.Bool(s.Bool)
	}
}

// Decode decodes JSONPatchRequestTstValue from json.
func (s *JSONPatchRequestTstValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JSONPatchRequestTstValue to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolJSONPatchRequestTstValue
	case jx.Number:
		v, err := d.Float64()
		s.Float64 = float64(v)
		if err != nil {
			return err
		}
		s.Type = Float64JSONPatchRequestTstValue
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringJSONPatchRequestTstValue
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JSONPatchRequestTstValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JSONPatchRequestTstValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *KeyInfos) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *KeyInfos) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("keyInformation")
		s.KeyInformation.Encode(e)
	}
}

var jsonFieldsNameOfKeyInfos = [2]string{
	0: "description",
	1: "keyInformation",
}

// Decode decodes KeyInfos from json.
func (s *KeyInfos) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode KeyInfos to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "keyInformation":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.KeyInformation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keyInformation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode KeyInfos")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfKeyInfos) {
					name = jsonFieldsNameOfKeyInfos[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *KeyInfos) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *KeyInfos) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes KeyInfosKeyInformation as json.
func (s KeyInfosKeyInformation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s KeyInfosKeyInformation) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case AntimatterDelegatedAWSKeyInfoKeyInfosKeyInformation:
		e.FieldStart("providerName")
		e.Str("aws_am")
		s.AntimatterDelegatedAWSKeyInfo.encodeFields(e)
	case AWSServiceAccountKeyInfoKeyInfosKeyInformation:
		e.FieldStart("providerName")
		e.Str("aws_sa")
		s.AWSServiceAccountKeyInfo.encodeFields(e)
	case BYOKKeyInfoKeyInfosKeyInformation:
		e.FieldStart("providerName")
		e.Str("byok")
		s.BYOKKeyInfo.encodeFields(e)
	case AntimatterDelegatedGCPKeyInfoKeyInfosKeyInformation:
		e.FieldStart("providerName")
		e.Str("gcp_am")
		s.AntimatterDelegatedGCPKeyInfo.encodeFields(e)
	case GCPServiceAccountKeyInfoKeyInfosKeyInformation:
		e.FieldStart("providerName")
		e.Str("gcp_sa")
		s.GCPServiceAccountKeyInfo.encodeFields(e)
	}
}

// Decode decodes KeyInfosKeyInformation from json.
func (s *KeyInfosKeyInformation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode KeyInfosKeyInformation to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "providerName":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "aws_am":
					s.Type = AntimatterDelegatedAWSKeyInfoKeyInfosKeyInformation
					found = true
				case "aws_sa":
					s.Type = AWSServiceAccountKeyInfoKeyInfosKeyInformation
					found = true
				case "byok":
					s.Type = BYOKKeyInfoKeyInfosKeyInformation
					found = true
				case "gcp_am":
					s.Type = AntimatterDelegatedGCPKeyInfoKeyInfosKeyInformation
					found = true
				case "gcp_sa":
					s.Type = GCPServiceAccountKeyInfoKeyInfosKeyInformation
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case GCPServiceAccountKeyInfoKeyInfosKeyInformation:
		if err := s.GCPServiceAccountKeyInfo.Decode(d); err != nil {
			return err
		}
	case AntimatterDelegatedGCPKeyInfoKeyInfosKeyInformation:
		if err := s.AntimatterDelegatedGCPKeyInfo.Decode(d); err != nil {
			return err
		}
	case AWSServiceAccountKeyInfoKeyInfosKeyInformation:
		if err := s.AWSServiceAccountKeyInfo.Decode(d); err != nil {
			return err
		}
	case AntimatterDelegatedAWSKeyInfoKeyInfosKeyInformation:
		if err := s.AntimatterDelegatedAWSKeyInfo.Decode(d); err != nil {
			return err
		}
	case BYOKKeyInfoKeyInfosKeyInformation:
		if err := s.BYOKKeyInfo.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s KeyInfosKeyInformation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *KeyInfosKeyInformation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LogEntryID as json.
func (s LogEntryID) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes LogEntryID from json.
func (s *LogEntryID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LogEntryID to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LogEntryID(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LogEntryID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LogEntryID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NewAccessLogEntry) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NewAccessLogEntry) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("operation")
		s.Operation.Encode(e)
	}
	{
		if s.Location.Set {
			e.FieldStart("location")
			s.Location.Encode(e)
		}
	}
	{
		e.FieldStart("readInfo")
		s.ReadInfo.Encode(e)
	}
}

var jsonFieldsNameOfNewAccessLogEntry = [3]string{
	0: "operation",
	1: "location",
	2: "readInfo",
}

// Decode decodes NewAccessLogEntry from json.
func (s *NewAccessLogEntry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NewAccessLogEntry to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "operation":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Operation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operation\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "readInfo":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ReadInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readInfo\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NewAccessLogEntry")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNewAccessLogEntry) {
					name = jsonFieldsNameOfNewAccessLogEntry[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NewAccessLogEntry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NewAccessLogEntry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NewAccessLogEntryOperation as json.
func (s NewAccessLogEntryOperation) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NewAccessLogEntryOperation from json.
func (s *NewAccessLogEntryOperation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NewAccessLogEntryOperation to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NewAccessLogEntryOperation(v) {
	case NewAccessLogEntryOperationRead:
		*s = NewAccessLogEntryOperationRead
	default:
		*s = NewAccessLogEntryOperation(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NewAccessLogEntryOperation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NewAccessLogEntryOperation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NewAccessLogEntryReadInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NewAccessLogEntryReadInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("parameters")
		s.Parameters.Encode(e)
	}
	{
		e.FieldStart("allowedTags")
		s.AllowedTags.Encode(e)
	}
	{
		e.FieldStart("redactedTags")
		s.RedactedTags.Encode(e)
	}
	{
		e.FieldStart("tokenizedTags")
		s.TokenizedTags.Encode(e)
	}
	{
		e.FieldStart("returnedRecords")
		e.Int(s.ReturnedRecords)
	}
	{
		e.FieldStart("filteredRecords")
		e.Int(s.FilteredRecords)
	}
}

var jsonFieldsNameOfNewAccessLogEntryReadInfo = [6]string{
	0: "parameters",
	1: "allowedTags",
	2: "redactedTags",
	3: "tokenizedTags",
	4: "returnedRecords",
	5: "filteredRecords",
}

// Decode decodes NewAccessLogEntryReadInfo from json.
func (s *NewAccessLogEntryReadInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NewAccessLogEntryReadInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "parameters":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		case "allowedTags":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.AllowedTags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedTags\"")
			}
		case "redactedTags":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.RedactedTags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"redactedTags\"")
			}
		case "tokenizedTags":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.TokenizedTags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokenizedTags\"")
			}
		case "returnedRecords":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ReturnedRecords = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"returnedRecords\"")
			}
		case "filteredRecords":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.FilteredRecords = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filteredRecords\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NewAccessLogEntryReadInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNewAccessLogEntryReadInfo) {
					name = jsonFieldsNameOfNewAccessLogEntryReadInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NewAccessLogEntryReadInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NewAccessLogEntryReadInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s NewAccessLogEntryReadInfoParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s NewAccessLogEntryReadInfoParameters) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes NewAccessLogEntryReadInfoParameters from json.
func (s *NewAccessLogEntryReadInfoParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NewAccessLogEntryReadInfoParameters to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NewAccessLogEntryReadInfoParameters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NewAccessLogEntryReadInfoParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NewAccessLogEntryReadInfoParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NewCapabilityDefinition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NewCapabilityDefinition) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("unary")
		e.Bool(s.Unary)
	}
	{
		e.FieldStart("summary")
		e.Str(s.Summary)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
}

var jsonFieldsNameOfNewCapabilityDefinition = [3]string{
	0: "unary",
	1: "summary",
	2: "description",
}

// Decode decodes NewCapabilityDefinition from json.
func (s *NewCapabilityDefinition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NewCapabilityDefinition to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "unary":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Unary = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unary\"")
			}
		case "summary":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Summary = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NewCapabilityDefinition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNewCapabilityDefinition) {
					name = jsonFieldsNameOfNewCapabilityDefinition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NewCapabilityDefinition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NewCapabilityDefinition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NewDomain) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NewDomain) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("adminEmail")
		e.Str(s.AdminEmail)
	}
	{
		if s.GoogleJWT.Set {
			e.FieldStart("googleJWT")
			s.GoogleJWT.Encode(e)
		}
	}
	{
		if s.DisplayName.Set {
			e.FieldStart("displayName")
			s.DisplayName.Encode(e)
		}
	}
}

var jsonFieldsNameOfNewDomain = [3]string{
	0: "adminEmail",
	1: "googleJWT",
	2: "displayName",
}

// Decode decodes NewDomain from json.
func (s *NewDomain) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NewDomain to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "adminEmail":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AdminEmail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"adminEmail\"")
			}
		case "googleJWT":
			if err := func() error {
				s.GoogleJWT.Reset()
				if err := s.GoogleJWT.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"googleJWT\"")
			}
		case "displayName":
			if err := func() error {
				s.DisplayName.Reset()
				if err := s.DisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NewDomain")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNewDomain) {
					name = jsonFieldsNameOfNewDomain[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NewDomain) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NewDomain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NewDomainPolicyRule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NewDomainPolicyRule) encodeFields(e *jx.Encoder) {
	{
		if s.DomainIdentity.Set {
			e.FieldStart("domainIdentity")
			s.DomainIdentity.Encode(e)
		}
	}
	{
		if s.Facts != nil {
			e.FieldStart("facts")
			s.Facts.Encode(e)
		}
	}
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
	{
		e.FieldStart("operation")
		s.Operation.Encode(e)
	}
	{
		e.FieldStart("result")
		s.Result.Encode(e)
	}
	{
		e.FieldStart("priority")
		e.Int(s.Priority)
	}
	{
		e.FieldStart("disabled")
		e.Bool(s.Disabled)
	}
}

var jsonFieldsNameOfNewDomainPolicyRule = [7]string{
	0: "domainIdentity",
	1: "facts",
	2: "path",
	3: "operation",
	4: "result",
	5: "priority",
	6: "disabled",
}

// Decode decodes NewDomainPolicyRule from json.
func (s *NewDomainPolicyRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NewDomainPolicyRule to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domainIdentity":
			if err := func() error {
				s.DomainIdentity.Reset()
				if err := s.DomainIdentity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainIdentity\"")
			}
		case "facts":
			if err := func() error {
				if err := s.Facts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"facts\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "operation":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Operation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operation\"")
			}
		case "result":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "priority":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Priority = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "disabled":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Disabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NewDomainPolicyRule")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNewDomainPolicyRule) {
					name = jsonFieldsNameOfNewDomainPolicyRule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NewDomainPolicyRule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NewDomainPolicyRule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NewDomainResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NewDomainResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	{
		e.FieldStart("apiKey")
		e.Str(s.ApiKey)
	}
}

var jsonFieldsNameOfNewDomainResponse = [2]string{
	0: "id",
	1: "apiKey",
}

// Decode decodes NewDomainResponse from json.
func (s *NewDomainResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NewDomainResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "apiKey":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ApiKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiKey\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NewDomainResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNewDomainResponse) {
					name = jsonFieldsNameOfNewDomainResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NewDomainResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NewDomainResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NewFact) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NewFact) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("arguments")
		e.ArrStart()
		for _, elem := range s.Arguments {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfNewFact = [1]string{
	0: "arguments",
}

// Decode decodes NewFact from json.
func (s *NewFact) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NewFact to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "arguments":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Arguments = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Arguments = append(s.Arguments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arguments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NewFact")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNewFact) {
					name = jsonFieldsNameOfNewFact[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NewFact) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NewFact) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NewFactTypeDefinition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NewFactTypeDefinition) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("arguments")
		e.ArrStart()
		for _, elem := range s.Arguments {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfNewFactTypeDefinition = [2]string{
	0: "description",
	1: "arguments",
}

// Decode decodes NewFactTypeDefinition from json.
func (s *NewFactTypeDefinition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NewFactTypeDefinition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "arguments":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Arguments = make([]NewFactTypeDefinitionArgumentsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NewFactTypeDefinitionArgumentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Arguments = append(s.Arguments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arguments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NewFactTypeDefinition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNewFactTypeDefinition) {
					name = jsonFieldsNameOfNewFactTypeDefinition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NewFactTypeDefinition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NewFactTypeDefinition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NewFactTypeDefinitionArgumentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NewFactTypeDefinitionArgumentsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
}

var jsonFieldsNameOfNewFactTypeDefinitionArgumentsItem = [2]string{
	0: "name",
	1: "description",
}

// Decode decodes NewFactTypeDefinitionArgumentsItem from json.
func (s *NewFactTypeDefinitionArgumentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NewFactTypeDefinitionArgumentsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NewFactTypeDefinitionArgumentsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNewFactTypeDefinitionArgumentsItem) {
					name = jsonFieldsNameOfNewFactTypeDefinitionArgumentsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NewFactTypeDefinitionArgumentsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NewFactTypeDefinitionArgumentsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NewReadContextConfigRule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NewReadContextConfigRule) encodeFields(e *jx.Encoder) {
	{
		if s.MatchExpressions != nil {
			e.FieldStart("matchExpressions")
			s.MatchExpressions.Encode(e)
		}
	}
	{
		e.FieldStart("action")
		s.Action.Encode(e)
	}
	{
		if s.TokenScope.Set {
			e.FieldStart("tokenScope")
			s.TokenScope.Encode(e)
		}
	}
	{
		if s.TokenFormat.Set {
			e.FieldStart("tokenFormat")
			s.TokenFormat.Encode(e)
		}
	}
	{
		if s.Facts != nil {
			e.FieldStart("facts")
			s.Facts.Encode(e)
		}
	}
	{
		e.FieldStart("priority")
		e.Int(s.Priority)
	}
}

var jsonFieldsNameOfNewReadContextConfigRule = [6]string{
	0: "matchExpressions",
	1: "action",
	2: "tokenScope",
	3: "tokenFormat",
	4: "facts",
	5: "priority",
}

// Decode decodes NewReadContextConfigRule from json.
func (s *NewReadContextConfigRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NewReadContextConfigRule to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchExpressions":
			if err := func() error {
				if err := s.MatchExpressions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchExpressions\"")
			}
		case "action":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		case "tokenScope":
			if err := func() error {
				s.TokenScope.Reset()
				if err := s.TokenScope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokenScope\"")
			}
		case "tokenFormat":
			if err := func() error {
				s.TokenFormat.Reset()
				if err := s.TokenFormat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokenFormat\"")
			}
		case "facts":
			if err := func() error {
				if err := s.Facts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"facts\"")
			}
		case "priority":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Priority = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NewReadContextConfigRule")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNewReadContextConfigRule) {
					name = jsonFieldsNameOfNewReadContextConfigRule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NewReadContextConfigRule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NewReadContextConfigRule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NewReadContextConfigRuleAction as json.
func (s NewReadContextConfigRuleAction) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NewReadContextConfigRuleAction from json.
func (s *NewReadContextConfigRuleAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NewReadContextConfigRuleAction to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NewReadContextConfigRuleAction(v) {
	case NewReadContextConfigRuleActionDenyCapsule:
		*s = NewReadContextConfigRuleActionDenyCapsule
	case NewReadContextConfigRuleActionDenyRecord:
		*s = NewReadContextConfigRuleActionDenyRecord
	case NewReadContextConfigRuleActionRedact:
		*s = NewReadContextConfigRuleActionRedact
	case NewReadContextConfigRuleActionTokenize:
		*s = NewReadContextConfigRuleActionTokenize
	case NewReadContextConfigRuleActionAllow:
		*s = NewReadContextConfigRuleActionAllow
	default:
		*s = NewReadContextConfigRuleAction(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NewReadContextConfigRuleAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NewReadContextConfigRuleAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NewReadContextConfigRuleTokenFormat as json.
func (s NewReadContextConfigRuleTokenFormat) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NewReadContextConfigRuleTokenFormat from json.
func (s *NewReadContextConfigRuleTokenFormat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NewReadContextConfigRuleTokenFormat to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NewReadContextConfigRuleTokenFormat(v) {
	case NewReadContextConfigRuleTokenFormatExplicit:
		*s = NewReadContextConfigRuleTokenFormatExplicit
	case NewReadContextConfigRuleTokenFormatSynthetic:
		*s = NewReadContextConfigRuleTokenFormatSynthetic
	default:
		*s = NewReadContextConfigRuleTokenFormat(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NewReadContextConfigRuleTokenFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NewReadContextConfigRuleTokenFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NewReadContextConfigRuleTokenScope as json.
func (s NewReadContextConfigRuleTokenScope) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NewReadContextConfigRuleTokenScope from json.
func (s *NewReadContextConfigRuleTokenScope) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NewReadContextConfigRuleTokenScope to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NewReadContextConfigRuleTokenScope(v) {
	case NewReadContextConfigRuleTokenScopeUnique:
		*s = NewReadContextConfigRuleTokenScopeUnique
	case NewReadContextConfigRuleTokenScopeCapsule:
		*s = NewReadContextConfigRuleTokenScopeCapsule
	case NewReadContextConfigRuleTokenScopeDomain:
		*s = NewReadContextConfigRuleTokenScopeDomain
	default:
		*s = NewReadContextConfigRuleTokenScope(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NewReadContextConfigRuleTokenScope) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NewReadContextConfigRuleTokenScope) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccessLogEntryCreateInfo as json.
func (o OptAccessLogEntryCreateInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AccessLogEntryCreateInfo from json.
func (o *OptAccessLogEntryCreateInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAccessLogEntryCreateInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAccessLogEntryCreateInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAccessLogEntryCreateInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccessLogEntryOpenInfo as json.
func (o OptAccessLogEntryOpenInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AccessLogEntryOpenInfo from json.
func (o *OptAccessLogEntryOpenInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAccessLogEntryOpenInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAccessLogEntryOpenInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAccessLogEntryOpenInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccessLogEntryReadInfo as json.
func (o OptAccessLogEntryReadInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AccessLogEntryReadInfo from json.
func (o *OptAccessLogEntryReadInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAccessLogEntryReadInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAccessLogEntryReadInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAccessLogEntryReadInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CapabilityReference as json.
func (o OptCapabilityReference) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CapabilityReference from json.
func (o *OptCapabilityReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCapabilityReference to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCapabilityReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCapabilityReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CapabilityRule as json.
func (o OptCapabilityRule) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CapabilityRule from json.
func (o *OptCapabilityRule) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCapabilityRule to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCapabilityRule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCapabilityRule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes DomainID as json.
func (o OptDomainID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DomainID from json.
func (o *OptDomainID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDomainID to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDomainID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDomainID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DomainIdentityProviderDetails as json.
func (o OptDomainIdentityProviderDetails) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DomainIdentityProviderDetails from json.
func (o *OptDomainIdentityProviderDetails) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDomainIdentityProviderDetails to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDomainIdentityProviderDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDomainIdentityProviderDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DomainSettingsDisasterRecovery as json.
func (o OptDomainSettingsDisasterRecovery) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DomainSettingsDisasterRecovery from json.
func (o *OptDomainSettingsDisasterRecovery) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDomainSettingsDisasterRecovery to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDomainSettingsDisasterRecovery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDomainSettingsDisasterRecovery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FactPolicyRulesItemArgumentsItemSource as json.
func (o OptFactPolicyRulesItemArgumentsItemSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes FactPolicyRulesItemArgumentsItemSource from json.
func (o *OptFactPolicyRulesItemArgumentsItemSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFactPolicyRulesItemArgumentsItemSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFactPolicyRulesItemArgumentsItemSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFactPolicyRulesItemArgumentsItemSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HookName as json.
func (o OptHookName) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HookName from json.
func (o *OptHookName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHookName to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHookName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHookName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ImportAlias as json.
func (o OptImportAlias) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ImportAlias from json.
func (o *OptImportAlias) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptImportAlias to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptImportAlias) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptImportAlias) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LogEntryID as json.
func (o OptLogEntryID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LogEntryID from json.
func (o *OptLogEntryID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLogEntryID to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLogEntryID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLogEntryID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NewReadContextConfigRuleTokenFormat as json.
func (o OptNewReadContextConfigRuleTokenFormat) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NewReadContextConfigRuleTokenFormat from json.
func (o *OptNewReadContextConfigRuleTokenFormat) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNewReadContextConfigRuleTokenFormat to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNewReadContextConfigRuleTokenFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNewReadContextConfigRuleTokenFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NewReadContextConfigRuleTokenScope as json.
func (o OptNewReadContextConfigRuleTokenScope) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NewReadContextConfigRuleTokenScope from json.
func (o *OptNewReadContextConfigRuleTokenScope) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNewReadContextConfigRuleTokenScope to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNewReadContextConfigRuleTokenScope) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNewReadContextConfigRuleTokenScope) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReadContextConfigRuleTokenFormat as json.
func (o OptReadContextConfigRuleTokenFormat) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ReadContextConfigRuleTokenFormat from json.
func (o *OptReadContextConfigRuleTokenFormat) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReadContextConfigRuleTokenFormat to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReadContextConfigRuleTokenFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReadContextConfigRuleTokenFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReadContextConfigRuleTokenScope as json.
func (o OptReadContextConfigRuleTokenScope) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ReadContextConfigRuleTokenScope from json.
func (o *OptReadContextConfigRuleTokenScope) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReadContextConfigRuleTokenScope to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReadContextConfigRuleTokenScope) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReadContextConfigRuleTokenScope) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReadContextRuleFactsItemArgumentsItemSource as json.
func (o OptReadContextRuleFactsItemArgumentsItemSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ReadContextRuleFactsItemArgumentsItemSource from json.
func (o *OptReadContextRuleFactsItemArgumentsItemSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReadContextRuleFactsItemArgumentsItemSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReadContextRuleFactsItemArgumentsItemSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReadContextRuleFactsItemArgumentsItemSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReadContextRuleFactsItemOperator as json.
func (o OptReadContextRuleFactsItemOperator) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ReadContextRuleFactsItemOperator from json.
func (o *OptReadContextRuleFactsItemOperator) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReadContextRuleFactsItemOperator to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReadContextRuleFactsItemOperator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReadContextRuleFactsItemOperator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RuleID as json.
func (o OptRuleID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RuleID from json.
func (o *OptRuleID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRuleID to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRuleID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRuleID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TagValueField as json.
func (o OptTagValueField) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TagValueField from json.
func (o *OptTagValueField) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTagValueField to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTagValueField) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTagValueField) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VersionConstraint as json.
func (o OptVersionConstraint) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VersionConstraint from json.
func (o *OptVersionConstraint) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVersionConstraint to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVersionConstraint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVersionConstraint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WriteContextName as json.
func (o OptWriteContextName) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WriteContextName from json.
func (o *OptWriteContextName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWriteContextName to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWriteContextName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWriteContextName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WriteContextReference as json.
func (o OptWriteContextReference) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WriteContextReference from json.
func (o *OptWriteContextReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWriteContextReference to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWriteContextReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWriteContextReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PatchRequest as json.
func (s PatchRequest) Encode(e *jx.Encoder) {
	unwrapped := []PatchRequestItem(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes PatchRequest from json.
func (s *PatchRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PatchRequest to nil")
	}
	var unwrapped []PatchRequestItem
	if err := func() error {
		unwrapped = make([]PatchRequestItem, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PatchRequestItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PatchRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PatchRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PatchRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PatchRequestItem as json.
func (s PatchRequestItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s PatchRequestItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case JSONPatchRequestAddPatchRequestItem:
		e.FieldStart("op")
		e.Str("add")
		s.JSONPatchRequestAdd.encodeFields(e)
	case JSONPatchRequestCopyPatchRequestItem:
		e.FieldStart("op")
		e.Str("copy")
		s.JSONPatchRequestCopy.encodeFields(e)
	case JSONPatchRequestMovePatchRequestItem:
		e.FieldStart("op")
		e.Str("move")
		s.JSONPatchRequestMove.encodeFields(e)
	case JSONPatchRequestRemovePatchRequestItem:
		e.FieldStart("op")
		e.Str("remove")
		s.JSONPatchRequestRemove.encodeFields(e)
	case JSONPatchRequestReplacePatchRequestItem:
		e.FieldStart("op")
		e.Str("replace")
		s.JSONPatchRequestReplace.encodeFields(e)
	case JSONPatchRequestTstPatchRequestItem:
		e.FieldStart("op")
		e.Str("test")
		s.JSONPatchRequestTst.encodeFields(e)
	}
}

// Decode decodes PatchRequestItem from json.
func (s *PatchRequestItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PatchRequestItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "op":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "add":
					s.Type = JSONPatchRequestAddPatchRequestItem
					found = true
				case "copy":
					s.Type = JSONPatchRequestCopyPatchRequestItem
					found = true
				case "move":
					s.Type = JSONPatchRequestMovePatchRequestItem
					found = true
				case "remove":
					s.Type = JSONPatchRequestRemovePatchRequestItem
					found = true
				case "replace":
					s.Type = JSONPatchRequestReplacePatchRequestItem
					found = true
				case "test":
					s.Type = JSONPatchRequestTstPatchRequestItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case JSONPatchRequestAddPatchRequestItem:
		if err := s.JSONPatchRequestAdd.Decode(d); err != nil {
			return err
		}
	case JSONPatchRequestReplacePatchRequestItem:
		if err := s.JSONPatchRequestReplace.Decode(d); err != nil {
			return err
		}
	case JSONPatchRequestTstPatchRequestItem:
		if err := s.JSONPatchRequestTst.Decode(d); err != nil {
			return err
		}
	case JSONPatchRequestRemovePatchRequestItem:
		if err := s.JSONPatchRequestRemove.Decode(d); err != nil {
			return err
		}
	case JSONPatchRequestMovePatchRequestItem:
		if err := s.JSONPatchRequestMove.Decode(d); err != nil {
			return err
		}
	case JSONPatchRequestCopyPatchRequestItem:
		if err := s.JSONPatchRequestCopy.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PatchRequestItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PatchRequestItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PolicyRuleOperation as json.
func (s PolicyRuleOperation) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PolicyRuleOperation from json.
func (s *PolicyRuleOperation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PolicyRuleOperation to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PolicyRuleOperation(v) {
	case PolicyRuleOperationEdit:
		*s = PolicyRuleOperationEdit
	case PolicyRuleOperationView:
		*s = PolicyRuleOperationView
	case PolicyRuleOperationUse:
		*s = PolicyRuleOperationUse
	default:
		*s = PolicyRuleOperation(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PolicyRuleOperation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PolicyRuleOperation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PolicyRuleResult as json.
func (s PolicyRuleResult) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PolicyRuleResult from json.
func (s *PolicyRuleResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PolicyRuleResult to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PolicyRuleResult(v) {
	case PolicyRuleResultAllow:
		*s = PolicyRuleResultAllow
	case PolicyRuleResultDeny:
		*s = PolicyRuleResultDeny
	default:
		*s = PolicyRuleResult(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PolicyRuleResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PolicyRuleResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PrincipalID as json.
func (s PrincipalID) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes PrincipalID from json.
func (s *PrincipalID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PrincipalID to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PrincipalID(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PrincipalID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PrincipalID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PrincipalInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PrincipalInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("principalID")
		s.PrincipalID.Encode(e)
	}
	{
		e.FieldStart("capabilities")
		e.ArrStart()
		for _, elem := range s.Capabilities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("details")
		s.Details.Encode(e)
	}
}

var jsonFieldsNameOfPrincipalInfo = [3]string{
	0: "principalID",
	1: "capabilities",
	2: "details",
}

// Decode decodes PrincipalInfo from json.
func (s *PrincipalInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PrincipalInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "principalID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.PrincipalID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"principalID\"")
			}
		case "capabilities":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Capabilities = make([]Capability, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Capability
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Capabilities = append(s.Capabilities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capabilities\"")
			}
		case "details":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PrincipalInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPrincipalInfo) {
					name = jsonFieldsNameOfPrincipalInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PrincipalInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PrincipalInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PrincipalSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PrincipalSummary) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("principalID")
		s.PrincipalID.Encode(e)
	}
	{
		e.FieldStart("principalType")
		s.PrincipalType.Encode(e)
	}
	{
		e.FieldStart("comment")
		e.Str(s.Comment)
	}
}

var jsonFieldsNameOfPrincipalSummary = [3]string{
	0: "principalID",
	1: "principalType",
	2: "comment",
}

// Decode decodes PrincipalSummary from json.
func (s *PrincipalSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PrincipalSummary to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "principalID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.PrincipalID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"principalID\"")
			}
		case "principalType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.PrincipalType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"principalType\"")
			}
		case "comment":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Comment = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comment\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PrincipalSummary")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPrincipalSummary) {
					name = jsonFieldsNameOfPrincipalSummary[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PrincipalSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PrincipalSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReadContextConfigRule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReadContextConfigRule) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	{
		if s.MatchExpressions != nil {
			e.FieldStart("matchExpressions")
			s.MatchExpressions.Encode(e)
		}
	}
	{
		e.FieldStart("action")
		s.Action.Encode(e)
	}
	{
		if s.TokenScope.Set {
			e.FieldStart("tokenScope")
			s.TokenScope.Encode(e)
		}
	}
	{
		if s.TokenFormat.Set {
			e.FieldStart("tokenFormat")
			s.TokenFormat.Encode(e)
		}
	}
	{
		if s.Facts != nil {
			e.FieldStart("facts")
			s.Facts.Encode(e)
		}
	}
	{
		e.FieldStart("priority")
		e.Int(s.Priority)
	}
	{
		e.FieldStart("imported")
		e.Bool(s.Imported)
	}
	{
		if s.SourceDomainID.Set {
			e.FieldStart("sourceDomainID")
			s.SourceDomainID.Encode(e)
		}
	}
	{
		if s.SourceDomainName.Set {
			e.FieldStart("sourceDomainName")
			s.SourceDomainName.Encode(e)
		}
	}
}

var jsonFieldsNameOfReadContextConfigRule = [10]string{
	0: "id",
	1: "matchExpressions",
	2: "action",
	3: "tokenScope",
	4: "tokenFormat",
	5: "facts",
	6: "priority",
	7: "imported",
	8: "sourceDomainID",
	9: "sourceDomainName",
}

// Decode decodes ReadContextConfigRule from json.
func (s *ReadContextConfigRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReadContextConfigRule to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "matchExpressions":
			if err := func() error {
				if err := s.MatchExpressions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchExpressions\"")
			}
		case "action":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		case "tokenScope":
			if err := func() error {
				s.TokenScope.Reset()
				if err := s.TokenScope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokenScope\"")
			}
		case "tokenFormat":
			if err := func() error {
				s.TokenFormat.Reset()
				if err := s.TokenFormat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokenFormat\"")
			}
		case "facts":
			if err := func() error {
				if err := s.Facts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"facts\"")
			}
		case "priority":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Priority = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "imported":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.Imported = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imported\"")
			}
		case "sourceDomainID":
			if err := func() error {
				s.SourceDomainID.Reset()
				if err := s.SourceDomainID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sourceDomainID\"")
			}
		case "sourceDomainName":
			if err := func() error {
				s.SourceDomainName.Reset()
				if err := s.SourceDomainName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sourceDomainName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReadContextConfigRule")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11000101,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReadContextConfigRule) {
					name = jsonFieldsNameOfReadContextConfigRule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReadContextConfigRule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReadContextConfigRule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReadContextConfigRuleAction as json.
func (s ReadContextConfigRuleAction) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReadContextConfigRuleAction from json.
func (s *ReadContextConfigRuleAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReadContextConfigRuleAction to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReadContextConfigRuleAction(v) {
	case ReadContextConfigRuleActionDenyCapsule:
		*s = ReadContextConfigRuleActionDenyCapsule
	case ReadContextConfigRuleActionDenyRecord:
		*s = ReadContextConfigRuleActionDenyRecord
	case ReadContextConfigRuleActionRedact:
		*s = ReadContextConfigRuleActionRedact
	case ReadContextConfigRuleActionTokenize:
		*s = ReadContextConfigRuleActionTokenize
	case ReadContextConfigRuleActionAllow:
		*s = ReadContextConfigRuleActionAllow
	default:
		*s = ReadContextConfigRuleAction(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReadContextConfigRuleAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReadContextConfigRuleAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReadContextConfigRuleTokenFormat as json.
func (s ReadContextConfigRuleTokenFormat) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReadContextConfigRuleTokenFormat from json.
func (s *ReadContextConfigRuleTokenFormat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReadContextConfigRuleTokenFormat to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReadContextConfigRuleTokenFormat(v) {
	case ReadContextConfigRuleTokenFormatExplicit:
		*s = ReadContextConfigRuleTokenFormatExplicit
	case ReadContextConfigRuleTokenFormatSynthetic:
		*s = ReadContextConfigRuleTokenFormatSynthetic
	default:
		*s = ReadContextConfigRuleTokenFormat(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReadContextConfigRuleTokenFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReadContextConfigRuleTokenFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReadContextConfigRuleTokenScope as json.
func (s ReadContextConfigRuleTokenScope) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReadContextConfigRuleTokenScope from json.
func (s *ReadContextConfigRuleTokenScope) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReadContextConfigRuleTokenScope to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReadContextConfigRuleTokenScope(v) {
	case ReadContextConfigRuleTokenScopeUnique:
		*s = ReadContextConfigRuleTokenScopeUnique
	case ReadContextConfigRuleTokenScopeCapsule:
		*s = ReadContextConfigRuleTokenScopeCapsule
	case ReadContextConfigRuleTokenScopeDomain:
		*s = ReadContextConfigRuleTokenScopeDomain
	default:
		*s = ReadContextConfigRuleTokenScope(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReadContextConfigRuleTokenScope) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReadContextConfigRuleTokenScope) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReadContextDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReadContextDetails) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("summary")
		e.Str(s.Summary)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.DisableReadLogging.Set {
			e.FieldStart("disableReadLogging")
			s.DisableReadLogging.Encode(e)
		}
	}
	{
		if s.KeyCacheTTL.Set {
			e.FieldStart("keyCacheTTL")
			s.KeyCacheTTL.Encode(e)
		}
	}
	{
		if s.RequiredHooks != nil {
			e.FieldStart("requiredHooks")
			e.ArrStart()
			for _, elem := range s.RequiredHooks {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("readParameters")
		e.ArrStart()
		for _, elem := range s.ReadParameters {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("rules")
		e.ArrStart()
		for _, elem := range s.Rules {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("imported")
		e.Bool(s.Imported)
	}
	{
		if s.SourceDomainID.Set {
			e.FieldStart("sourceDomainID")
			s.SourceDomainID.Encode(e)
		}
	}
	{
		if s.SourceDomainName.Set {
			e.FieldStart("sourceDomainName")
			s.SourceDomainName.Encode(e)
		}
	}
	{
		e.FieldStart("policyAssembly")
		e.Base64(s.PolicyAssembly)
	}
}

var jsonFieldsNameOfReadContextDetails = [12]string{
	0:  "name",
	1:  "summary",
	2:  "description",
	3:  "disableReadLogging",
	4:  "keyCacheTTL",
	5:  "requiredHooks",
	6:  "readParameters",
	7:  "rules",
	8:  "imported",
	9:  "sourceDomainID",
	10: "sourceDomainName",
	11: "policyAssembly",
}

// Decode decodes ReadContextDetails from json.
func (s *ReadContextDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReadContextDetails to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "summary":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Summary = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "disableReadLogging":
			if err := func() error {
				s.DisableReadLogging.Reset()
				if err := s.DisableReadLogging.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disableReadLogging\"")
			}
		case "keyCacheTTL":
			if err := func() error {
				s.KeyCacheTTL.Reset()
				if err := s.KeyCacheTTL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keyCacheTTL\"")
			}
		case "requiredHooks":
			if err := func() error {
				s.RequiredHooks = make([]ReadContextRequiredHook, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReadContextRequiredHook
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RequiredHooks = append(s.RequiredHooks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requiredHooks\"")
			}
		case "readParameters":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.ReadParameters = make([]ReadContextParameter, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReadContextParameter
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ReadParameters = append(s.ReadParameters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readParameters\"")
			}
		case "rules":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.Rules = make([]ReadContextConfigRule, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReadContextConfigRule
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rules = append(s.Rules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		case "imported":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Imported = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imported\"")
			}
		case "sourceDomainID":
			if err := func() error {
				s.SourceDomainID.Reset()
				if err := s.SourceDomainID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sourceDomainID\"")
			}
		case "sourceDomainName":
			if err := func() error {
				s.SourceDomainName.Reset()
				if err := s.SourceDomainName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sourceDomainName\"")
			}
		case "policyAssembly":
			if err := func() error {
				v, err := d.Base64()
				s.PolicyAssembly = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"policyAssembly\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReadContextDetails")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11000111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReadContextDetails) {
					name = jsonFieldsNameOfReadContextDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReadContextDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReadContextDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReadContextList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReadContextList) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("readContexts")
		e.ArrStart()
		for _, elem := range s.ReadContexts {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfReadContextList = [1]string{
	0: "readContexts",
}

// Decode decodes ReadContextList from json.
func (s *ReadContextList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReadContextList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "readContexts":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ReadContexts = make([]ReadContextShortDetails, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReadContextShortDetails
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ReadContexts = append(s.ReadContexts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readContexts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReadContextList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReadContextList) {
					name = jsonFieldsNameOfReadContextList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReadContextList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReadContextList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReadContextName as json.
func (s ReadContextName) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes ReadContextName from json.
func (s *ReadContextName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReadContextName to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReadContextName(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReadContextName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReadContextName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReadContextParameter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReadContextParameter) encodeFields(e *jx.Encoder) {
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
	{
		if s.Required.Set {
			e.FieldStart("required")
			s.Required.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfReadContextParameter = [3]string{
	0: "key",
	1: "required",
	2: "description",
}

// Decode decodes ReadContextParameter from json.
func (s *ReadContextParameter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReadContextParameter to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "required":
			if err := func() error {
				s.Required.Reset()
				if err := s.Required.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReadContextParameter")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReadContextParameter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReadContextParameter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReadContextReference as json.
func (s ReadContextReference) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes ReadContextReference from json.
func (s *ReadContextReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReadContextReference to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReadContextReference(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReadContextReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReadContextReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReadContextRequiredHook) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReadContextRequiredHook) encodeFields(e *jx.Encoder) {
	{
		if s.Hook.Set {
			e.FieldStart("hook")
			s.Hook.Encode(e)
		}
	}
	{
		if s.Constraint.Set {
			e.FieldStart("constraint")
			s.Constraint.Encode(e)
		}
	}
	{
		if s.WriteContext.Set {
			e.FieldStart("writeContext")
			s.WriteContext.Encode(e)
		}
	}
}

var jsonFieldsNameOfReadContextRequiredHook = [3]string{
	0: "hook",
	1: "constraint",
	2: "writeContext",
}

// Decode decodes ReadContextRequiredHook from json.
func (s *ReadContextRequiredHook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReadContextRequiredHook to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hook":
			if err := func() error {
				s.Hook.Reset()
				if err := s.Hook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hook\"")
			}
		case "constraint":
			if err := func() error {
				s.Constraint.Reset()
				if err := s.Constraint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"constraint\"")
			}
		case "writeContext":
			if err := func() error {
				s.WriteContext.Reset()
				if err := s.WriteContext.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"writeContext\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReadContextRequiredHook")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReadContextRequiredHook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReadContextRequiredHook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReadContextRuleFacts as json.
func (s ReadContextRuleFacts) Encode(e *jx.Encoder) {
	unwrapped := []ReadContextRuleFactsItem(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReadContextRuleFacts from json.
func (s *ReadContextRuleFacts) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReadContextRuleFacts to nil")
	}
	var unwrapped []ReadContextRuleFactsItem
	if err := func() error {
		unwrapped = make([]ReadContextRuleFactsItem, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ReadContextRuleFactsItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReadContextRuleFacts(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReadContextRuleFacts) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReadContextRuleFacts) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReadContextRuleFactsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReadContextRuleFactsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Operator.Set {
			e.FieldStart("operator")
			s.Operator.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Arguments != nil {
			e.FieldStart("arguments")
			e.ArrStart()
			for _, elem := range s.Arguments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfReadContextRuleFactsItem = [3]string{
	0: "operator",
	1: "name",
	2: "arguments",
}

// Decode decodes ReadContextRuleFactsItem from json.
func (s *ReadContextRuleFactsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReadContextRuleFactsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "operator":
			if err := func() error {
				s.Operator.Reset()
				if err := s.Operator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "arguments":
			if err := func() error {
				s.Arguments = make([]ReadContextRuleFactsItemArgumentsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReadContextRuleFactsItemArgumentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Arguments = append(s.Arguments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arguments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReadContextRuleFactsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReadContextRuleFactsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReadContextRuleFactsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReadContextRuleFactsItemArgumentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReadContextRuleFactsItemArgumentsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfReadContextRuleFactsItemArgumentsItem = [3]string{
	0: "source",
	1: "key",
	2: "value",
}

// Decode decodes ReadContextRuleFactsItemArgumentsItem from json.
func (s *ReadContextRuleFactsItemArgumentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReadContextRuleFactsItemArgumentsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReadContextRuleFactsItemArgumentsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReadContextRuleFactsItemArgumentsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReadContextRuleFactsItemArgumentsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReadContextRuleFactsItemArgumentsItemSource as json.
func (s ReadContextRuleFactsItemArgumentsItemSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReadContextRuleFactsItemArgumentsItemSource from json.
func (s *ReadContextRuleFactsItemArgumentsItemSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReadContextRuleFactsItemArgumentsItemSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReadContextRuleFactsItemArgumentsItemSource(v) {
	case ReadContextRuleFactsItemArgumentsItemSourceDomainIdentity:
		*s = ReadContextRuleFactsItemArgumentsItemSourceDomainIdentity
	case ReadContextRuleFactsItemArgumentsItemSourceReadParameters:
		*s = ReadContextRuleFactsItemArgumentsItemSourceReadParameters
	case ReadContextRuleFactsItemArgumentsItemSourceTags:
		*s = ReadContextRuleFactsItemArgumentsItemSourceTags
	case ReadContextRuleFactsItemArgumentsItemSourceLiteral:
		*s = ReadContextRuleFactsItemArgumentsItemSourceLiteral
	default:
		*s = ReadContextRuleFactsItemArgumentsItemSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReadContextRuleFactsItemArgumentsItemSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReadContextRuleFactsItemArgumentsItemSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReadContextRuleFactsItemOperator as json.
func (s ReadContextRuleFactsItemOperator) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReadContextRuleFactsItemOperator from json.
func (s *ReadContextRuleFactsItemOperator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReadContextRuleFactsItemOperator to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReadContextRuleFactsItemOperator(v) {
	case ReadContextRuleFactsItemOperatorExists:
		*s = ReadContextRuleFactsItemOperatorExists
	case ReadContextRuleFactsItemOperatorNotExists:
		*s = ReadContextRuleFactsItemOperatorNotExists
	default:
		*s = ReadContextRuleFactsItemOperator(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReadContextRuleFactsItemOperator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReadContextRuleFactsItemOperator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReadContextRuleMatchExpressions as json.
func (s ReadContextRuleMatchExpressions) Encode(e *jx.Encoder) {
	unwrapped := []ReadContextRuleMatchExpressionsItem(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReadContextRuleMatchExpressions from json.
func (s *ReadContextRuleMatchExpressions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReadContextRuleMatchExpressions to nil")
	}
	var unwrapped []ReadContextRuleMatchExpressionsItem
	if err := func() error {
		unwrapped = make([]ReadContextRuleMatchExpressionsItem, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ReadContextRuleMatchExpressionsItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReadContextRuleMatchExpressions(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReadContextRuleMatchExpressions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReadContextRuleMatchExpressions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReadContextRuleMatchExpressionsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReadContextRuleMatchExpressionsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source")
		s.Source.Encode(e)
	}
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("operator")
		s.Operator.Encode(e)
	}
	{
		if s.Values != nil {
			e.FieldStart("values")
			e.ArrStart()
			for _, elem := range s.Values {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfReadContextRuleMatchExpressionsItem = [5]string{
	0: "source",
	1: "key",
	2: "operator",
	3: "values",
	4: "value",
}

// Decode decodes ReadContextRuleMatchExpressionsItem from json.
func (s *ReadContextRuleMatchExpressionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReadContextRuleMatchExpressionsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Operator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "values":
			if err := func() error {
				s.Values = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReadContextRuleMatchExpressionsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReadContextRuleMatchExpressionsItem) {
					name = jsonFieldsNameOfReadContextRuleMatchExpressionsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReadContextRuleMatchExpressionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReadContextRuleMatchExpressionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReadContextRuleMatchExpressionsItemOperator as json.
func (s ReadContextRuleMatchExpressionsItemOperator) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReadContextRuleMatchExpressionsItemOperator from json.
func (s *ReadContextRuleMatchExpressionsItemOperator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReadContextRuleMatchExpressionsItemOperator to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReadContextRuleMatchExpressionsItemOperator(v) {
	case ReadContextRuleMatchExpressionsItemOperatorIn:
		*s = ReadContextRuleMatchExpressionsItemOperatorIn
	case ReadContextRuleMatchExpressionsItemOperatorNotIn:
		*s = ReadContextRuleMatchExpressionsItemOperatorNotIn
	case ReadContextRuleMatchExpressionsItemOperatorExists:
		*s = ReadContextRuleMatchExpressionsItemOperatorExists
	case ReadContextRuleMatchExpressionsItemOperatorNotExists:
		*s = ReadContextRuleMatchExpressionsItemOperatorNotExists
	case ReadContextRuleMatchExpressionsItemOperatorDateDeltaLessThan:
		*s = ReadContextRuleMatchExpressionsItemOperatorDateDeltaLessThan
	case ReadContextRuleMatchExpressionsItemOperatorDateDeltaGreaterThan:
		*s = ReadContextRuleMatchExpressionsItemOperatorDateDeltaGreaterThan
	default:
		*s = ReadContextRuleMatchExpressionsItemOperator(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReadContextRuleMatchExpressionsItemOperator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReadContextRuleMatchExpressionsItemOperator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReadContextRuleMatchExpressionsItemSource as json.
func (s ReadContextRuleMatchExpressionsItemSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReadContextRuleMatchExpressionsItemSource from json.
func (s *ReadContextRuleMatchExpressionsItemSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReadContextRuleMatchExpressionsItemSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReadContextRuleMatchExpressionsItemSource(v) {
	case ReadContextRuleMatchExpressionsItemSourceDomainIdentity:
		*s = ReadContextRuleMatchExpressionsItemSourceDomainIdentity
	case ReadContextRuleMatchExpressionsItemSourceReadParameters:
		*s = ReadContextRuleMatchExpressionsItemSourceReadParameters
	case ReadContextRuleMatchExpressionsItemSourceTags:
		*s = ReadContextRuleMatchExpressionsItemSourceTags
	default:
		*s = ReadContextRuleMatchExpressionsItemSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReadContextRuleMatchExpressionsItemSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReadContextRuleMatchExpressionsItemSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReadContextShortDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReadContextShortDetails) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("summary")
		e.Str(s.Summary)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.DisableReadLogging.Set {
			e.FieldStart("disableReadLogging")
			s.DisableReadLogging.Encode(e)
		}
	}
	{
		if s.KeyCacheTTL.Set {
			e.FieldStart("keyCacheTTL")
			s.KeyCacheTTL.Encode(e)
		}
	}
	{
		e.FieldStart("readParameters")
		e.ArrStart()
		for _, elem := range s.ReadParameters {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("imported")
		e.Bool(s.Imported)
	}
	{
		if s.SourceDomainID.Set {
			e.FieldStart("sourceDomainID")
			s.SourceDomainID.Encode(e)
		}
	}
	{
		if s.SourceDomainName.Set {
			e.FieldStart("sourceDomainName")
			s.SourceDomainName.Encode(e)
		}
	}
}

var jsonFieldsNameOfReadContextShortDetails = [9]string{
	0: "name",
	1: "summary",
	2: "description",
	3: "disableReadLogging",
	4: "keyCacheTTL",
	5: "readParameters",
	6: "imported",
	7: "sourceDomainID",
	8: "sourceDomainName",
}

// Decode decodes ReadContextShortDetails from json.
func (s *ReadContextShortDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReadContextShortDetails to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "summary":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Summary = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "disableReadLogging":
			if err := func() error {
				s.DisableReadLogging.Reset()
				if err := s.DisableReadLogging.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disableReadLogging\"")
			}
		case "keyCacheTTL":
			if err := func() error {
				s.KeyCacheTTL.Reset()
				if err := s.KeyCacheTTL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keyCacheTTL\"")
			}
		case "readParameters":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.ReadParameters = make([]ReadContextParameter, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReadContextParameter
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ReadParameters = append(s.ReadParameters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readParameters\"")
			}
		case "imported":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Imported = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imported\"")
			}
		case "sourceDomainID":
			if err := func() error {
				s.SourceDomainID.Reset()
				if err := s.SourceDomainID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sourceDomainID\"")
			}
		case "sourceDomainName":
			if err := func() error {
				s.SourceDomainName.Reset()
				if err := s.SourceDomainName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sourceDomainName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReadContextShortDetails")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01100111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReadContextShortDetails) {
					name = jsonFieldsNameOfReadContextShortDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReadContextShortDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReadContextShortDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResourceExhaustedError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResourceExhaustedError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("resourceType")
		e.Str(s.ResourceType)
	}
	{
		e.FieldStart("identifier")
		e.Str(s.Identifier)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfResourceExhaustedError = [3]string{
	0: "resourceType",
	1: "identifier",
	2: "message",
}

// Decode decodes ResourceExhaustedError from json.
func (s *ResourceExhaustedError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceExhaustedError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ResourceType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "identifier":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Identifier = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identifier\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceExhaustedError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResourceExhaustedError) {
					name = jsonFieldsNameOfResourceExhaustedError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResourceExhaustedError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceExhaustedError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResourceNotFoundError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResourceNotFoundError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("resourceType")
		e.Str(s.ResourceType)
	}
	{
		e.FieldStart("identifier")
		e.Str(s.Identifier)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfResourceNotFoundError = [3]string{
	0: "resourceType",
	1: "identifier",
	2: "message",
}

// Decode decodes ResourceNotFoundError from json.
func (s *ResourceNotFoundError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceNotFoundError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ResourceType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "identifier":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Identifier = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identifier\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceNotFoundError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResourceNotFoundError) {
					name = jsonFieldsNameOfResourceNotFoundError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResourceNotFoundError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceNotFoundError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RootEncryptionKeyID as json.
func (s RootEncryptionKeyID) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes RootEncryptionKeyID from json.
func (s *RootEncryptionKeyID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RootEncryptionKeyID to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RootEncryptionKeyID(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RootEncryptionKeyID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RootEncryptionKeyID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RootEncryptionKeyIDResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RootEncryptionKeyIDResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("rekID")
		e.Str(s.RekID)
	}
}

var jsonFieldsNameOfRootEncryptionKeyIDResponse = [1]string{
	0: "rekID",
}

// Decode decodes RootEncryptionKeyIDResponse from json.
func (s *RootEncryptionKeyIDResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RootEncryptionKeyIDResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rekID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.RekID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rekID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RootEncryptionKeyIDResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRootEncryptionKeyIDResponse) {
					name = jsonFieldsNameOfRootEncryptionKeyIDResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RootEncryptionKeyIDResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RootEncryptionKeyIDResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RootEncryptionKeyItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RootEncryptionKeyItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
	{
		e.FieldStart("resourcePath")
		e.Str(s.ResourcePath)
	}
	{
		e.FieldStart("rekID")
		e.Str(s.RekID)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
}

var jsonFieldsNameOfRootEncryptionKeyItem = [4]string{
	0: "source",
	1: "resourcePath",
	2: "rekID",
	3: "description",
}

// Decode decodes RootEncryptionKeyItem from json.
func (s *RootEncryptionKeyItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RootEncryptionKeyItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "resourcePath":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ResourcePath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourcePath\"")
			}
		case "rekID":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.RekID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rekID\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RootEncryptionKeyItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRootEncryptionKeyItem) {
					name = jsonFieldsNameOfRootEncryptionKeyItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RootEncryptionKeyItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RootEncryptionKeyItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RootEncryptionKeyListResponse as json.
func (s RootEncryptionKeyListResponse) Encode(e *jx.Encoder) {
	unwrapped := []RootEncryptionKeyItem(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes RootEncryptionKeyListResponse from json.
func (s *RootEncryptionKeyListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RootEncryptionKeyListResponse to nil")
	}
	var unwrapped []RootEncryptionKeyItem
	if err := func() error {
		unwrapped = make([]RootEncryptionKeyItem, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem RootEncryptionKeyItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RootEncryptionKeyListResponse(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RootEncryptionKeyListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RootEncryptionKeyListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RootEncryptionKeyTestResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RootEncryptionKeyTestResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
	{
		e.FieldStart("resourcePath")
		e.Str(s.ResourcePath)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("statusMessage")
		e.Str(s.StatusMessage)
	}
	{
		e.FieldStart("latencyMS")
		e.Float64(s.LatencyMS)
	}
}

var jsonFieldsNameOfRootEncryptionKeyTestResponse = [7]string{
	0: "id",
	1: "source",
	2: "resourcePath",
	3: "description",
	4: "status",
	5: "statusMessage",
	6: "latencyMS",
}

// Decode decodes RootEncryptionKeyTestResponse from json.
func (s *RootEncryptionKeyTestResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RootEncryptionKeyTestResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "source":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "resourcePath":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ResourcePath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourcePath\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "statusMessage":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.StatusMessage = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusMessage\"")
			}
		case "latencyMS":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.LatencyMS = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latencyMS\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RootEncryptionKeyTestResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRootEncryptionKeyTestResponse) {
					name = jsonFieldsNameOfRootEncryptionKeyTestResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RootEncryptionKeyTestResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RootEncryptionKeyTestResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RootEncryptionKeyTestResponseStatus as json.
func (s RootEncryptionKeyTestResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RootEncryptionKeyTestResponseStatus from json.
func (s *RootEncryptionKeyTestResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RootEncryptionKeyTestResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RootEncryptionKeyTestResponseStatus(v) {
	case RootEncryptionKeyTestResponseStatusHEALTHY:
		*s = RootEncryptionKeyTestResponseStatusHEALTHY
	case RootEncryptionKeyTestResponseStatusUNREACHABLE:
		*s = RootEncryptionKeyTestResponseStatusUNREACHABLE
	case RootEncryptionKeyTestResponseStatusMISCONFIGURED:
		*s = RootEncryptionKeyTestResponseStatusMISCONFIGURED
	default:
		*s = RootEncryptionKeyTestResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RootEncryptionKeyTestResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RootEncryptionKeyTestResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RotateKeyEncryptionKeyResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RotateKeyEncryptionKeyResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("has_more")
		e.Bool(s.HasMore)
	}
}

var jsonFieldsNameOfRotateKeyEncryptionKeyResponse = [1]string{
	0: "has_more",
}

// Decode decodes RotateKeyEncryptionKeyResponse from json.
func (s *RotateKeyEncryptionKeyResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RotateKeyEncryptionKeyResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "has_more":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_more\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RotateKeyEncryptionKeyResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRotateKeyEncryptionKeyResponse) {
					name = jsonFieldsNameOfRotateKeyEncryptionKeyResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RotateKeyEncryptionKeyResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RotateKeyEncryptionKeyResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RuleID as json.
func (s RuleID) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes RuleID from json.
func (s *RuleID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleID to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RuleID(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RuleID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RuleReference as json.
func (s RuleReference) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes RuleReference from json.
func (s *RuleReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleReference to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RuleReference(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RuleReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionID as json.
func (s SessionID) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes SessionID from json.
func (s *SessionID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionID to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SessionID(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SessionID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StarredDomainAddReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StarredDomainAddReq) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfStarredDomainAddReq = [0]string{}

// Decode decodes StarredDomainAddReq from json.
func (s *StarredDomainAddReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StarredDomainAddReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode StarredDomainAddReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StarredDomainAddReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StarredDomainAddReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StarredDomainList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StarredDomainList) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("domains")
		e.ArrStart()
		for _, elem := range s.Domains {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfStarredDomainList = [1]string{
	0: "domains",
}

// Decode decodes StarredDomainList from json.
func (s *StarredDomainList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StarredDomainList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domains":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Domains = make([]DomainID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DomainID
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Domains = append(s.Domains, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domains\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StarredDomainList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStarredDomainList) {
					name = jsonFieldsNameOfStarredDomainList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StarredDomainList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StarredDomainList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Tag) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Tag) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("value")
		s.Value.Encode(e)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
	{
		if s.HookVersion.Set {
			e.FieldStart("hook_version")
			s.HookVersion.Encode(e)
		}
	}
}

var jsonFieldsNameOfTag = [5]string{
	0: "name",
	1: "value",
	2: "type",
	3: "source",
	4: "hook_version",
}

// Decode decodes Tag from json.
func (s *Tag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Tag to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "source":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "hook_version":
			if err := func() error {
				s.HookVersion.Reset()
				if err := s.HookVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hook_version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Tag")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTag) {
					name = jsonFieldsNameOfTag[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Tag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Tag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TagMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TagMeta) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfTagMeta = [1]string{
	0: "name",
}

// Decode decodes TagMeta from json.
func (s *TagMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagMeta to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TagMeta")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTagMeta) {
					name = jsonFieldsNameOfTagMeta[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TagMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TagNameField as json.
func (s TagNameField) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes TagNameField from json.
func (s *TagNameField) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagNameField to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TagNameField(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TagNameField) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagNameField) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TagSet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TagSet) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("capsuleTags")
		e.ArrStart()
		for _, elem := range s.CapsuleTags {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("spanTags")
		e.ArrStart()
		for _, elem := range s.SpanTags {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfTagSet = [2]string{
	0: "capsuleTags",
	1: "spanTags",
}

// Decode decodes TagSet from json.
func (s *TagSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagSet to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "capsuleTags":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.CapsuleTags = make([]Tag, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Tag
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CapsuleTags = append(s.CapsuleTags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capsuleTags\"")
			}
		case "spanTags":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.SpanTags = make([]TagSetSpanTagsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TagSetSpanTagsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SpanTags = append(s.SpanTags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spanTags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TagSet")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTagSet) {
					name = jsonFieldsNameOfTagSet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TagSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TagSetSpanTagsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TagSetSpanTagsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("start")
		e.Int64(s.Start)
	}
	{
		e.FieldStart("end")
		e.Int64(s.End)
	}
	{
		e.FieldStart("tags")
		e.ArrStart()
		for _, elem := range s.Tags {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfTagSetSpanTagsItem = [3]string{
	0: "start",
	1: "end",
	2: "tags",
}

// Decode decodes TagSetSpanTagsItem from json.
func (s *TagSetSpanTagsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagSetSpanTagsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "start":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.Start = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "end":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.End = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "tags":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Tags = make([]Tag, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Tag
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TagSetSpanTagsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTagSetSpanTagsItem) {
					name = jsonFieldsNameOfTagSetSpanTagsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TagSetSpanTagsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagSetSpanTagsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TagSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TagSummary) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uniqueTags")
		e.ArrStart()
		for _, elem := range s.UniqueTags {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("elidedTags")
		e.ArrStart()
		for _, elem := range s.ElidedTags {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfTagSummary = [2]string{
	0: "uniqueTags",
	1: "elidedTags",
}

// Decode decodes TagSummary from json.
func (s *TagSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagSummary to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uniqueTags":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.UniqueTags = make([]TagSummaryUniqueTagsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TagSummaryUniqueTagsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.UniqueTags = append(s.UniqueTags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uniqueTags\"")
			}
		case "elidedTags":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ElidedTags = make([]TagSummaryElidedTagsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TagSummaryElidedTagsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ElidedTags = append(s.ElidedTags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elidedTags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TagSummary")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTagSummary) {
					name = jsonFieldsNameOfTagSummary[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TagSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TagSummaryElidedTagsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TagSummaryElidedTagsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tagName")
		e.Str(s.TagName)
	}
	{
		e.FieldStart("numUniqueTags")
		e.Int(s.NumUniqueTags)
	}
	{
		e.FieldStart("totalOccurrences")
		e.Int(s.TotalOccurrences)
	}
}

var jsonFieldsNameOfTagSummaryElidedTagsItem = [3]string{
	0: "tagName",
	1: "numUniqueTags",
	2: "totalOccurrences",
}

// Decode decodes TagSummaryElidedTagsItem from json.
func (s *TagSummaryElidedTagsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagSummaryElidedTagsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tagName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TagName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tagName\"")
			}
		case "numUniqueTags":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.NumUniqueTags = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numUniqueTags\"")
			}
		case "totalOccurrences":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.TotalOccurrences = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalOccurrences\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TagSummaryElidedTagsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTagSummaryElidedTagsItem) {
					name = jsonFieldsNameOfTagSummaryElidedTagsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TagSummaryElidedTagsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagSummaryElidedTagsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TagSummaryUniqueTagsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TagSummaryUniqueTagsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("occurrences")
		e.Int(s.Occurrences)
	}
}

var jsonFieldsNameOfTagSummaryUniqueTagsItem = [2]string{
	0: "tag",
	1: "occurrences",
}

// Decode decodes TagSummaryUniqueTagsItem from json.
func (s *TagSummaryUniqueTagsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagSummaryUniqueTagsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tag":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "occurrences":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Occurrences = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"occurrences\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TagSummaryUniqueTagsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTagSummaryUniqueTagsItem) {
					name = jsonFieldsNameOfTagSummaryUniqueTagsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TagSummaryUniqueTagsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagSummaryUniqueTagsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TagTypeField as json.
func (s TagTypeField) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TagTypeField from json.
func (s *TagTypeField) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagTypeField to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TagTypeField(v) {
	case TagTypeFieldString:
		*s = TagTypeFieldString
	case TagTypeFieldNumber:
		*s = TagTypeFieldNumber
	case TagTypeFieldBoolean:
		*s = TagTypeFieldBoolean
	case TagTypeFieldDate:
		*s = TagTypeFieldDate
	case TagTypeFieldUnary:
		*s = TagTypeFieldUnary
	default:
		*s = TagTypeField(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TagTypeField) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagTypeField) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TagValueField as json.
func (s TagValueField) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes TagValueField from json.
func (s *TagValueField) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagValueField to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TagValueField(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TagValueField) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagValueField) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnauthorizedError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnauthorizedError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfUnauthorizedError = [1]string{
	0: "message",
}

// Decode decodes UnauthorizedError from json.
func (s *UnauthorizedError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnauthorizedError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnauthorizedError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnauthorizedError) {
					name = jsonFieldsNameOfUnauthorizedError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnauthorizedError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnauthorizedError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpsertSpanTagsRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpsertSpanTagsRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("summary")
		s.Summary.Encode(e)
	}
	{
		e.FieldStart("createToken")
		s.CreateToken.Encode(e)
	}
}

var jsonFieldsNameOfUpsertSpanTagsRequest = [2]string{
	0: "summary",
	1: "createToken",
}

// Decode decodes UpsertSpanTagsRequest from json.
func (s *UpsertSpanTagsRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpsertSpanTagsRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "summary":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Summary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "createToken":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.CreateToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createToken\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpsertSpanTagsRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpsertSpanTagsRequest) {
					name = jsonFieldsNameOfUpsertSpanTagsRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpsertSpanTagsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpsertSpanTagsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VerifyContactResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VerifyContactResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("domain")
		s.Domain.Encode(e)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfVerifyContactResponse = [3]string{
	0: "domain",
	1: "email",
	2: "message",
}

// Decode decodes VerifyContactResponse from json.
func (s *VerifyContactResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifyContactResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domain":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VerifyContactResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVerifyContactResponse) {
					name = jsonFieldsNameOfVerifyContactResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VerifyContactResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifyContactResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VersionConstraint as json.
func (s VersionConstraint) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes VersionConstraint from json.
func (s *VersionConstraint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VersionConstraint to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VersionConstraint(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VersionConstraint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VersionConstraint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WriteContextConfigInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WriteContextConfigInfo) encodeFields(e *jx.Encoder) {
	{
		if s.KeyReuseTTL.Set {
			e.FieldStart("keyReuseTTL")
			s.KeyReuseTTL.Encode(e)
		}
	}
	{
		if s.DefaultCapsuleTags != nil {
			e.FieldStart("defaultCapsuleTags")
			e.ArrStart()
			for _, elem := range s.DefaultCapsuleTags {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("requiredHooks")
		e.ArrStart()
		for _, elem := range s.RequiredHooks {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfWriteContextConfigInfo = [3]string{
	0: "keyReuseTTL",
	1: "defaultCapsuleTags",
	2: "requiredHooks",
}

// Decode decodes WriteContextConfigInfo from json.
func (s *WriteContextConfigInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WriteContextConfigInfo to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "keyReuseTTL":
			if err := func() error {
				s.KeyReuseTTL.Reset()
				if err := s.KeyReuseTTL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keyReuseTTL\"")
			}
		case "defaultCapsuleTags":
			if err := func() error {
				s.DefaultCapsuleTags = make([]WriteContextRegexTag, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WriteContextRegexTag
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DefaultCapsuleTags = append(s.DefaultCapsuleTags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultCapsuleTags\"")
			}
		case "requiredHooks":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.RequiredHooks = make([]WriteContextConfigInfoRequiredHooksItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WriteContextConfigInfoRequiredHooksItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RequiredHooks = append(s.RequiredHooks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requiredHooks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WriteContextConfigInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWriteContextConfigInfo) {
					name = jsonFieldsNameOfWriteContextConfigInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WriteContextConfigInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WriteContextConfigInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WriteContextConfigInfoRequiredHooksItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WriteContextConfigInfoRequiredHooksItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hook")
		s.Hook.Encode(e)
	}
	{
		e.FieldStart("constraint")
		s.Constraint.Encode(e)
	}
	{
		e.FieldStart("mode")
		s.Mode.Encode(e)
	}
}

var jsonFieldsNameOfWriteContextConfigInfoRequiredHooksItem = [3]string{
	0: "hook",
	1: "constraint",
	2: "mode",
}

// Decode decodes WriteContextConfigInfoRequiredHooksItem from json.
func (s *WriteContextConfigInfoRequiredHooksItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WriteContextConfigInfoRequiredHooksItem to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hook":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Hook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hook\"")
			}
		case "constraint":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Constraint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"constraint\"")
			}
		case "mode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Mode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WriteContextConfigInfoRequiredHooksItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWriteContextConfigInfoRequiredHooksItem) {
					name = jsonFieldsNameOfWriteContextConfigInfoRequiredHooksItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WriteContextConfigInfoRequiredHooksItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WriteContextConfigInfoRequiredHooksItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WriteContextConfigInfoRequiredHooksItemMode as json.
func (s WriteContextConfigInfoRequiredHooksItemMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WriteContextConfigInfoRequiredHooksItemMode from json.
func (s *WriteContextConfigInfoRequiredHooksItemMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WriteContextConfigInfoRequiredHooksItemMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WriteContextConfigInfoRequiredHooksItemMode(v) {
	case WriteContextConfigInfoRequiredHooksItemModeSync:
		*s = WriteContextConfigInfoRequiredHooksItemModeSync
	case WriteContextConfigInfoRequiredHooksItemModeAsync:
		*s = WriteContextConfigInfoRequiredHooksItemModeAsync
	default:
		*s = WriteContextConfigInfoRequiredHooksItemMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WriteContextConfigInfoRequiredHooksItemMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WriteContextConfigInfoRequiredHooksItemMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WriteContextDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WriteContextDetails) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("summary")
		e.Str(s.Summary)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("imported")
		e.Bool(s.Imported)
	}
	{
		if s.SourceDomainID.Set {
			e.FieldStart("sourceDomainID")
			s.SourceDomainID.Encode(e)
		}
	}
	{
		if s.SourceDomainName.Set {
			e.FieldStart("sourceDomainName")
			s.SourceDomainName.Encode(e)
		}
	}
}

var jsonFieldsNameOfWriteContextDetails = [7]string{
	0: "name",
	1: "summary",
	2: "description",
	3: "config",
	4: "imported",
	5: "sourceDomainID",
	6: "sourceDomainName",
}

// Decode decodes WriteContextDetails from json.
func (s *WriteContextDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WriteContextDetails to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "summary":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Summary = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "config":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "imported":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Imported = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imported\"")
			}
		case "sourceDomainID":
			if err := func() error {
				s.SourceDomainID.Reset()
				if err := s.SourceDomainID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sourceDomainID\"")
			}
		case "sourceDomainName":
			if err := func() error {
				s.SourceDomainName.Reset()
				if err := s.SourceDomainName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sourceDomainName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WriteContextDetails")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWriteContextDetails) {
					name = jsonFieldsNameOfWriteContextDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WriteContextDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WriteContextDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WriteContextList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WriteContextList) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("writeContexts")
		e.ArrStart()
		for _, elem := range s.WriteContexts {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfWriteContextList = [1]string{
	0: "writeContexts",
}

// Decode decodes WriteContextList from json.
func (s *WriteContextList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WriteContextList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "writeContexts":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.WriteContexts = make([]WriteContextDetails, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WriteContextDetails
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.WriteContexts = append(s.WriteContexts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"writeContexts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WriteContextList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWriteContextList) {
					name = jsonFieldsNameOfWriteContextList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WriteContextList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WriteContextList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WriteContextName as json.
func (s WriteContextName) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes WriteContextName from json.
func (s *WriteContextName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WriteContextName to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WriteContextName(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WriteContextName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WriteContextName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WriteContextReference as json.
func (s WriteContextReference) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes WriteContextReference from json.
func (s *WriteContextReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WriteContextReference to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WriteContextReference(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WriteContextReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WriteContextReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WriteContextRegexRule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WriteContextRegexRule) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("pattern")
		e.Str(s.Pattern)
	}
	{
		e.FieldStart("matchOnKey")
		e.Bool(s.MatchOnKey)
	}
	{
		e.FieldStart("spanTags")
		e.ArrStart()
		for _, elem := range s.SpanTags {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("capsuleTags")
		e.ArrStart()
		for _, elem := range s.CapsuleTags {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfWriteContextRegexRule = [5]string{
	0: "id",
	1: "pattern",
	2: "matchOnKey",
	3: "spanTags",
	4: "capsuleTags",
}

// Decode decodes WriteContextRegexRule from json.
func (s *WriteContextRegexRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WriteContextRegexRule to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "pattern":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Pattern = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pattern\"")
			}
		case "matchOnKey":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.MatchOnKey = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchOnKey\"")
			}
		case "spanTags":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.SpanTags = make([]WriteContextRegexTag, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WriteContextRegexTag
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SpanTags = append(s.SpanTags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spanTags\"")
			}
		case "capsuleTags":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.CapsuleTags = make([]WriteContextRegexTag, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WriteContextRegexTag
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CapsuleTags = append(s.CapsuleTags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capsuleTags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WriteContextRegexRule")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWriteContextRegexRule) {
					name = jsonFieldsNameOfWriteContextRegexRule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WriteContextRegexRule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WriteContextRegexRule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WriteContextRegexTag) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WriteContextRegexTag) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfWriteContextRegexTag = [3]string{
	0: "name",
	1: "value",
	2: "type",
}

// Decode decodes WriteContextRegexTag from json.
func (s *WriteContextRegexTag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WriteContextRegexTag to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WriteContextRegexTag")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWriteContextRegexTag) {
					name = jsonFieldsNameOfWriteContextRegexTag[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WriteContextRegexTag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WriteContextRegexTag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
