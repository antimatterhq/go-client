// Code generated by ogen, DO NOT EDIT.

package spec

import (
	"context"
	"fmt"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.19.0"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// CapsuleGetById invokes capsuleGetById operation.
	//
	// This endpoint allows you to get a Capsule without knowing the Domain ID. It will redirect the user
	// to the full `/domains/{domainID}/capsules/{capsuleID}` path.
	//
	// GET /capsules/{capsuleID}
	CapsuleGetById(ctx context.Context, params CapsuleGetByIdParams) (CapsuleGetByIdRes, error)
	// DomainAddAccessLogEntry invokes domainAddAccessLogEntry operation.
	//
	// Adds a data-plane audit log entry for this capsule. Contains information about the originating
	// principal and about read tag rollups. Contains an open capsule token (read from the file) to
	// ensure that you legitimately read the capsule. Note that not all audit log entry types may be
	// added with this method. Some (like open records) are generated server side.
	//
	// POST /domains/{domainID}/capsules/{capsuleID}/log
	DomainAddAccessLogEntry(ctx context.Context, request *AddCapsuleLogEntryRequest, params DomainAddAccessLogEntryParams) (DomainAddAccessLogEntryRes, error)
	// DomainAddExternalRootEncryptionKey invokes domainAddExternalRootEncryptionKey operation.
	//
	// Add a new external root encryption key with its supporting access configuration.
	//
	// POST /domains/{domainID}/control/keys
	DomainAddExternalRootEncryptionKey(ctx context.Context, request *KeyInfos, params DomainAddExternalRootEncryptionKeyParams) (DomainAddExternalRootEncryptionKeyRes, error)
	// DomainAddNew invokes domainAddNew operation.
	//
	// Add a new domain with no default peer relationships. You will need to confirm the email address
	// before the domain is able to be interacted with.
	//
	// POST /domains
	DomainAddNew(ctx context.Context, request *NewDomain) (DomainAddNewRes, error)
	// DomainAddReadContextRule invokes domainAddReadContextRule operation.
	//
	// Read context configuration is rule based, much like domain policy. This adds a new rule to the
	// read context. Rules are processed in priority order, stopping with the first matching rule.
	//
	// POST /domains/{domainID}/control/read-context/{contextName}/config
	DomainAddReadContextRule(ctx context.Context, request *NewReadContextConfigRule, params DomainAddReadContextRuleParams) (DomainAddReadContextRuleRes, error)
	// DomainAuthenticate invokes domainAuthenticate operation.
	//
	// Use an authentication method to obtain a domain ID token which is used as the bearer for all other
	// endpoints. You can use the `/public-info` route to obtain a list of identity providers supported
	// by this endpoint.
	//
	// POST /domains/{domainID}/authenticate
	DomainAuthenticate(ctx context.Context, request *DomainAuthenticate, params DomainAuthenticateParams) (DomainAuthenticateRes, error)
	// DomainContactIssueVerify invokes domainContactIssueVerify operation.
	//
	// Issue a new verification request to a pending contact email associated with the domain. There is a
	// rate limiter on this endpoint, you may need to wait between invocations.
	//
	// POST /domains/{domainID}/account/verify
	DomainContactIssueVerify(ctx context.Context, request *DomainContactIssueVerifyReq, params DomainContactIssueVerifyParams) (DomainContactIssueVerifyRes, error)
	// DomainContactVerify invokes domainContactVerify operation.
	//
	// Verify an admin contact email recently associated with a domain. The token will have been emailed
	// (in the form of a link) to the email address when `/account/verify` is called, the domain was
	// initially created, or the email was added via the settings endpoint.
	//
	// GET /domains/{domainID}/account/verify
	DomainContactVerify(ctx context.Context, params DomainContactVerifyParams) (DomainContactVerifyRes, error)
	// DomainCreateCapsule invokes domainCreateCapsule operation.
	//
	// Create a new capsule. The ID will be returned. Capsule will be "unsealed" first, meaning it's
	// still in a creating state. Returns a capsule create token that can be used to feed in additional
	// data about the capsule while it's still unsealed. Also returns a DEK and an encrypted DEK.
	//
	// POST /domains/{domainID}/capsules
	DomainCreateCapsule(ctx context.Context, request *DomainCreateCapsuleReq, params DomainCreateCapsuleParams) (DomainCreateCapsuleRes, error)
	// DomainCreatePeerDomain invokes domainCreatePeerDomain operation.
	//
	// Create a domain with a default "subordinate" peering relationship with the current domain.
	// Namely, the current "parent" domain will be configured to allow the new "child" domain to use the
	// parent's billing and admin contact settings, and the child domain will be configured to import
	// those settings.
	// Optionally, similar linking can be performed for identity providers, read/write contexts and facts
	// by setting the appropriate linkX parameter to true. In most cases, what you want is to set
	// `linkAll=true`.
	// Note, that a "subdomain" is just shorthand for a domain with the above-described peering config.
	// This peering can be changed at any time, and there is no permanent difference between a domain
	// created in this way, and a domain created with POST /domains.
	//
	// POST /domains/{domainID}/peer-domain
	DomainCreatePeerDomain(ctx context.Context, request *CreatePeerDomain, params DomainCreatePeerDomainParams) (DomainCreatePeerDomainRes, error)
	// DomainCreatePolicyRule invokes domainCreatePolicyRule operation.
	//
	// Create a domain policy rule.
	//
	// POST /domains/{domainID}/control/policy
	DomainCreatePolicyRule(ctx context.Context, request *NewDomainPolicyRule, params DomainCreatePolicyRuleParams) (DomainCreatePolicyRuleRes, error)
	// DomainDataTaggingHookInvoke invokes domainDataTaggingHookInvoke operation.
	//
	// Invoke a hook that operates on data and returns tags.
	//
	// POST /domains/{domainID}/hooks/data-tagging/{hookName}/invoke
	DomainDataTaggingHookInvoke(ctx context.Context, request *DataTaggingHookInput, params DomainDataTaggingHookInvokeParams) (DomainDataTaggingHookInvokeRes, error)
	// DomainDeleteCapability invokes domainDeleteCapability operation.
	//
	// Delete a capability. All domain policy rules that reference the capability must have already been
	// deleted, or you will receive a 409 error.
	//
	// DELETE /domains/{domainID}/control/capabilities/{capability}
	DomainDeleteCapability(ctx context.Context, params DomainDeleteCapabilityParams) (DomainDeleteCapabilityRes, error)
	// DomainDeleteCapsuleTags invokes domainDeleteCapsuleTags operation.
	//
	// Delete capsule-level tags.
	//
	// POST /domains/{domainID}/capsules/{capsuleID}/capsule-tags/delete
	DomainDeleteCapsuleTags(ctx context.Context, request *DeleteTags, params DomainDeleteCapsuleTagsParams) (DomainDeleteCapsuleTagsRes, error)
	// DomainDeleteExternalRootEncryptionKey invokes domainDeleteExternalRootEncryptionKey operation.
	//
	// Delete an external root encryption key using its ID. This operation is only successful if the
	// external root encryption key is not in use by any key encryption keys. Call the /keys/rotate
	// endpoint to ensure that all KEKs have been migrated to the active REK.
	//
	// DELETE /domains/{domainID}/control/keys/{rootEncryptionKeyID}
	DomainDeleteExternalRootEncryptionKey(ctx context.Context, params DomainDeleteExternalRootEncryptionKeyParams) (DomainDeleteExternalRootEncryptionKeyRes, error)
	// DomainDeleteFactByID invokes domainDeleteFactByID operation.
	//
	// Delete a fact by ID.
	//
	// DELETE /domains/{domainID}/control/facts/{factType}/{factID}
	DomainDeleteFactByID(ctx context.Context, params DomainDeleteFactByIDParams) (DomainDeleteFactByIDRes, error)
	// DomainDeleteFactType invokes domainDeleteFactType operation.
	//
	// Deletes a fact type and all facts inside it.
	//
	// DELETE /domains/{domainID}/control/facts/{factType}
	DomainDeleteFactType(ctx context.Context, params DomainDeleteFactTypeParams) (DomainDeleteFactTypeRes, error)
	// DomainDeleteIdentityProvider invokes domainDeleteIdentityProvider operation.
	//
	// Delete an identity provider. All domain tokens created using this identity provider will be
	// invalidated. Take care not to remove the identity provider that is providing you admin access to
	// your domain, as you may "lock yourself out".
	//
	// DELETE /domains/{domainID}/control/identities/{identityProviderName}
	DomainDeleteIdentityProvider(ctx context.Context, params DomainDeleteIdentityProviderParams) (DomainDeleteIdentityProviderRes, error)
	// DomainDeleteIdentityProviderPrincipal invokes domainDeleteIdentityProviderPrincipal operation.
	//
	// Delete an identity provider principal.
	//
	// DELETE /domains/{domainID}/control/identities/{identityProviderName}/principals/{principalID}
	DomainDeleteIdentityProviderPrincipal(ctx context.Context, params DomainDeleteIdentityProviderPrincipalParams) (DomainDeleteIdentityProviderPrincipalRes, error)
	// DomainDeletePeer invokes domainDeletePeer operation.
	//
	// Removes the peering relationship with the given domain.
	//
	// DELETE /domains/{domainID}/control/peers/{peerDomainID}
	DomainDeletePeer(ctx context.Context, params DomainDeletePeerParams) (DomainDeletePeerRes, error)
	// DomainDeletePolicyRule invokes domainDeletePolicyRule operation.
	//
	// Delete a domain policy rule by ID.
	//
	// DELETE /domains/{domainID}/control/policy/{ruleID}
	DomainDeletePolicyRule(ctx context.Context, params DomainDeletePolicyRuleParams) (DomainDeletePolicyRuleRes, error)
	// DomainDeleteReadContext invokes domainDeleteReadContext operation.
	//
	// Delete a read context. All configuration associated with this read context will also be deleted.
	// Domain policy rules referencing this read context will be left as-is.
	//
	// DELETE /domains/{domainID}/control/read-context/{contextName}
	DomainDeleteReadContext(ctx context.Context, params DomainDeleteReadContextParams) (DomainDeleteReadContextRes, error)
	// DomainDeleteReadContextRule invokes domainDeleteReadContextRule operation.
	//
	// Deletes a read context configuration rule by ID.
	//
	// DELETE /domains/{domainID}/control/read-context/{contextName}/config/{ruleID}
	DomainDeleteReadContextRule(ctx context.Context, params DomainDeleteReadContextRuleParams) (DomainDeleteReadContextRuleRes, error)
	// DomainDeleteWriteContext invokes domainDeleteWriteContext operation.
	//
	// Delete a write context. All configuration associated with this write context will also be deleted.
	// Domain policy rules referencing this write context will be left as-is.
	//
	// DELETE /domains/{domainID}/control/write-context/{contextName}
	DomainDeleteWriteContext(ctx context.Context, params DomainDeleteWriteContextParams) (DomainDeleteWriteContextRes, error)
	// DomainDeleteWriteContextRegexRule invokes domainDeleteWriteContextRegexRule operation.
	//
	// Delete a regex classifier rule for the context.
	//
	// DELETE /domains/{domainID}/control/write-context/{contextName}/regex-rule/{ruleID}
	DomainDeleteWriteContextRegexRule(ctx context.Context, params DomainDeleteWriteContextRegexRuleParams) (DomainDeleteWriteContextRegexRuleRes, error)
	// DomainDescribeWriteContext invokes domainDescribeWriteContext operation.
	//
	// Returns a detailed description of a write context.
	//
	// GET /domains/{domainID}/control/write-context/{contextName}
	DomainDescribeWriteContext(ctx context.Context, params DomainDescribeWriteContextParams) (DomainDescribeWriteContextRes, error)
	// DomainExternalRootEncryptionKeyTest invokes domainExternalRootEncryptionKeyTest operation.
	//
	// Attempts to use a root encryption key to encrypt and decrypt, validating its availability.
	//
	// POST /domains/{domainID}/control/keys/{rootEncryptionKeyID}/test
	DomainExternalRootEncryptionKeyTest(ctx context.Context, request *DomainExternalRootEncryptionKeyTestReq, params DomainExternalRootEncryptionKeyTestParams) (DomainExternalRootEncryptionKeyTestRes, error)
	// DomainFlushEncryptionKeys invokes domainFlushEncryptionKeys operation.
	//
	// Flush all keys in memory. The keys will be immediately reloaded from persistent storage, forcing a
	// check that the domain's root encryption key is still available.
	//
	// POST /domains/{domainID}/encryption/flush
	DomainFlushEncryptionKeys(ctx context.Context, request *DomainFlushEncryptionKeysReq, params DomainFlushEncryptionKeysParams) (DomainFlushEncryptionKeysRes, error)
	// DomainGetActiveExternalRootEncryptionKey invokes domainGetActiveExternalRootEncryptionKey operation.
	//
	// Return the details about the current active root encryption key used by the domain.
	//
	// GET /domains/{domainID}/control/keys/active
	DomainGetActiveExternalRootEncryptionKey(ctx context.Context, params DomainGetActiveExternalRootEncryptionKeyParams) (DomainGetActiveExternalRootEncryptionKeyRes, error)
	// DomainGetCapabilities invokes domainGetCapabilities operation.
	//
	// Get the capabilities configured within the domain. A capability is a key/value pair that can be
	// attached to a principal by an identity provider. The capabilities can be referenced by the domain
	// policy rules.
	//
	// GET /domains/{domainID}/control/capabilities
	DomainGetCapabilities(ctx context.Context, params DomainGetCapabilitiesParams) (DomainGetCapabilitiesRes, error)
	// DomainGetCapability invokes domainGetCapability operation.
	//
	// Get a capability. A capability is a key/value pair that can be  attached to a principal by an
	// identity provider. The capabilities can be referenced by the domain policy rules.
	//
	// GET /domains/{domainID}/control/capabilities/{capability}
	DomainGetCapability(ctx context.Context, params DomainGetCapabilityParams) (DomainGetCapabilityRes, error)
	// DomainGetCapsuleInfo invokes domainGetCapsuleInfo operation.
	//
	// Get the summary information about this capsule.
	//
	// GET /domains/{domainID}/capsules/{capsuleID}
	DomainGetCapsuleInfo(ctx context.Context, params DomainGetCapsuleInfoParams) (DomainGetCapsuleInfoRes, error)
	// DomainGetExternalRootEncryptionKeyProviders invokes domainGetExternalRootEncryptionKeyProviders operation.
	//
	// Returns a list of available root encryption key providers, along with their description and, if
	// relevant, any additional information required to use them (e.g. for the delegated key provider
	// `aws_am` the AWS account number to delegate to is returned).
	//
	// GET /domains/{domainID}/control/keys/providers
	DomainGetExternalRootEncryptionKeyProviders(ctx context.Context, params DomainGetExternalRootEncryptionKeyProvidersParams) (DomainGetExternalRootEncryptionKeyProvidersRes, error)
	// DomainGetFactByID invokes domainGetFactByID operation.
	//
	// Returns the fact with the given ID.
	//
	// GET /domains/{domainID}/control/facts/{factType}/{factID}
	DomainGetFactByID(ctx context.Context, params DomainGetFactByIDParams) (DomainGetFactByIDRes, error)
	// DomainGetFactType invokes domainGetFactType operation.
	//
	// Get the definition of the given fact type.
	//
	// GET /domains/{domainID}/control/facts/{factType}
	DomainGetFactType(ctx context.Context, params DomainGetFactTypeParams) (DomainGetFactTypeRes, error)
	// DomainGetIdentityProvider invokes domainGetIdentityProvider operation.
	//
	// Retrieve detailed information and configuration of an identity provider.
	//
	// GET /domains/{domainID}/control/identities/{identityProviderName}
	DomainGetIdentityProvider(ctx context.Context, params DomainGetIdentityProviderParams) (DomainGetIdentityProviderRes, error)
	// DomainGetIdentityProviderPrincipal invokes domainGetIdentityProviderPrincipal operation.
	//
	// Retrieve detailed information about an identity provider principal.
	//
	// GET /domains/{domainID}/control/identities/{identityProviderName}/principals/{principalID}
	DomainGetIdentityProviderPrincipal(ctx context.Context, params DomainGetIdentityProviderPrincipalParams) (DomainGetIdentityProviderPrincipalRes, error)
	// DomainGetIdentityProviderPrincipals invokes domainGetIdentityProviderPrincipals operation.
	//
	// Retrieve a list of principals for an identity provider.
	//
	// GET /domains/{domainID}/control/identities/{identityProviderName}/principals
	DomainGetIdentityProviderPrincipals(ctx context.Context, params DomainGetIdentityProviderPrincipalsParams) (DomainGetIdentityProviderPrincipalsRes, error)
	// DomainGetPeer invokes domainGetPeer operation.
	//
	// Retrieve the details of a domain that is configured as a peer of this domain, by using its alias
	// or one of its nicknames.
	//
	// GET /domains/{domainID}/peer-domain
	DomainGetPeer(ctx context.Context, params DomainGetPeerParams) (DomainGetPeerRes, error)
	// DomainGetPeerConfig invokes domainGetPeerConfig operation.
	//
	// Get the configuration for this peer.
	//
	// GET /domains/{domainID}/control/peers/{peerDomainID}
	DomainGetPeerConfig(ctx context.Context, params DomainGetPeerConfigParams) (DomainGetPeerConfigRes, error)
	// DomainGetPrivateInfo invokes domainGetPrivateInfo operation.
	//
	// Returns a Domain's summary information. This may include more information than the `public-info`
	// endpoint but requires authentication.
	//
	// GET /domains/{domainID}/info
	DomainGetPrivateInfo(ctx context.Context, params DomainGetPrivateInfoParams) (DomainGetPrivateInfoRes, error)
	// DomainGetPublicInfo invokes domainGetPublicInfo operation.
	//
	// Returns a Domain's summary information. This endpoint does not require authorization. This
	// endpoint can be used to determine which identity providers the `/authenticate` endpoint supports.
	//
	// GET /domains/{domainID}/public-info
	DomainGetPublicInfo(ctx context.Context, params DomainGetPublicInfoParams) (DomainGetPublicInfoRes, error)
	// DomainGetReadContext invokes domainGetReadContext operation.
	//
	// Returns information about a read context.
	//
	// GET /domains/{domainID}/control/read-context/{contextName}
	DomainGetReadContext(ctx context.Context, params DomainGetReadContextParams) (DomainGetReadContextRes, error)
	// DomainGetSettings invokes domainGetSettings operation.
	//
	// Get the domain settings. This contains configuration for the contact email addresses as well as
	// the display name for the domain.
	//
	// GET /domains/{domainID}/control/settings
	DomainGetSettings(ctx context.Context, params DomainGetSettingsParams) (DomainGetSettingsRes, error)
	// DomainGetStatus invokes domainGetStatus operation.
	//
	// The domain status object contains important notifications for administrators of the domain.
	//
	// GET /domains/{domainID}/control/status
	DomainGetStatus(ctx context.Context, params DomainGetStatusParams) (DomainGetStatusRes, error)
	// DomainGetTagInfo invokes domainGetTagInfo operation.
	//
	// Get an ordered list of the top 100 tags. The ordering is: - Tags emitted by hooks - Tags
	// referenced in read context rules - Capsule and span tags that appear in the capsule manifest
	// ordered by number of appearances This list will be truncated (and `has_more` will be true) if the
	// above yields more than 100 tags. There is currently no endpoint to receive a complete list of tags.
	//
	// GET /domains/{domainID}/tag-info
	DomainGetTagInfo(ctx context.Context, params DomainGetTagInfoParams) (DomainGetTagInfoRes, error)
	// DomainGetWriteContextRegexRules invokes domainGetWriteContextRegexRules operation.
	//
	// Get a full listing of all regex rules for the context.
	//
	// GET /domains/{domainID}/control/write-context/{contextName}/regex-rule
	DomainGetWriteContextRegexRules(ctx context.Context, params DomainGetWriteContextRegexRulesParams) (DomainGetWriteContextRegexRulesRes, error)
	// DomainInsertIdentityProviderPrincipal invokes domainInsertIdentityProviderPrincipal operation.
	//
	// Create a new principal for the provider. Note that the identityProviderName must refer to an
	// existing identity provider or the response will be a 400.
	//
	// POST /domains/{domainID}/control/identities/{identityProviderName}/principals
	DomainInsertIdentityProviderPrincipal(ctx context.Context, request *DomainIdentityProviderPrincipalParams, params DomainInsertIdentityProviderPrincipalParams) (DomainInsertIdentityProviderPrincipalRes, error)
	// DomainInsertWriteContextRegexRule invokes domainInsertWriteContextRegexRule operation.
	//
	// Create a new regex rule for a write context.
	//
	// POST /domains/{domainID}/control/write-context/{contextName}/regex-rule
	DomainInsertWriteContextRegexRule(ctx context.Context, request *WriteContextRegexRule, params DomainInsertWriteContextRegexRuleParams) (DomainInsertWriteContextRegexRuleRes, error)
	// DomainListCapsules invokes domainListCapsules operation.
	//
	// Get information about capsules.
	//
	// GET /domains/{domainID}/capsules
	DomainListCapsules(ctx context.Context, params DomainListCapsulesParams) (DomainListCapsulesRes, error)
	// DomainListExternalRootEncryptionKey invokes domainListExternalRootEncryptionKey operation.
	//
	// List all external root encryption keys for the domain.
	//
	// GET /domains/{domainID}/control/keys
	DomainListExternalRootEncryptionKey(ctx context.Context, params DomainListExternalRootEncryptionKeyParams) (DomainListExternalRootEncryptionKeyRes, error)
	// DomainListFactTypes invokes domainListFactTypes operation.
	//
	// Get a list of the fact types in this domain. Facts are used by domain policy rules and read
	// context rules.
	//
	// GET /domains/{domainID}/control/facts
	DomainListFactTypes(ctx context.Context, params DomainListFactTypesParams) (DomainListFactTypesRes, error)
	// DomainListFacts invokes domainListFacts operation.
	//
	// Get the facts within a fact type.
	//
	// GET /domains/{domainID}/control/facts/{factType}/list
	DomainListFacts(ctx context.Context, params DomainListFactsParams) (DomainListFactsRes, error)
	// DomainListHooks invokes domainListHooks operation.
	//
	// Get a list of available hooks in this domain. Hooks can be added to write contexts to classify
	// data.
	//
	// GET /domains/{domainID}/hooks
	DomainListHooks(ctx context.Context, params DomainListHooksParams) (DomainListHooksRes, error)
	// DomainListIdentityProviders invokes domainListIdentityProviders operation.
	//
	// Retrieve the domain's identity providers and a brief overview of their configuration. This
	// endpoint requires authentication, but you can obtain an abridged list of the domain identity
	// providers prior to authentication by using the `/public-info` endpoint.
	//
	// GET /domains/{domainID}/control/identities
	DomainListIdentityProviders(ctx context.Context, params DomainListIdentityProvidersParams) (DomainListIdentityProvidersRes, error)
	// DomainListPeers invokes domainListPeers operation.
	//
	// Returns a list of this domains peers.
	//
	// GET /domains/{domainID}/control/peers
	DomainListPeers(ctx context.Context, params DomainListPeersParams) (DomainListPeersRes, error)
	// DomainListPolicyRules invokes domainListPolicyRules operation.
	//
	// Get the domain policy rules. These govern which resources in the domain can be interacted with.
	// Note that the peers "bypass" these rules, in that a peer domain can retrieve policy and
	// configuration that has been allowed by peering configuration without needing an allowing domain
	// policy rule, but they cannot access data within this domain.
	//
	// GET /domains/{domainID}/control/policy
	DomainListPolicyRules(ctx context.Context, params DomainListPolicyRulesParams) (DomainListPolicyRulesRes, error)
	// DomainListReadContexts invokes domainListReadContexts operation.
	//
	// List the domain read contexts. If a user has view permissions on this resource, they may list all
	// read contexts, even if they do not have view, edit or use permissions on some of the read contexts
	// in the list.
	//
	// GET /domains/{domainID}/control/read-context
	DomainListReadContexts(ctx context.Context, params DomainListReadContextsParams) (DomainListReadContextsRes, error)
	// DomainListResources invokes domainListResources operation.
	//
	// Gets a list of resource strings that can be used in policy rules, and the set of permissions that
	// you can assign to them. The return value from this endpoint is useful as a reference when
	// authoring custom domain policy for new capabilities.
	//
	// GET /domains/{domainID}/control/resources
	DomainListResources(ctx context.Context, params DomainListResourcesParams) (DomainListResourcesRes, error)
	// DomainListWriteContexts invokes domainListWriteContexts operation.
	//
	// List the domain write contexts. If a user has view permissions on this resource, they may list all
	// write contexts, even if they do not have view, edit or use permissions on some of the write
	// contexts in the list.
	//
	// GET /domains/{domainID}/control/write-context
	DomainListWriteContexts(ctx context.Context, params DomainListWriteContextsParams) (DomainListWriteContextsRes, error)
	// DomainOpenCapsule invokes domainOpenCapsule operation.
	//
	// Given the encrypted DEK for this capsule, get back the decrypted DEK. contains the read context.
	//
	// POST /domains/{domainID}/capsules/{capsuleID}/open
	DomainOpenCapsule(ctx context.Context, request *CapsuleOpenRequest, params DomainOpenCapsuleParams) (DomainOpenCapsuleRes, error)
	// DomainPatchSettings invokes domainPatchSettings operation.
	//
	// Applies the given patch to the domain settings.
	//
	// PATCH /domains/{domainID}/control/settings
	DomainPatchSettings(ctx context.Context, request *DomainSettingsPatch, params DomainPatchSettingsParams) (DomainPatchSettingsRes, error)
	// DomainPolicyFlush invokes domainPolicyFlush operation.
	//
	// Flush the policy cache so that changes to permissions take effect.
	//
	// POST /domains/{domainID}/control/policy/flush
	DomainPolicyFlush(ctx context.Context, params DomainPolicyFlushParams) (DomainPolicyFlushRes, error)
	// DomainPutCapability invokes domainPutCapability operation.
	//
	// Create or update a capability. If you want to return an error if the capability already existed,
	// set `createonly` to true.
	//
	// PUT /domains/{domainID}/control/capabilities/{capability}
	DomainPutCapability(ctx context.Context, request *NewCapabilityDefinition, params DomainPutCapabilityParams) (DomainPutCapabilityRes, error)
	// DomainPutFactType invokes domainPutFactType operation.
	//
	// Facts are used to store ancillary information that helps express domain policy rules and read
	// context configuration rules. This endpoint allows you to register a new fact type. To create a
	// fact within an existing type, use `/control/facts/{factType}/new`.
	//
	// PUT /domains/{domainID}/control/facts/{factType}
	DomainPutFactType(ctx context.Context, request *NewFactTypeDefinition, params DomainPutFactTypeParams) (DomainPutFactTypeRes, error)
	// DomainQueryAccessLog invokes domainQueryAccessLog operation.
	//
	// Query the data access log for this domain. This contains all operations interacting with capsules
	// within this domain. Results are returned in reverse chronological order.
	//
	// GET /domains/{domainID}/log
	DomainQueryAccessLog(ctx context.Context, params DomainQueryAccessLogParams) (DomainQueryAccessLogRes, error)
	// DomainQueryAccessLogSingleCapsule invokes domainQueryAccessLogSingleCapsule operation.
	//
	// Query the data-plane access log for this capsule. Results are returned in reverse chronological
	// order.
	//
	// GET /domains/{domainID}/capsules/{capsuleID}/log
	DomainQueryAccessLogSingleCapsule(ctx context.Context, params DomainQueryAccessLogSingleCapsuleParams) (DomainQueryAccessLogSingleCapsuleRes, error)
	// DomainQueryControlLog invokes domainQueryControlLog operation.
	//
	// Query the domain control-plane audit log. Results are returned in reverse chronological order.
	//
	// GET /domains/{domainID}/control/log
	DomainQueryControlLog(ctx context.Context, params DomainQueryControlLogParams) (DomainQueryControlLogRes, error)
	// DomainReadContextFlush invokes domainReadContextFlush operation.
	//
	// Flush the read context cache so that changes to permissions take effect.
	//
	// POST /domains/{domainID}/control/read-context/{contextName}/flush
	DomainReadContextFlush(ctx context.Context, params DomainReadContextFlushParams) (DomainReadContextFlushRes, error)
	// DomainRenumberPolicyRules invokes domainRenumberPolicyRules operation.
	//
	// Re-assign rule priority numbers to integer multiples of 10.
	//
	// POST /domains/{domainID}/control/policy/renumber
	DomainRenumberPolicyRules(ctx context.Context, params DomainRenumberPolicyRulesParams) (DomainRenumberPolicyRulesRes, error)
	// DomainRotateRootEncryptionKeys invokes domainRotateRootEncryptionKeys operation.
	//
	// Collects key encryption keys not encrypted with the current active root encryption key, decrypts
	// them with their original root encryption key, and then encrypts them with the active root
	// encryption key. This is a batched operation and only 100 keys will be processed in a single call.
	// In the response, "has_more" will be true if there are more KEKs that can be rotated. Usually the
	// caller will call this endpoint in a loop until has_more is false.
	//
	// POST /domains/{domainID}/control/keys/rotate
	DomainRotateRootEncryptionKeys(ctx context.Context, request *DomainRotateRootEncryptionKeysReq, params DomainRotateRootEncryptionKeysParams) (DomainRotateRootEncryptionKeysRes, error)
	// DomainSealCapsule invokes domainSealCapsule operation.
	//
	// Seal this capsule, if it's unsealed. Requires capsule create token.
	//
	// POST /domains/{domainID}/capsules/{capsuleID}/seal
	DomainSealCapsule(ctx context.Context, request *CapsuleSealRequest, params DomainSealCapsuleParams) (DomainSealCapsuleRes, error)
	// DomainSetActiveExternalRootEncryptionKey invokes domainSetActiveExternalRootEncryptionKey operation.
	//
	// This will set which root encryption is active: i.e. is used for new capsules, or is used to
	// encrypt KEKs when `/keys/rotate` is called or when new capsules are created.
	//
	// POST /domains/{domainID}/control/keys/active
	DomainSetActiveExternalRootEncryptionKey(ctx context.Context, request *ActiveRootEncryptionKeyID, params DomainSetActiveExternalRootEncryptionKeyParams) (DomainSetActiveExternalRootEncryptionKeyRes, error)
	// DomainUpdateIdentityProviderPrincipal invokes domainUpdateIdentityProviderPrincipal operation.
	//
	// Update the set of capabilities assigned to an identity provider principal. The capabilities must
	// exist.
	//
	// PUT /domains/{domainID}/control/identities/{identityProviderName}/principals/{principalID}
	DomainUpdateIdentityProviderPrincipal(ctx context.Context, request *CapabilityList, params DomainUpdateIdentityProviderPrincipalParams) (DomainUpdateIdentityProviderPrincipalRes, error)
	// DomainUpdatePeer invokes domainUpdatePeer operation.
	//
	// Create or update the configuration for this peer. Please note, if the configuration already exists,
	//  it is updated to reflect the values in the request. This will include setting the fields to their
	// default value if not supplied.
	//
	// PUT /domains/{domainID}/control/peers/{peerDomainID}
	DomainUpdatePeer(ctx context.Context, request *DomainPeerConfig, params DomainUpdatePeerParams) (DomainUpdatePeerRes, error)
	// DomainUpdatePolicyRule invokes domainUpdatePolicyRule operation.
	//
	// Update a domain policy rule.
	//
	// PUT /domains/{domainID}/control/policy/{ruleID}
	DomainUpdatePolicyRule(ctx context.Context, request *NewDomainPolicyRule, params DomainUpdatePolicyRuleParams) (DomainUpdatePolicyRuleRes, error)
	// DomainUpdateReadContextRule invokes domainUpdateReadContextRule operation.
	//
	// Update a read context configuration rule. The rule must already exist.
	//
	// PUT /domains/{domainID}/control/read-context/{contextName}/config/{ruleID}
	DomainUpdateReadContextRule(ctx context.Context, request *NewReadContextConfigRule, params DomainUpdateReadContextRuleParams) (DomainUpdateReadContextRuleRes, error)
	// DomainUpsertCapsuleTags invokes domainUpsertCapsuleTags operation.
	//
	// Upsert capsule-level tags. This is permitted even after a capsule is sealed.
	//
	// POST /domains/{domainID}/capsules/{capsuleID}/capsule-tags
	DomainUpsertCapsuleTags(ctx context.Context, request []Tag, params DomainUpsertCapsuleTagsParams) (DomainUpsertCapsuleTagsRes, error)
	// DomainUpsertFact invokes domainUpsertFact operation.
	//
	// Create a new fact. The fact type must have been previously registered using
	// `/control/facts/{factType}`. If an identical fact exists (having the same value for all fields),
	// this call is a no-op and returns the same ID.
	//
	// POST /domains/{domainID}/control/facts/{factType}/new
	DomainUpsertFact(ctx context.Context, request *NewFact, params DomainUpsertFactParams) (DomainUpsertFactRes, error)
	// DomainUpsertIdentityProvider invokes domainUpsertIdentityProvider operation.
	//
	// Create or configure an identity provider.
	//
	// PUT /domains/{domainID}/control/identities/{identityProviderName}
	DomainUpsertIdentityProvider(ctx context.Context, request DomainIdentityProviderDetails, params DomainUpsertIdentityProviderParams) (DomainUpsertIdentityProviderRes, error)
	// DomainUpsertReadContext invokes domainUpsertReadContext operation.
	//
	// Update or create a read context.
	//
	// PUT /domains/{domainID}/control/read-context/{contextName}
	DomainUpsertReadContext(ctx context.Context, request *AddReadContext, params DomainUpsertReadContextParams) (DomainUpsertReadContextRes, error)
	// DomainUpsertSpanTags invokes domainUpsertSpanTags operation.
	//
	// Upsert span tag rollups. This is only permitted when a capsule is not sealed. It requires a
	// special "capsule owner" token that is returned by create capsule. Note that the rollup
	// calculations must be done on the client side. This method only permits storing the entire rollup,
	// not aggregating serverside. This is idempotent.
	//
	// PUT /domains/{domainID}/capsules/{capsuleID}/span-tags
	DomainUpsertSpanTags(ctx context.Context, request *UpsertSpanTagsRequest, params DomainUpsertSpanTagsParams) (DomainUpsertSpanTagsRes, error)
	// DomainUpsertWriteContext invokes domainUpsertWriteContext operation.
	//
	// Create or update an existing write context. If the config is omitted, it will be left as-is
	// (existing write contexts) or created as blank (new write contexts).
	//
	// PUT /domains/{domainID}/control/write-context/{contextName}
	DomainUpsertWriteContext(ctx context.Context, request *AddWriteContext, params DomainUpsertWriteContextParams) (DomainUpsertWriteContextRes, error)
	// DomainUpsertWriteContextConfiguration invokes domainUpsertWriteContextConfiguration operation.
	//
	// Update a write context configuration. The write context must already exist.
	//
	// PUT /domains/{domainID}/control/write-context/{contextName}/config
	DomainUpsertWriteContextConfiguration(ctx context.Context, request *WriteContextConfigInfo, params DomainUpsertWriteContextConfigurationParams) (DomainUpsertWriteContextConfigurationRes, error)
	// StarredDomainAdd invokes starredDomainAdd operation.
	//
	// Adds the domain to the list of starred domains for the user.
	//
	// PUT /global/starred-domains/{domainID}
	StarredDomainAdd(ctx context.Context, request *StarredDomainAddReq, params StarredDomainAddParams) (StarredDomainAddRes, error)
	// StarredDomainList invokes starredDomainList operation.
	//
	// Returns a list of domains that the user has starred. This is a list of domain IDs, not domain
	// names. The user must be authenticated to call this method.
	//
	// GET /global/starred-domains
	StarredDomainList(ctx context.Context) (StarredDomainListRes, error)
	// StarredDomainRemove invokes starredDomainRemove operation.
	//
	// Removes the domain from the list of starred domains for the user.
	//
	// DELETE /global/starred-domains/{domainID}
	StarredDomainRemove(ctx context.Context, params StarredDomainRemoveParams) (StarredDomainRemoveRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}
type errorHandler interface {
	NewError(ctx context.Context, err error) *ErrorStatusCode
}

var _ Handler = struct {
	errorHandler
	*Client
}{}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// CapsuleGetById invokes capsuleGetById operation.
//
// This endpoint allows you to get a Capsule without knowing the Domain ID. It will redirect the user
// to the full `/domains/{domainID}/capsules/{capsuleID}` path.
//
// GET /capsules/{capsuleID}
func (c *Client) CapsuleGetById(ctx context.Context, params CapsuleGetByIdParams) (CapsuleGetByIdRes, error) {
	res, err := c.sendCapsuleGetById(ctx, params)
	return res, err
}

func (c *Client) sendCapsuleGetById(ctx context.Context, params CapsuleGetByIdParams) (res CapsuleGetByIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("capsuleGetById"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/capsules/{capsuleID}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CapsuleGetById",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/capsules/"
	{
		// Encode "capsuleID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "capsuleID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.CapsuleID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCapsuleGetByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainAddAccessLogEntry invokes domainAddAccessLogEntry operation.
//
// Adds a data-plane audit log entry for this capsule. Contains information about the originating
// principal and about read tag rollups. Contains an open capsule token (read from the file) to
// ensure that you legitimately read the capsule. Note that not all audit log entry types may be
// added with this method. Some (like open records) are generated server side.
//
// POST /domains/{domainID}/capsules/{capsuleID}/log
func (c *Client) DomainAddAccessLogEntry(ctx context.Context, request *AddCapsuleLogEntryRequest, params DomainAddAccessLogEntryParams) (DomainAddAccessLogEntryRes, error) {
	res, err := c.sendDomainAddAccessLogEntry(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainAddAccessLogEntry(ctx context.Context, request *AddCapsuleLogEntryRequest, params DomainAddAccessLogEntryParams) (res DomainAddAccessLogEntryRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainAddAccessLogEntry"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/capsules/{capsuleID}/log"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainAddAccessLogEntry",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/capsules/"
	{
		// Encode "capsuleID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "capsuleID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.CapsuleID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/log"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainAddAccessLogEntryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainAddAccessLogEntry", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainAddAccessLogEntryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainAddExternalRootEncryptionKey invokes domainAddExternalRootEncryptionKey operation.
//
// Add a new external root encryption key with its supporting access configuration.
//
// POST /domains/{domainID}/control/keys
func (c *Client) DomainAddExternalRootEncryptionKey(ctx context.Context, request *KeyInfos, params DomainAddExternalRootEncryptionKeyParams) (DomainAddExternalRootEncryptionKeyRes, error) {
	res, err := c.sendDomainAddExternalRootEncryptionKey(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainAddExternalRootEncryptionKey(ctx context.Context, request *KeyInfos, params DomainAddExternalRootEncryptionKeyParams) (res DomainAddExternalRootEncryptionKeyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainAddExternalRootEncryptionKey"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/keys"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainAddExternalRootEncryptionKey",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/keys"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainAddExternalRootEncryptionKeyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainAddExternalRootEncryptionKey", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainAddExternalRootEncryptionKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainAddNew invokes domainAddNew operation.
//
// Add a new domain with no default peer relationships. You will need to confirm the email address
// before the domain is able to be interacted with.
//
// POST /domains
func (c *Client) DomainAddNew(ctx context.Context, request *NewDomain) (DomainAddNewRes, error) {
	res, err := c.sendDomainAddNew(ctx, request)
	return res, err
}

func (c *Client) sendDomainAddNew(ctx context.Context, request *NewDomain) (res DomainAddNewRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainAddNew"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/domains"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainAddNew",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/domains"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainAddNewRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainAddNewResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainAddReadContextRule invokes domainAddReadContextRule operation.
//
// Read context configuration is rule based, much like domain policy. This adds a new rule to the
// read context. Rules are processed in priority order, stopping with the first matching rule.
//
// POST /domains/{domainID}/control/read-context/{contextName}/config
func (c *Client) DomainAddReadContextRule(ctx context.Context, request *NewReadContextConfigRule, params DomainAddReadContextRuleParams) (DomainAddReadContextRuleRes, error) {
	res, err := c.sendDomainAddReadContextRule(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainAddReadContextRule(ctx context.Context, request *NewReadContextConfigRule, params DomainAddReadContextRuleParams) (res DomainAddReadContextRuleRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainAddReadContextRule"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/read-context/{contextName}/config"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainAddReadContextRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/read-context/"
	{
		// Encode "contextName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "contextName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ContextName); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/config"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainAddReadContextRuleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainAddReadContextRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainAddReadContextRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainAuthenticate invokes domainAuthenticate operation.
//
// Use an authentication method to obtain a domain ID token which is used as the bearer for all other
// endpoints. You can use the `/public-info` route to obtain a list of identity providers supported
// by this endpoint.
//
// POST /domains/{domainID}/authenticate
func (c *Client) DomainAuthenticate(ctx context.Context, request *DomainAuthenticate, params DomainAuthenticateParams) (DomainAuthenticateRes, error) {
	res, err := c.sendDomainAuthenticate(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainAuthenticate(ctx context.Context, request *DomainAuthenticate, params DomainAuthenticateParams) (res DomainAuthenticateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainAuthenticate"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/authenticate"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainAuthenticate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/authenticate"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "identityProviderName" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "identityProviderName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IdentityProviderName.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tokenExchange" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tokenExchange",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TokenExchange.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainAuthenticateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainAuthenticateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainContactIssueVerify invokes domainContactIssueVerify operation.
//
// Issue a new verification request to a pending contact email associated with the domain. There is a
// rate limiter on this endpoint, you may need to wait between invocations.
//
// POST /domains/{domainID}/account/verify
func (c *Client) DomainContactIssueVerify(ctx context.Context, request *DomainContactIssueVerifyReq, params DomainContactIssueVerifyParams) (DomainContactIssueVerifyRes, error) {
	res, err := c.sendDomainContactIssueVerify(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainContactIssueVerify(ctx context.Context, request *DomainContactIssueVerifyReq, params DomainContactIssueVerifyParams) (res DomainContactIssueVerifyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainContactIssueVerify"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/account/verify"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainContactIssueVerify",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/account/verify"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainContactIssueVerifyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainContactIssueVerifyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainContactVerify invokes domainContactVerify operation.
//
// Verify an admin contact email recently associated with a domain. The token will have been emailed
// (in the form of a link) to the email address when `/account/verify` is called, the domain was
// initially created, or the email was added via the settings endpoint.
//
// GET /domains/{domainID}/account/verify
func (c *Client) DomainContactVerify(ctx context.Context, params DomainContactVerifyParams) (DomainContactVerifyRes, error) {
	res, err := c.sendDomainContactVerify(ctx, params)
	return res, err
}

func (c *Client) sendDomainContactVerify(ctx context.Context, params DomainContactVerifyParams) (res DomainContactVerifyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainContactVerify"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/account/verify"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainContactVerify",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/account/verify"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Token.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "googleJWT" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "googleJWT",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.GoogleJWT.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "address" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "address",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Address))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainContactVerifyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainCreateCapsule invokes domainCreateCapsule operation.
//
// Create a new capsule. The ID will be returned. Capsule will be "unsealed" first, meaning it's
// still in a creating state. Returns a capsule create token that can be used to feed in additional
// data about the capsule while it's still unsealed. Also returns a DEK and an encrypted DEK.
//
// POST /domains/{domainID}/capsules
func (c *Client) DomainCreateCapsule(ctx context.Context, request *DomainCreateCapsuleReq, params DomainCreateCapsuleParams) (DomainCreateCapsuleRes, error) {
	res, err := c.sendDomainCreateCapsule(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainCreateCapsule(ctx context.Context, request *DomainCreateCapsuleReq, params DomainCreateCapsuleParams) (res DomainCreateCapsuleRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainCreateCapsule"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/capsules"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainCreateCapsule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/capsules"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "writeContext" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "writeContext",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if unwrapped := string(params.WriteContext); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainCreateCapsuleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainCreateCapsule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainCreateCapsuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainCreatePeerDomain invokes domainCreatePeerDomain operation.
//
// Create a domain with a default "subordinate" peering relationship with the current domain.
// Namely, the current "parent" domain will be configured to allow the new "child" domain to use the
// parent's billing and admin contact settings, and the child domain will be configured to import
// those settings.
// Optionally, similar linking can be performed for identity providers, read/write contexts and facts
// by setting the appropriate linkX parameter to true. In most cases, what you want is to set
// `linkAll=true`.
// Note, that a "subdomain" is just shorthand for a domain with the above-described peering config.
// This peering can be changed at any time, and there is no permanent difference between a domain
// created in this way, and a domain created with POST /domains.
//
// POST /domains/{domainID}/peer-domain
func (c *Client) DomainCreatePeerDomain(ctx context.Context, request *CreatePeerDomain, params DomainCreatePeerDomainParams) (DomainCreatePeerDomainRes, error) {
	res, err := c.sendDomainCreatePeerDomain(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainCreatePeerDomain(ctx context.Context, request *CreatePeerDomain, params DomainCreatePeerDomainParams) (res DomainCreatePeerDomainRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainCreatePeerDomain"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/peer-domain"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainCreatePeerDomain",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/peer-domain"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainCreatePeerDomainRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainCreatePeerDomain", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainCreatePeerDomainResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainCreatePolicyRule invokes domainCreatePolicyRule operation.
//
// Create a domain policy rule.
//
// POST /domains/{domainID}/control/policy
func (c *Client) DomainCreatePolicyRule(ctx context.Context, request *NewDomainPolicyRule, params DomainCreatePolicyRuleParams) (DomainCreatePolicyRuleRes, error) {
	res, err := c.sendDomainCreatePolicyRule(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainCreatePolicyRule(ctx context.Context, request *NewDomainPolicyRule, params DomainCreatePolicyRuleParams) (res DomainCreatePolicyRuleRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainCreatePolicyRule"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/policy"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainCreatePolicyRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/policy"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainCreatePolicyRuleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainCreatePolicyRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainCreatePolicyRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainDataTaggingHookInvoke invokes domainDataTaggingHookInvoke operation.
//
// Invoke a hook that operates on data and returns tags.
//
// POST /domains/{domainID}/hooks/data-tagging/{hookName}/invoke
func (c *Client) DomainDataTaggingHookInvoke(ctx context.Context, request *DataTaggingHookInput, params DomainDataTaggingHookInvokeParams) (DomainDataTaggingHookInvokeRes, error) {
	res, err := c.sendDomainDataTaggingHookInvoke(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainDataTaggingHookInvoke(ctx context.Context, request *DataTaggingHookInput, params DomainDataTaggingHookInvokeParams) (res DomainDataTaggingHookInvokeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainDataTaggingHookInvoke"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/hooks/data-tagging/{hookName}/invoke"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainDataTaggingHookInvoke",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/hooks/data-tagging/"
	{
		// Encode "hookName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hookName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.HookName); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/invoke"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "writeContext" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "writeContext",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WriteContext.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainDataTaggingHookInvokeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainDataTaggingHookInvoke", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainDataTaggingHookInvokeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainDeleteCapability invokes domainDeleteCapability operation.
//
// Delete a capability. All domain policy rules that reference the capability must have already been
// deleted, or you will receive a 409 error.
//
// DELETE /domains/{domainID}/control/capabilities/{capability}
func (c *Client) DomainDeleteCapability(ctx context.Context, params DomainDeleteCapabilityParams) (DomainDeleteCapabilityRes, error) {
	res, err := c.sendDomainDeleteCapability(ctx, params)
	return res, err
}

func (c *Client) sendDomainDeleteCapability(ctx context.Context, params DomainDeleteCapabilityParams) (res DomainDeleteCapabilityRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainDeleteCapability"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/capabilities/{capability}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainDeleteCapability",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/capabilities/"
	{
		// Encode "capability" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "capability",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.Capability); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainDeleteCapability", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainDeleteCapabilityResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainDeleteCapsuleTags invokes domainDeleteCapsuleTags operation.
//
// Delete capsule-level tags.
//
// POST /domains/{domainID}/capsules/{capsuleID}/capsule-tags/delete
func (c *Client) DomainDeleteCapsuleTags(ctx context.Context, request *DeleteTags, params DomainDeleteCapsuleTagsParams) (DomainDeleteCapsuleTagsRes, error) {
	res, err := c.sendDomainDeleteCapsuleTags(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainDeleteCapsuleTags(ctx context.Context, request *DeleteTags, params DomainDeleteCapsuleTagsParams) (res DomainDeleteCapsuleTagsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainDeleteCapsuleTags"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/capsules/{capsuleID}/capsule-tags/delete"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainDeleteCapsuleTags",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/capsules/"
	{
		// Encode "capsuleID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "capsuleID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.CapsuleID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/capsule-tags/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainDeleteCapsuleTagsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainDeleteCapsuleTags", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainDeleteCapsuleTagsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainDeleteExternalRootEncryptionKey invokes domainDeleteExternalRootEncryptionKey operation.
//
// Delete an external root encryption key using its ID. This operation is only successful if the
// external root encryption key is not in use by any key encryption keys. Call the /keys/rotate
// endpoint to ensure that all KEKs have been migrated to the active REK.
//
// DELETE /domains/{domainID}/control/keys/{rootEncryptionKeyID}
func (c *Client) DomainDeleteExternalRootEncryptionKey(ctx context.Context, params DomainDeleteExternalRootEncryptionKeyParams) (DomainDeleteExternalRootEncryptionKeyRes, error) {
	res, err := c.sendDomainDeleteExternalRootEncryptionKey(ctx, params)
	return res, err
}

func (c *Client) sendDomainDeleteExternalRootEncryptionKey(ctx context.Context, params DomainDeleteExternalRootEncryptionKeyParams) (res DomainDeleteExternalRootEncryptionKeyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainDeleteExternalRootEncryptionKey"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/keys/{rootEncryptionKeyID}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainDeleteExternalRootEncryptionKey",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/keys/"
	{
		// Encode "rootEncryptionKeyID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "rootEncryptionKeyID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.RootEncryptionKeyID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainDeleteExternalRootEncryptionKey", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainDeleteExternalRootEncryptionKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainDeleteFactByID invokes domainDeleteFactByID operation.
//
// Delete a fact by ID.
//
// DELETE /domains/{domainID}/control/facts/{factType}/{factID}
func (c *Client) DomainDeleteFactByID(ctx context.Context, params DomainDeleteFactByIDParams) (DomainDeleteFactByIDRes, error) {
	res, err := c.sendDomainDeleteFactByID(ctx, params)
	return res, err
}

func (c *Client) sendDomainDeleteFactByID(ctx context.Context, params DomainDeleteFactByIDParams) (res DomainDeleteFactByIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainDeleteFactByID"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/facts/{factType}/{factID}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainDeleteFactByID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/facts/"
	{
		// Encode "factType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "factType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.FactType); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "factID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "factID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.FactID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainDeleteFactByID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainDeleteFactByIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainDeleteFactType invokes domainDeleteFactType operation.
//
// Deletes a fact type and all facts inside it.
//
// DELETE /domains/{domainID}/control/facts/{factType}
func (c *Client) DomainDeleteFactType(ctx context.Context, params DomainDeleteFactTypeParams) (DomainDeleteFactTypeRes, error) {
	res, err := c.sendDomainDeleteFactType(ctx, params)
	return res, err
}

func (c *Client) sendDomainDeleteFactType(ctx context.Context, params DomainDeleteFactTypeParams) (res DomainDeleteFactTypeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainDeleteFactType"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/facts/{factType}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainDeleteFactType",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/facts/"
	{
		// Encode "factType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "factType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.FactType); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "confirm" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "confirm",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if unwrapped := string(params.Confirm); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainDeleteFactType", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainDeleteFactTypeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainDeleteIdentityProvider invokes domainDeleteIdentityProvider operation.
//
// Delete an identity provider. All domain tokens created using this identity provider will be
// invalidated. Take care not to remove the identity provider that is providing you admin access to
// your domain, as you may "lock yourself out".
//
// DELETE /domains/{domainID}/control/identities/{identityProviderName}
func (c *Client) DomainDeleteIdentityProvider(ctx context.Context, params DomainDeleteIdentityProviderParams) (DomainDeleteIdentityProviderRes, error) {
	res, err := c.sendDomainDeleteIdentityProvider(ctx, params)
	return res, err
}

func (c *Client) sendDomainDeleteIdentityProvider(ctx context.Context, params DomainDeleteIdentityProviderParams) (res DomainDeleteIdentityProviderRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainDeleteIdentityProvider"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/identities/{identityProviderName}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainDeleteIdentityProvider",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/identities/"
	{
		// Encode "identityProviderName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "identityProviderName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.IdentityProviderName); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainDeleteIdentityProvider", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainDeleteIdentityProviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainDeleteIdentityProviderPrincipal invokes domainDeleteIdentityProviderPrincipal operation.
//
// Delete an identity provider principal.
//
// DELETE /domains/{domainID}/control/identities/{identityProviderName}/principals/{principalID}
func (c *Client) DomainDeleteIdentityProviderPrincipal(ctx context.Context, params DomainDeleteIdentityProviderPrincipalParams) (DomainDeleteIdentityProviderPrincipalRes, error) {
	res, err := c.sendDomainDeleteIdentityProviderPrincipal(ctx, params)
	return res, err
}

func (c *Client) sendDomainDeleteIdentityProviderPrincipal(ctx context.Context, params DomainDeleteIdentityProviderPrincipalParams) (res DomainDeleteIdentityProviderPrincipalRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainDeleteIdentityProviderPrincipal"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/identities/{identityProviderName}/principals/{principalID}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainDeleteIdentityProviderPrincipal",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/identities/"
	{
		// Encode "identityProviderName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "identityProviderName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.IdentityProviderName); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/principals/"
	{
		// Encode "principalID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "principalID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.PrincipalID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainDeleteIdentityProviderPrincipal", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainDeleteIdentityProviderPrincipalResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainDeletePeer invokes domainDeletePeer operation.
//
// Removes the peering relationship with the given domain.
//
// DELETE /domains/{domainID}/control/peers/{peerDomainID}
func (c *Client) DomainDeletePeer(ctx context.Context, params DomainDeletePeerParams) (DomainDeletePeerRes, error) {
	res, err := c.sendDomainDeletePeer(ctx, params)
	return res, err
}

func (c *Client) sendDomainDeletePeer(ctx context.Context, params DomainDeletePeerParams) (res DomainDeletePeerRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainDeletePeer"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/peers/{peerDomainID}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainDeletePeer",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/peers/"
	{
		// Encode "peerDomainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "peerDomainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.PeerDomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainDeletePeer", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainDeletePeerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainDeletePolicyRule invokes domainDeletePolicyRule operation.
//
// Delete a domain policy rule by ID.
//
// DELETE /domains/{domainID}/control/policy/{ruleID}
func (c *Client) DomainDeletePolicyRule(ctx context.Context, params DomainDeletePolicyRuleParams) (DomainDeletePolicyRuleRes, error) {
	res, err := c.sendDomainDeletePolicyRule(ctx, params)
	return res, err
}

func (c *Client) sendDomainDeletePolicyRule(ctx context.Context, params DomainDeletePolicyRuleParams) (res DomainDeletePolicyRuleRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainDeletePolicyRule"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/policy/{ruleID}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainDeletePolicyRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/policy/"
	{
		// Encode "ruleID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ruleID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.RuleID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainDeletePolicyRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainDeletePolicyRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainDeleteReadContext invokes domainDeleteReadContext operation.
//
// Delete a read context. All configuration associated with this read context will also be deleted.
// Domain policy rules referencing this read context will be left as-is.
//
// DELETE /domains/{domainID}/control/read-context/{contextName}
func (c *Client) DomainDeleteReadContext(ctx context.Context, params DomainDeleteReadContextParams) (DomainDeleteReadContextRes, error) {
	res, err := c.sendDomainDeleteReadContext(ctx, params)
	return res, err
}

func (c *Client) sendDomainDeleteReadContext(ctx context.Context, params DomainDeleteReadContextParams) (res DomainDeleteReadContextRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainDeleteReadContext"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/read-context/{contextName}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainDeleteReadContext",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/read-context/"
	{
		// Encode "contextName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "contextName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ContextName); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainDeleteReadContext", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainDeleteReadContextResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainDeleteReadContextRule invokes domainDeleteReadContextRule operation.
//
// Deletes a read context configuration rule by ID.
//
// DELETE /domains/{domainID}/control/read-context/{contextName}/config/{ruleID}
func (c *Client) DomainDeleteReadContextRule(ctx context.Context, params DomainDeleteReadContextRuleParams) (DomainDeleteReadContextRuleRes, error) {
	res, err := c.sendDomainDeleteReadContextRule(ctx, params)
	return res, err
}

func (c *Client) sendDomainDeleteReadContextRule(ctx context.Context, params DomainDeleteReadContextRuleParams) (res DomainDeleteReadContextRuleRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainDeleteReadContextRule"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/read-context/{contextName}/config/{ruleID}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainDeleteReadContextRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/read-context/"
	{
		// Encode "contextName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "contextName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ContextName); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/config/"
	{
		// Encode "ruleID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ruleID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.RuleID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainDeleteReadContextRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainDeleteReadContextRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainDeleteWriteContext invokes domainDeleteWriteContext operation.
//
// Delete a write context. All configuration associated with this write context will also be deleted.
// Domain policy rules referencing this write context will be left as-is.
//
// DELETE /domains/{domainID}/control/write-context/{contextName}
func (c *Client) DomainDeleteWriteContext(ctx context.Context, params DomainDeleteWriteContextParams) (DomainDeleteWriteContextRes, error) {
	res, err := c.sendDomainDeleteWriteContext(ctx, params)
	return res, err
}

func (c *Client) sendDomainDeleteWriteContext(ctx context.Context, params DomainDeleteWriteContextParams) (res DomainDeleteWriteContextRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainDeleteWriteContext"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/write-context/{contextName}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainDeleteWriteContext",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/write-context/"
	{
		// Encode "contextName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "contextName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ContextName); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainDeleteWriteContext", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainDeleteWriteContextResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainDeleteWriteContextRegexRule invokes domainDeleteWriteContextRegexRule operation.
//
// Delete a regex classifier rule for the context.
//
// DELETE /domains/{domainID}/control/write-context/{contextName}/regex-rule/{ruleID}
func (c *Client) DomainDeleteWriteContextRegexRule(ctx context.Context, params DomainDeleteWriteContextRegexRuleParams) (DomainDeleteWriteContextRegexRuleRes, error) {
	res, err := c.sendDomainDeleteWriteContextRegexRule(ctx, params)
	return res, err
}

func (c *Client) sendDomainDeleteWriteContextRegexRule(ctx context.Context, params DomainDeleteWriteContextRegexRuleParams) (res DomainDeleteWriteContextRegexRuleRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainDeleteWriteContextRegexRule"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/write-context/{contextName}/regex-rule/{ruleID}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainDeleteWriteContextRegexRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/write-context/"
	{
		// Encode "contextName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "contextName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ContextName); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/regex-rule/"
	{
		// Encode "ruleID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ruleID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.RuleID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainDeleteWriteContextRegexRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainDeleteWriteContextRegexRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainDescribeWriteContext invokes domainDescribeWriteContext operation.
//
// Returns a detailed description of a write context.
//
// GET /domains/{domainID}/control/write-context/{contextName}
func (c *Client) DomainDescribeWriteContext(ctx context.Context, params DomainDescribeWriteContextParams) (DomainDescribeWriteContextRes, error) {
	res, err := c.sendDomainDescribeWriteContext(ctx, params)
	return res, err
}

func (c *Client) sendDomainDescribeWriteContext(ctx context.Context, params DomainDescribeWriteContextParams) (res DomainDescribeWriteContextRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainDescribeWriteContext"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/write-context/{contextName}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainDescribeWriteContext",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/write-context/"
	{
		// Encode "contextName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "contextName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ContextName); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainDescribeWriteContext", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainDescribeWriteContextResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainExternalRootEncryptionKeyTest invokes domainExternalRootEncryptionKeyTest operation.
//
// Attempts to use a root encryption key to encrypt and decrypt, validating its availability.
//
// POST /domains/{domainID}/control/keys/{rootEncryptionKeyID}/test
func (c *Client) DomainExternalRootEncryptionKeyTest(ctx context.Context, request *DomainExternalRootEncryptionKeyTestReq, params DomainExternalRootEncryptionKeyTestParams) (DomainExternalRootEncryptionKeyTestRes, error) {
	res, err := c.sendDomainExternalRootEncryptionKeyTest(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainExternalRootEncryptionKeyTest(ctx context.Context, request *DomainExternalRootEncryptionKeyTestReq, params DomainExternalRootEncryptionKeyTestParams) (res DomainExternalRootEncryptionKeyTestRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainExternalRootEncryptionKeyTest"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/keys/{rootEncryptionKeyID}/test"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainExternalRootEncryptionKeyTest",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/keys/"
	{
		// Encode "rootEncryptionKeyID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "rootEncryptionKeyID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.RootEncryptionKeyID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/test"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainExternalRootEncryptionKeyTestRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainExternalRootEncryptionKeyTest", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainExternalRootEncryptionKeyTestResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainFlushEncryptionKeys invokes domainFlushEncryptionKeys operation.
//
// Flush all keys in memory. The keys will be immediately reloaded from persistent storage, forcing a
// check that the domain's root encryption key is still available.
//
// POST /domains/{domainID}/encryption/flush
func (c *Client) DomainFlushEncryptionKeys(ctx context.Context, request *DomainFlushEncryptionKeysReq, params DomainFlushEncryptionKeysParams) (DomainFlushEncryptionKeysRes, error) {
	res, err := c.sendDomainFlushEncryptionKeys(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainFlushEncryptionKeys(ctx context.Context, request *DomainFlushEncryptionKeysReq, params DomainFlushEncryptionKeysParams) (res DomainFlushEncryptionKeysRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainFlushEncryptionKeys"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/encryption/flush"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainFlushEncryptionKeys",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/encryption/flush"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainFlushEncryptionKeysRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainFlushEncryptionKeys", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainFlushEncryptionKeysResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainGetActiveExternalRootEncryptionKey invokes domainGetActiveExternalRootEncryptionKey operation.
//
// Return the details about the current active root encryption key used by the domain.
//
// GET /domains/{domainID}/control/keys/active
func (c *Client) DomainGetActiveExternalRootEncryptionKey(ctx context.Context, params DomainGetActiveExternalRootEncryptionKeyParams) (DomainGetActiveExternalRootEncryptionKeyRes, error) {
	res, err := c.sendDomainGetActiveExternalRootEncryptionKey(ctx, params)
	return res, err
}

func (c *Client) sendDomainGetActiveExternalRootEncryptionKey(ctx context.Context, params DomainGetActiveExternalRootEncryptionKeyParams) (res DomainGetActiveExternalRootEncryptionKeyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainGetActiveExternalRootEncryptionKey"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/keys/active"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainGetActiveExternalRootEncryptionKey",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/keys/active"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainGetActiveExternalRootEncryptionKey", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainGetActiveExternalRootEncryptionKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainGetCapabilities invokes domainGetCapabilities operation.
//
// Get the capabilities configured within the domain. A capability is a key/value pair that can be
// attached to a principal by an identity provider. The capabilities can be referenced by the domain
// policy rules.
//
// GET /domains/{domainID}/control/capabilities
func (c *Client) DomainGetCapabilities(ctx context.Context, params DomainGetCapabilitiesParams) (DomainGetCapabilitiesRes, error) {
	res, err := c.sendDomainGetCapabilities(ctx, params)
	return res, err
}

func (c *Client) sendDomainGetCapabilities(ctx context.Context, params DomainGetCapabilitiesParams) (res DomainGetCapabilitiesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainGetCapabilities"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/capabilities"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainGetCapabilities",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/capabilities"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainGetCapabilities", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainGetCapabilitiesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainGetCapability invokes domainGetCapability operation.
//
// Get a capability. A capability is a key/value pair that can be  attached to a principal by an
// identity provider. The capabilities can be referenced by the domain policy rules.
//
// GET /domains/{domainID}/control/capabilities/{capability}
func (c *Client) DomainGetCapability(ctx context.Context, params DomainGetCapabilityParams) (DomainGetCapabilityRes, error) {
	res, err := c.sendDomainGetCapability(ctx, params)
	return res, err
}

func (c *Client) sendDomainGetCapability(ctx context.Context, params DomainGetCapabilityParams) (res DomainGetCapabilityRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainGetCapability"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/capabilities/{capability}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainGetCapability",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/capabilities/"
	{
		// Encode "capability" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "capability",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.Capability); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainGetCapability", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainGetCapabilityResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainGetCapsuleInfo invokes domainGetCapsuleInfo operation.
//
// Get the summary information about this capsule.
//
// GET /domains/{domainID}/capsules/{capsuleID}
func (c *Client) DomainGetCapsuleInfo(ctx context.Context, params DomainGetCapsuleInfoParams) (DomainGetCapsuleInfoRes, error) {
	res, err := c.sendDomainGetCapsuleInfo(ctx, params)
	return res, err
}

func (c *Client) sendDomainGetCapsuleInfo(ctx context.Context, params DomainGetCapsuleInfoParams) (res DomainGetCapsuleInfoRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainGetCapsuleInfo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/capsules/{capsuleID}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainGetCapsuleInfo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/capsules/"
	{
		// Encode "capsuleID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "capsuleID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.CapsuleID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainGetCapsuleInfo", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainGetCapsuleInfoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainGetExternalRootEncryptionKeyProviders invokes domainGetExternalRootEncryptionKeyProviders operation.
//
// Returns a list of available root encryption key providers, along with their description and, if
// relevant, any additional information required to use them (e.g. for the delegated key provider
// `aws_am` the AWS account number to delegate to is returned).
//
// GET /domains/{domainID}/control/keys/providers
func (c *Client) DomainGetExternalRootEncryptionKeyProviders(ctx context.Context, params DomainGetExternalRootEncryptionKeyProvidersParams) (DomainGetExternalRootEncryptionKeyProvidersRes, error) {
	res, err := c.sendDomainGetExternalRootEncryptionKeyProviders(ctx, params)
	return res, err
}

func (c *Client) sendDomainGetExternalRootEncryptionKeyProviders(ctx context.Context, params DomainGetExternalRootEncryptionKeyProvidersParams) (res DomainGetExternalRootEncryptionKeyProvidersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainGetExternalRootEncryptionKeyProviders"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/keys/providers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainGetExternalRootEncryptionKeyProviders",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/keys/providers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainGetExternalRootEncryptionKeyProviders", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainGetExternalRootEncryptionKeyProvidersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainGetFactByID invokes domainGetFactByID operation.
//
// Returns the fact with the given ID.
//
// GET /domains/{domainID}/control/facts/{factType}/{factID}
func (c *Client) DomainGetFactByID(ctx context.Context, params DomainGetFactByIDParams) (DomainGetFactByIDRes, error) {
	res, err := c.sendDomainGetFactByID(ctx, params)
	return res, err
}

func (c *Client) sendDomainGetFactByID(ctx context.Context, params DomainGetFactByIDParams) (res DomainGetFactByIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainGetFactByID"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/facts/{factType}/{factID}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainGetFactByID",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/facts/"
	{
		// Encode "factType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "factType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.FactType); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "factID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "factID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.FactID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainGetFactByID", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainGetFactByIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainGetFactType invokes domainGetFactType operation.
//
// Get the definition of the given fact type.
//
// GET /domains/{domainID}/control/facts/{factType}
func (c *Client) DomainGetFactType(ctx context.Context, params DomainGetFactTypeParams) (DomainGetFactTypeRes, error) {
	res, err := c.sendDomainGetFactType(ctx, params)
	return res, err
}

func (c *Client) sendDomainGetFactType(ctx context.Context, params DomainGetFactTypeParams) (res DomainGetFactTypeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainGetFactType"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/facts/{factType}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainGetFactType",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/facts/"
	{
		// Encode "factType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "factType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.FactType); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainGetFactType", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainGetFactTypeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainGetIdentityProvider invokes domainGetIdentityProvider operation.
//
// Retrieve detailed information and configuration of an identity provider.
//
// GET /domains/{domainID}/control/identities/{identityProviderName}
func (c *Client) DomainGetIdentityProvider(ctx context.Context, params DomainGetIdentityProviderParams) (DomainGetIdentityProviderRes, error) {
	res, err := c.sendDomainGetIdentityProvider(ctx, params)
	return res, err
}

func (c *Client) sendDomainGetIdentityProvider(ctx context.Context, params DomainGetIdentityProviderParams) (res DomainGetIdentityProviderRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainGetIdentityProvider"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/identities/{identityProviderName}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainGetIdentityProvider",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/identities/"
	{
		// Encode "identityProviderName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "identityProviderName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.IdentityProviderName); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainGetIdentityProvider", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainGetIdentityProviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainGetIdentityProviderPrincipal invokes domainGetIdentityProviderPrincipal operation.
//
// Retrieve detailed information about an identity provider principal.
//
// GET /domains/{domainID}/control/identities/{identityProviderName}/principals/{principalID}
func (c *Client) DomainGetIdentityProviderPrincipal(ctx context.Context, params DomainGetIdentityProviderPrincipalParams) (DomainGetIdentityProviderPrincipalRes, error) {
	res, err := c.sendDomainGetIdentityProviderPrincipal(ctx, params)
	return res, err
}

func (c *Client) sendDomainGetIdentityProviderPrincipal(ctx context.Context, params DomainGetIdentityProviderPrincipalParams) (res DomainGetIdentityProviderPrincipalRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainGetIdentityProviderPrincipal"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/identities/{identityProviderName}/principals/{principalID}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainGetIdentityProviderPrincipal",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/identities/"
	{
		// Encode "identityProviderName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "identityProviderName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.IdentityProviderName); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/principals/"
	{
		// Encode "principalID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "principalID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.PrincipalID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainGetIdentityProviderPrincipal", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainGetIdentityProviderPrincipalResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainGetIdentityProviderPrincipals invokes domainGetIdentityProviderPrincipals operation.
//
// Retrieve a list of principals for an identity provider.
//
// GET /domains/{domainID}/control/identities/{identityProviderName}/principals
func (c *Client) DomainGetIdentityProviderPrincipals(ctx context.Context, params DomainGetIdentityProviderPrincipalsParams) (DomainGetIdentityProviderPrincipalsRes, error) {
	res, err := c.sendDomainGetIdentityProviderPrincipals(ctx, params)
	return res, err
}

func (c *Client) sendDomainGetIdentityProviderPrincipals(ctx context.Context, params DomainGetIdentityProviderPrincipalsParams) (res DomainGetIdentityProviderPrincipalsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainGetIdentityProviderPrincipals"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/identities/{identityProviderName}/principals"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainGetIdentityProviderPrincipals",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/identities/"
	{
		// Encode "identityProviderName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "identityProviderName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.IdentityProviderName); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/principals"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainGetIdentityProviderPrincipals", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainGetIdentityProviderPrincipalsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainGetPeer invokes domainGetPeer operation.
//
// Retrieve the details of a domain that is configured as a peer of this domain, by using its alias
// or one of its nicknames.
//
// GET /domains/{domainID}/peer-domain
func (c *Client) DomainGetPeer(ctx context.Context, params DomainGetPeerParams) (DomainGetPeerRes, error) {
	res, err := c.sendDomainGetPeer(ctx, params)
	return res, err
}

func (c *Client) sendDomainGetPeer(ctx context.Context, params DomainGetPeerParams) (res DomainGetPeerRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainGetPeer"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/peer-domain"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainGetPeer",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/peer-domain"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "nickname" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "nickname",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Nickname.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "alias" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "alias",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Alias.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainGetPeer", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainGetPeerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainGetPeerConfig invokes domainGetPeerConfig operation.
//
// Get the configuration for this peer.
//
// GET /domains/{domainID}/control/peers/{peerDomainID}
func (c *Client) DomainGetPeerConfig(ctx context.Context, params DomainGetPeerConfigParams) (DomainGetPeerConfigRes, error) {
	res, err := c.sendDomainGetPeerConfig(ctx, params)
	return res, err
}

func (c *Client) sendDomainGetPeerConfig(ctx context.Context, params DomainGetPeerConfigParams) (res DomainGetPeerConfigRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainGetPeerConfig"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/peers/{peerDomainID}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainGetPeerConfig",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/peers/"
	{
		// Encode "peerDomainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "peerDomainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.PeerDomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainGetPeerConfig", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainGetPeerConfigResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainGetPrivateInfo invokes domainGetPrivateInfo operation.
//
// Returns a Domain's summary information. This may include more information than the `public-info`
// endpoint but requires authentication.
//
// GET /domains/{domainID}/info
func (c *Client) DomainGetPrivateInfo(ctx context.Context, params DomainGetPrivateInfoParams) (DomainGetPrivateInfoRes, error) {
	res, err := c.sendDomainGetPrivateInfo(ctx, params)
	return res, err
}

func (c *Client) sendDomainGetPrivateInfo(ctx context.Context, params DomainGetPrivateInfoParams) (res DomainGetPrivateInfoRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainGetPrivateInfo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/info"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainGetPrivateInfo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/info"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainGetPrivateInfo", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainGetPrivateInfoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainGetPublicInfo invokes domainGetPublicInfo operation.
//
// Returns a Domain's summary information. This endpoint does not require authorization. This
// endpoint can be used to determine which identity providers the `/authenticate` endpoint supports.
//
// GET /domains/{domainID}/public-info
func (c *Client) DomainGetPublicInfo(ctx context.Context, params DomainGetPublicInfoParams) (DomainGetPublicInfoRes, error) {
	res, err := c.sendDomainGetPublicInfo(ctx, params)
	return res, err
}

func (c *Client) sendDomainGetPublicInfo(ctx context.Context, params DomainGetPublicInfoParams) (res DomainGetPublicInfoRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainGetPublicInfo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/public-info"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainGetPublicInfo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/public-info"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainGetPublicInfoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainGetReadContext invokes domainGetReadContext operation.
//
// Returns information about a read context.
//
// GET /domains/{domainID}/control/read-context/{contextName}
func (c *Client) DomainGetReadContext(ctx context.Context, params DomainGetReadContextParams) (DomainGetReadContextRes, error) {
	res, err := c.sendDomainGetReadContext(ctx, params)
	return res, err
}

func (c *Client) sendDomainGetReadContext(ctx context.Context, params DomainGetReadContextParams) (res DomainGetReadContextRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainGetReadContext"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/read-context/{contextName}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainGetReadContext",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/read-context/"
	{
		// Encode "contextName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "contextName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ContextName); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "includePolicyBundle" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "includePolicyBundle",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludePolicyBundle.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainGetReadContext", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainGetReadContextResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainGetSettings invokes domainGetSettings operation.
//
// Get the domain settings. This contains configuration for the contact email addresses as well as
// the display name for the domain.
//
// GET /domains/{domainID}/control/settings
func (c *Client) DomainGetSettings(ctx context.Context, params DomainGetSettingsParams) (DomainGetSettingsRes, error) {
	res, err := c.sendDomainGetSettings(ctx, params)
	return res, err
}

func (c *Client) sendDomainGetSettings(ctx context.Context, params DomainGetSettingsParams) (res DomainGetSettingsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainGetSettings"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/settings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainGetSettings",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/settings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainGetSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainGetSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainGetStatus invokes domainGetStatus operation.
//
// The domain status object contains important notifications for administrators of the domain.
//
// GET /domains/{domainID}/control/status
func (c *Client) DomainGetStatus(ctx context.Context, params DomainGetStatusParams) (DomainGetStatusRes, error) {
	res, err := c.sendDomainGetStatus(ctx, params)
	return res, err
}

func (c *Client) sendDomainGetStatus(ctx context.Context, params DomainGetStatusParams) (res DomainGetStatusRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainGetStatus"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/status"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainGetStatus",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/status"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainGetStatus", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainGetStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainGetTagInfo invokes domainGetTagInfo operation.
//
// Get an ordered list of the top 100 tags. The ordering is: - Tags emitted by hooks - Tags
// referenced in read context rules - Capsule and span tags that appear in the capsule manifest
// ordered by number of appearances This list will be truncated (and `has_more` will be true) if the
// above yields more than 100 tags. There is currently no endpoint to receive a complete list of tags.
//
// GET /domains/{domainID}/tag-info
func (c *Client) DomainGetTagInfo(ctx context.Context, params DomainGetTagInfoParams) (DomainGetTagInfoRes, error) {
	res, err := c.sendDomainGetTagInfo(ctx, params)
	return res, err
}

func (c *Client) sendDomainGetTagInfo(ctx context.Context, params DomainGetTagInfoParams) (res DomainGetTagInfoRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainGetTagInfo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/tag-info"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainGetTagInfo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tag-info"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainGetTagInfo", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainGetTagInfoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainGetWriteContextRegexRules invokes domainGetWriteContextRegexRules operation.
//
// Get a full listing of all regex rules for the context.
//
// GET /domains/{domainID}/control/write-context/{contextName}/regex-rule
func (c *Client) DomainGetWriteContextRegexRules(ctx context.Context, params DomainGetWriteContextRegexRulesParams) (DomainGetWriteContextRegexRulesRes, error) {
	res, err := c.sendDomainGetWriteContextRegexRules(ctx, params)
	return res, err
}

func (c *Client) sendDomainGetWriteContextRegexRules(ctx context.Context, params DomainGetWriteContextRegexRulesParams) (res DomainGetWriteContextRegexRulesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainGetWriteContextRegexRules"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/write-context/{contextName}/regex-rule"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainGetWriteContextRegexRules",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/write-context/"
	{
		// Encode "contextName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "contextName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ContextName); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/regex-rule"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainGetWriteContextRegexRules", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainGetWriteContextRegexRulesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainInsertIdentityProviderPrincipal invokes domainInsertIdentityProviderPrincipal operation.
//
// Create a new principal for the provider. Note that the identityProviderName must refer to an
// existing identity provider or the response will be a 400.
//
// POST /domains/{domainID}/control/identities/{identityProviderName}/principals
func (c *Client) DomainInsertIdentityProviderPrincipal(ctx context.Context, request *DomainIdentityProviderPrincipalParams, params DomainInsertIdentityProviderPrincipalParams) (DomainInsertIdentityProviderPrincipalRes, error) {
	res, err := c.sendDomainInsertIdentityProviderPrincipal(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainInsertIdentityProviderPrincipal(ctx context.Context, request *DomainIdentityProviderPrincipalParams, params DomainInsertIdentityProviderPrincipalParams) (res DomainInsertIdentityProviderPrincipalRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainInsertIdentityProviderPrincipal"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/identities/{identityProviderName}/principals"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainInsertIdentityProviderPrincipal",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/identities/"
	{
		// Encode "identityProviderName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "identityProviderName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.IdentityProviderName); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/principals"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainInsertIdentityProviderPrincipalRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainInsertIdentityProviderPrincipal", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainInsertIdentityProviderPrincipalResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainInsertWriteContextRegexRule invokes domainInsertWriteContextRegexRule operation.
//
// Create a new regex rule for a write context.
//
// POST /domains/{domainID}/control/write-context/{contextName}/regex-rule
func (c *Client) DomainInsertWriteContextRegexRule(ctx context.Context, request *WriteContextRegexRule, params DomainInsertWriteContextRegexRuleParams) (DomainInsertWriteContextRegexRuleRes, error) {
	res, err := c.sendDomainInsertWriteContextRegexRule(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainInsertWriteContextRegexRule(ctx context.Context, request *WriteContextRegexRule, params DomainInsertWriteContextRegexRuleParams) (res DomainInsertWriteContextRegexRuleRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainInsertWriteContextRegexRule"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/write-context/{contextName}/regex-rule"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainInsertWriteContextRegexRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/write-context/"
	{
		// Encode "contextName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "contextName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ContextName); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/regex-rule"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainInsertWriteContextRegexRuleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainInsertWriteContextRegexRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainInsertWriteContextRegexRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainListCapsules invokes domainListCapsules operation.
//
// Get information about capsules.
//
// GET /domains/{domainID}/capsules
func (c *Client) DomainListCapsules(ctx context.Context, params DomainListCapsulesParams) (DomainListCapsulesRes, error) {
	res, err := c.sendDomainListCapsules(ctx, params)
	return res, err
}

func (c *Client) sendDomainListCapsules(ctx context.Context, params DomainListCapsulesParams) (res DomainListCapsulesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainListCapsules"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/capsules"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainListCapsules",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/capsules"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "start_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartDate.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "end_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EndDate.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "num_results" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "num_results",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NumResults.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "span_tags" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "span_tags",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SpanTags.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort_on" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort_on",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortOn.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start_after" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start_after",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartAfter.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "ascending" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ascending",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Ascending.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainListCapsules", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainListCapsulesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainListExternalRootEncryptionKey invokes domainListExternalRootEncryptionKey operation.
//
// List all external root encryption keys for the domain.
//
// GET /domains/{domainID}/control/keys
func (c *Client) DomainListExternalRootEncryptionKey(ctx context.Context, params DomainListExternalRootEncryptionKeyParams) (DomainListExternalRootEncryptionKeyRes, error) {
	res, err := c.sendDomainListExternalRootEncryptionKey(ctx, params)
	return res, err
}

func (c *Client) sendDomainListExternalRootEncryptionKey(ctx context.Context, params DomainListExternalRootEncryptionKeyParams) (res DomainListExternalRootEncryptionKeyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainListExternalRootEncryptionKey"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/keys"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainListExternalRootEncryptionKey",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/keys"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainListExternalRootEncryptionKey", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainListExternalRootEncryptionKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainListFactTypes invokes domainListFactTypes operation.
//
// Get a list of the fact types in this domain. Facts are used by domain policy rules and read
// context rules.
//
// GET /domains/{domainID}/control/facts
func (c *Client) DomainListFactTypes(ctx context.Context, params DomainListFactTypesParams) (DomainListFactTypesRes, error) {
	res, err := c.sendDomainListFactTypes(ctx, params)
	return res, err
}

func (c *Client) sendDomainListFactTypes(ctx context.Context, params DomainListFactTypesParams) (res DomainListFactTypesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainListFactTypes"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/facts"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainListFactTypes",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/facts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainListFactTypes", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainListFactTypesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainListFacts invokes domainListFacts operation.
//
// Get the facts within a fact type.
//
// GET /domains/{domainID}/control/facts/{factType}/list
func (c *Client) DomainListFacts(ctx context.Context, params DomainListFactsParams) (DomainListFactsRes, error) {
	res, err := c.sendDomainListFacts(ctx, params)
	return res, err
}

func (c *Client) sendDomainListFacts(ctx context.Context, params DomainListFactsParams) (res DomainListFactsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainListFacts"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/facts/{factType}/list"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainListFacts",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/facts/"
	{
		// Encode "factType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "factType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.FactType); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/list"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainListFacts", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainListFactsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainListHooks invokes domainListHooks operation.
//
// Get a list of available hooks in this domain. Hooks can be added to write contexts to classify
// data.
//
// GET /domains/{domainID}/hooks
func (c *Client) DomainListHooks(ctx context.Context, params DomainListHooksParams) (DomainListHooksRes, error) {
	res, err := c.sendDomainListHooks(ctx, params)
	return res, err
}

func (c *Client) sendDomainListHooks(ctx context.Context, params DomainListHooksParams) (res DomainListHooksRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainListHooks"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/hooks"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainListHooks",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/hooks"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainListHooks", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainListHooksResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainListIdentityProviders invokes domainListIdentityProviders operation.
//
// Retrieve the domain's identity providers and a brief overview of their configuration. This
// endpoint requires authentication, but you can obtain an abridged list of the domain identity
// providers prior to authentication by using the `/public-info` endpoint.
//
// GET /domains/{domainID}/control/identities
func (c *Client) DomainListIdentityProviders(ctx context.Context, params DomainListIdentityProvidersParams) (DomainListIdentityProvidersRes, error) {
	res, err := c.sendDomainListIdentityProviders(ctx, params)
	return res, err
}

func (c *Client) sendDomainListIdentityProviders(ctx context.Context, params DomainListIdentityProvidersParams) (res DomainListIdentityProvidersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainListIdentityProviders"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/identities"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainListIdentityProviders",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/identities"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainListIdentityProviders", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainListIdentityProvidersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainListPeers invokes domainListPeers operation.
//
// Returns a list of this domains peers.
//
// GET /domains/{domainID}/control/peers
func (c *Client) DomainListPeers(ctx context.Context, params DomainListPeersParams) (DomainListPeersRes, error) {
	res, err := c.sendDomainListPeers(ctx, params)
	return res, err
}

func (c *Client) sendDomainListPeers(ctx context.Context, params DomainListPeersParams) (res DomainListPeersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainListPeers"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/peers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainListPeers",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/peers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainListPeers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainListPeersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainListPolicyRules invokes domainListPolicyRules operation.
//
// Get the domain policy rules. These govern which resources in the domain can be interacted with.
// Note that the peers "bypass" these rules, in that a peer domain can retrieve policy and
// configuration that has been allowed by peering configuration without needing an allowing domain
// policy rule, but they cannot access data within this domain.
//
// GET /domains/{domainID}/control/policy
func (c *Client) DomainListPolicyRules(ctx context.Context, params DomainListPolicyRulesParams) (DomainListPolicyRulesRes, error) {
	res, err := c.sendDomainListPolicyRules(ctx, params)
	return res, err
}

func (c *Client) sendDomainListPolicyRules(ctx context.Context, params DomainListPolicyRulesParams) (res DomainListPolicyRulesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainListPolicyRules"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/policy"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainListPolicyRules",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/policy"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainListPolicyRules", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainListPolicyRulesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainListReadContexts invokes domainListReadContexts operation.
//
// List the domain read contexts. If a user has view permissions on this resource, they may list all
// read contexts, even if they do not have view, edit or use permissions on some of the read contexts
// in the list.
//
// GET /domains/{domainID}/control/read-context
func (c *Client) DomainListReadContexts(ctx context.Context, params DomainListReadContextsParams) (DomainListReadContextsRes, error) {
	res, err := c.sendDomainListReadContexts(ctx, params)
	return res, err
}

func (c *Client) sendDomainListReadContexts(ctx context.Context, params DomainListReadContextsParams) (res DomainListReadContextsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainListReadContexts"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/read-context"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainListReadContexts",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/read-context"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainListReadContexts", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainListReadContextsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainListResources invokes domainListResources operation.
//
// Gets a list of resource strings that can be used in policy rules, and the set of permissions that
// you can assign to them. The return value from this endpoint is useful as a reference when
// authoring custom domain policy for new capabilities.
//
// GET /domains/{domainID}/control/resources
func (c *Client) DomainListResources(ctx context.Context, params DomainListResourcesParams) (DomainListResourcesRes, error) {
	res, err := c.sendDomainListResources(ctx, params)
	return res, err
}

func (c *Client) sendDomainListResources(ctx context.Context, params DomainListResourcesParams) (res DomainListResourcesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainListResources"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/resources"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainListResources",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/resources"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainListResources", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainListResourcesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainListWriteContexts invokes domainListWriteContexts operation.
//
// List the domain write contexts. If a user has view permissions on this resource, they may list all
// write contexts, even if they do not have view, edit or use permissions on some of the write
// contexts in the list.
//
// GET /domains/{domainID}/control/write-context
func (c *Client) DomainListWriteContexts(ctx context.Context, params DomainListWriteContextsParams) (DomainListWriteContextsRes, error) {
	res, err := c.sendDomainListWriteContexts(ctx, params)
	return res, err
}

func (c *Client) sendDomainListWriteContexts(ctx context.Context, params DomainListWriteContextsParams) (res DomainListWriteContextsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainListWriteContexts"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/write-context"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainListWriteContexts",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/write-context"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainListWriteContexts", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainListWriteContextsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainOpenCapsule invokes domainOpenCapsule operation.
//
// Given the encrypted DEK for this capsule, get back the decrypted DEK. contains the read context.
//
// POST /domains/{domainID}/capsules/{capsuleID}/open
func (c *Client) DomainOpenCapsule(ctx context.Context, request *CapsuleOpenRequest, params DomainOpenCapsuleParams) (DomainOpenCapsuleRes, error) {
	res, err := c.sendDomainOpenCapsule(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainOpenCapsule(ctx context.Context, request *CapsuleOpenRequest, params DomainOpenCapsuleParams) (res DomainOpenCapsuleRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainOpenCapsule"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/capsules/{capsuleID}/open"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainOpenCapsule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/capsules/"
	{
		// Encode "capsuleID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "capsuleID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.CapsuleID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/open"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "readContext" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "readContext",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if unwrapped := string(params.ReadContext); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainOpenCapsuleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainOpenCapsule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainOpenCapsuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainPatchSettings invokes domainPatchSettings operation.
//
// Applies the given patch to the domain settings.
//
// PATCH /domains/{domainID}/control/settings
func (c *Client) DomainPatchSettings(ctx context.Context, request *DomainSettingsPatch, params DomainPatchSettingsParams) (DomainPatchSettingsRes, error) {
	res, err := c.sendDomainPatchSettings(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainPatchSettings(ctx context.Context, request *DomainSettingsPatch, params DomainPatchSettingsParams) (res DomainPatchSettingsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainPatchSettings"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/settings"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainPatchSettings",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/settings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainPatchSettingsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainPatchSettings", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainPatchSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainPolicyFlush invokes domainPolicyFlush operation.
//
// Flush the policy cache so that changes to permissions take effect.
//
// POST /domains/{domainID}/control/policy/flush
func (c *Client) DomainPolicyFlush(ctx context.Context, params DomainPolicyFlushParams) (DomainPolicyFlushRes, error) {
	res, err := c.sendDomainPolicyFlush(ctx, params)
	return res, err
}

func (c *Client) sendDomainPolicyFlush(ctx context.Context, params DomainPolicyFlushParams) (res DomainPolicyFlushRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainPolicyFlush"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/policy/flush"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainPolicyFlush",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/policy/flush"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainPolicyFlush", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainPolicyFlushResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainPutCapability invokes domainPutCapability operation.
//
// Create or update a capability. If you want to return an error if the capability already existed,
// set `createonly` to true.
//
// PUT /domains/{domainID}/control/capabilities/{capability}
func (c *Client) DomainPutCapability(ctx context.Context, request *NewCapabilityDefinition, params DomainPutCapabilityParams) (DomainPutCapabilityRes, error) {
	res, err := c.sendDomainPutCapability(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainPutCapability(ctx context.Context, request *NewCapabilityDefinition, params DomainPutCapabilityParams) (res DomainPutCapabilityRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainPutCapability"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/capabilities/{capability}"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainPutCapability",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/capabilities/"
	{
		// Encode "capability" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "capability",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.Capability); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "createonly" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "createonly",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Createonly.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainPutCapabilityRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainPutCapability", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainPutCapabilityResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainPutFactType invokes domainPutFactType operation.
//
// Facts are used to store ancillary information that helps express domain policy rules and read
// context configuration rules. This endpoint allows you to register a new fact type. To create a
// fact within an existing type, use `/control/facts/{factType}/new`.
//
// PUT /domains/{domainID}/control/facts/{factType}
func (c *Client) DomainPutFactType(ctx context.Context, request *NewFactTypeDefinition, params DomainPutFactTypeParams) (DomainPutFactTypeRes, error) {
	res, err := c.sendDomainPutFactType(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainPutFactType(ctx context.Context, request *NewFactTypeDefinition, params DomainPutFactTypeParams) (res DomainPutFactTypeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainPutFactType"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/facts/{factType}"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainPutFactType",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/facts/"
	{
		// Encode "factType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "factType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.FactType); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainPutFactTypeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainPutFactType", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainPutFactTypeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainQueryAccessLog invokes domainQueryAccessLog operation.
//
// Query the data access log for this domain. This contains all operations interacting with capsules
// within this domain. Results are returned in reverse chronological order.
//
// GET /domains/{domainID}/log
func (c *Client) DomainQueryAccessLog(ctx context.Context, params DomainQueryAccessLogParams) (DomainQueryAccessLogRes, error) {
	res, err := c.sendDomainQueryAccessLog(ctx, params)
	return res, err
}

func (c *Client) sendDomainQueryAccessLog(ctx context.Context, params DomainQueryAccessLogParams) (res DomainQueryAccessLogRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainQueryAccessLog"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/log"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainQueryAccessLog",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/log"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "start_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartDate.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "end_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EndDate.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "num_results" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "num_results",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NumResults.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start_from_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start_from_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartFromID.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "session" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Session.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "location" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "location",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Location.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "location_prefixed" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "location_prefixed",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.LocationPrefixed.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "operation_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "operation_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OperationType.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "allowed_tag" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "allowed_tag",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AllowedTag.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "redacted_or_tokenized_tag" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "redacted_or_tokenized_tag",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.RedactedOrTokenizedTag.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainQueryAccessLog", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainQueryAccessLogResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainQueryAccessLogSingleCapsule invokes domainQueryAccessLogSingleCapsule operation.
//
// Query the data-plane access log for this capsule. Results are returned in reverse chronological
// order.
//
// GET /domains/{domainID}/capsules/{capsuleID}/log
func (c *Client) DomainQueryAccessLogSingleCapsule(ctx context.Context, params DomainQueryAccessLogSingleCapsuleParams) (DomainQueryAccessLogSingleCapsuleRes, error) {
	res, err := c.sendDomainQueryAccessLogSingleCapsule(ctx, params)
	return res, err
}

func (c *Client) sendDomainQueryAccessLogSingleCapsule(ctx context.Context, params DomainQueryAccessLogSingleCapsuleParams) (res DomainQueryAccessLogSingleCapsuleRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainQueryAccessLogSingleCapsule"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/capsules/{capsuleID}/log"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainQueryAccessLogSingleCapsule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/capsules/"
	{
		// Encode "capsuleID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "capsuleID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.CapsuleID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/log"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "start_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartDate.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "end_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EndDate.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "num_results" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "num_results",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NumResults.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start_from_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start_from_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartFromID.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "session" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Session.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "location" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "location",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Location.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "location_prefixed" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "location_prefixed",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.LocationPrefixed.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "operation_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "operation_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OperationType.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "allowed_tag" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "allowed_tag",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AllowedTag.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "redacted_or_tokenized_tag" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "redacted_or_tokenized_tag",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.RedactedOrTokenizedTag.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainQueryAccessLogSingleCapsule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainQueryAccessLogSingleCapsuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainQueryControlLog invokes domainQueryControlLog operation.
//
// Query the domain control-plane audit log. Results are returned in reverse chronological order.
//
// GET /domains/{domainID}/control/log
func (c *Client) DomainQueryControlLog(ctx context.Context, params DomainQueryControlLogParams) (DomainQueryControlLogRes, error) {
	res, err := c.sendDomainQueryControlLog(ctx, params)
	return res, err
}

func (c *Client) sendDomainQueryControlLog(ctx context.Context, params DomainQueryControlLogParams) (res DomainQueryControlLogRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainQueryControlLog"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/log"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainQueryControlLog",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/log"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "start_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartDate.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "end_date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end_date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EndDate.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "num_results" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "num_results",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NumResults.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start_from_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start_from_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartFromID.Get(); ok {
				if unwrapped := string(val); true {
					return e.EncodeValue(conv.StringToString(unwrapped))
				}
				return nil
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "session" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "session",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Session.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "url" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "url",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.URL.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "description" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "description",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Description.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainQueryControlLog", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainQueryControlLogResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainReadContextFlush invokes domainReadContextFlush operation.
//
// Flush the read context cache so that changes to permissions take effect.
//
// POST /domains/{domainID}/control/read-context/{contextName}/flush
func (c *Client) DomainReadContextFlush(ctx context.Context, params DomainReadContextFlushParams) (DomainReadContextFlushRes, error) {
	res, err := c.sendDomainReadContextFlush(ctx, params)
	return res, err
}

func (c *Client) sendDomainReadContextFlush(ctx context.Context, params DomainReadContextFlushParams) (res DomainReadContextFlushRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainReadContextFlush"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/read-context/{contextName}/flush"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainReadContextFlush",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/read-context/"
	{
		// Encode "contextName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "contextName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ContextName); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/flush"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainReadContextFlush", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainReadContextFlushResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainRenumberPolicyRules invokes domainRenumberPolicyRules operation.
//
// Re-assign rule priority numbers to integer multiples of 10.
//
// POST /domains/{domainID}/control/policy/renumber
func (c *Client) DomainRenumberPolicyRules(ctx context.Context, params DomainRenumberPolicyRulesParams) (DomainRenumberPolicyRulesRes, error) {
	res, err := c.sendDomainRenumberPolicyRules(ctx, params)
	return res, err
}

func (c *Client) sendDomainRenumberPolicyRules(ctx context.Context, params DomainRenumberPolicyRulesParams) (res DomainRenumberPolicyRulesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainRenumberPolicyRules"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/policy/renumber"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainRenumberPolicyRules",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/policy/renumber"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainRenumberPolicyRules", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainRenumberPolicyRulesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainRotateRootEncryptionKeys invokes domainRotateRootEncryptionKeys operation.
//
// Collects key encryption keys not encrypted with the current active root encryption key, decrypts
// them with their original root encryption key, and then encrypts them with the active root
// encryption key. This is a batched operation and only 100 keys will be processed in a single call.
// In the response, "has_more" will be true if there are more KEKs that can be rotated. Usually the
// caller will call this endpoint in a loop until has_more is false.
//
// POST /domains/{domainID}/control/keys/rotate
func (c *Client) DomainRotateRootEncryptionKeys(ctx context.Context, request *DomainRotateRootEncryptionKeysReq, params DomainRotateRootEncryptionKeysParams) (DomainRotateRootEncryptionKeysRes, error) {
	res, err := c.sendDomainRotateRootEncryptionKeys(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainRotateRootEncryptionKeys(ctx context.Context, request *DomainRotateRootEncryptionKeysReq, params DomainRotateRootEncryptionKeysParams) (res DomainRotateRootEncryptionKeysRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainRotateRootEncryptionKeys"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/keys/rotate"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainRotateRootEncryptionKeys",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/keys/rotate"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainRotateRootEncryptionKeysRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainRotateRootEncryptionKeys", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainRotateRootEncryptionKeysResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainSealCapsule invokes domainSealCapsule operation.
//
// Seal this capsule, if it's unsealed. Requires capsule create token.
//
// POST /domains/{domainID}/capsules/{capsuleID}/seal
func (c *Client) DomainSealCapsule(ctx context.Context, request *CapsuleSealRequest, params DomainSealCapsuleParams) (DomainSealCapsuleRes, error) {
	res, err := c.sendDomainSealCapsule(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainSealCapsule(ctx context.Context, request *CapsuleSealRequest, params DomainSealCapsuleParams) (res DomainSealCapsuleRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainSealCapsule"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/capsules/{capsuleID}/seal"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainSealCapsule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/capsules/"
	{
		// Encode "capsuleID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "capsuleID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.CapsuleID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/seal"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainSealCapsuleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainSealCapsule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainSealCapsuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainSetActiveExternalRootEncryptionKey invokes domainSetActiveExternalRootEncryptionKey operation.
//
// This will set which root encryption is active: i.e. is used for new capsules, or is used to
// encrypt KEKs when `/keys/rotate` is called or when new capsules are created.
//
// POST /domains/{domainID}/control/keys/active
func (c *Client) DomainSetActiveExternalRootEncryptionKey(ctx context.Context, request *ActiveRootEncryptionKeyID, params DomainSetActiveExternalRootEncryptionKeyParams) (DomainSetActiveExternalRootEncryptionKeyRes, error) {
	res, err := c.sendDomainSetActiveExternalRootEncryptionKey(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainSetActiveExternalRootEncryptionKey(ctx context.Context, request *ActiveRootEncryptionKeyID, params DomainSetActiveExternalRootEncryptionKeyParams) (res DomainSetActiveExternalRootEncryptionKeyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainSetActiveExternalRootEncryptionKey"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/keys/active"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainSetActiveExternalRootEncryptionKey",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/keys/active"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainSetActiveExternalRootEncryptionKeyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainSetActiveExternalRootEncryptionKey", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainSetActiveExternalRootEncryptionKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainUpdateIdentityProviderPrincipal invokes domainUpdateIdentityProviderPrincipal operation.
//
// Update the set of capabilities assigned to an identity provider principal. The capabilities must
// exist.
//
// PUT /domains/{domainID}/control/identities/{identityProviderName}/principals/{principalID}
func (c *Client) DomainUpdateIdentityProviderPrincipal(ctx context.Context, request *CapabilityList, params DomainUpdateIdentityProviderPrincipalParams) (DomainUpdateIdentityProviderPrincipalRes, error) {
	res, err := c.sendDomainUpdateIdentityProviderPrincipal(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainUpdateIdentityProviderPrincipal(ctx context.Context, request *CapabilityList, params DomainUpdateIdentityProviderPrincipalParams) (res DomainUpdateIdentityProviderPrincipalRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainUpdateIdentityProviderPrincipal"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/identities/{identityProviderName}/principals/{principalID}"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainUpdateIdentityProviderPrincipal",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/identities/"
	{
		// Encode "identityProviderName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "identityProviderName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.IdentityProviderName); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/principals/"
	{
		// Encode "principalID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "principalID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.PrincipalID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainUpdateIdentityProviderPrincipalRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainUpdateIdentityProviderPrincipal", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainUpdateIdentityProviderPrincipalResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainUpdatePeer invokes domainUpdatePeer operation.
//
// Create or update the configuration for this peer. Please note, if the configuration already exists,
//
//	it is updated to reflect the values in the request. This will include setting the fields to their
//
// default value if not supplied.
//
// PUT /domains/{domainID}/control/peers/{peerDomainID}
func (c *Client) DomainUpdatePeer(ctx context.Context, request *DomainPeerConfig, params DomainUpdatePeerParams) (DomainUpdatePeerRes, error) {
	res, err := c.sendDomainUpdatePeer(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainUpdatePeer(ctx context.Context, request *DomainPeerConfig, params DomainUpdatePeerParams) (res DomainUpdatePeerRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainUpdatePeer"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/peers/{peerDomainID}"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainUpdatePeer",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/peers/"
	{
		// Encode "peerDomainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "peerDomainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.PeerDomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainUpdatePeerRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainUpdatePeer", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainUpdatePeerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainUpdatePolicyRule invokes domainUpdatePolicyRule operation.
//
// Update a domain policy rule.
//
// PUT /domains/{domainID}/control/policy/{ruleID}
func (c *Client) DomainUpdatePolicyRule(ctx context.Context, request *NewDomainPolicyRule, params DomainUpdatePolicyRuleParams) (DomainUpdatePolicyRuleRes, error) {
	res, err := c.sendDomainUpdatePolicyRule(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainUpdatePolicyRule(ctx context.Context, request *NewDomainPolicyRule, params DomainUpdatePolicyRuleParams) (res DomainUpdatePolicyRuleRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainUpdatePolicyRule"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/policy/{ruleID}"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainUpdatePolicyRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/policy/"
	{
		// Encode "ruleID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ruleID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.RuleID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainUpdatePolicyRuleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainUpdatePolicyRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainUpdatePolicyRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainUpdateReadContextRule invokes domainUpdateReadContextRule operation.
//
// Update a read context configuration rule. The rule must already exist.
//
// PUT /domains/{domainID}/control/read-context/{contextName}/config/{ruleID}
func (c *Client) DomainUpdateReadContextRule(ctx context.Context, request *NewReadContextConfigRule, params DomainUpdateReadContextRuleParams) (DomainUpdateReadContextRuleRes, error) {
	res, err := c.sendDomainUpdateReadContextRule(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainUpdateReadContextRule(ctx context.Context, request *NewReadContextConfigRule, params DomainUpdateReadContextRuleParams) (res DomainUpdateReadContextRuleRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainUpdateReadContextRule"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/read-context/{contextName}/config/{ruleID}"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainUpdateReadContextRule",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/read-context/"
	{
		// Encode "contextName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "contextName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ContextName); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/config/"
	{
		// Encode "ruleID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ruleID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.RuleID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainUpdateReadContextRuleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainUpdateReadContextRule", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainUpdateReadContextRuleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainUpsertCapsuleTags invokes domainUpsertCapsuleTags operation.
//
// Upsert capsule-level tags. This is permitted even after a capsule is sealed.
//
// POST /domains/{domainID}/capsules/{capsuleID}/capsule-tags
func (c *Client) DomainUpsertCapsuleTags(ctx context.Context, request []Tag, params DomainUpsertCapsuleTagsParams) (DomainUpsertCapsuleTagsRes, error) {
	res, err := c.sendDomainUpsertCapsuleTags(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainUpsertCapsuleTags(ctx context.Context, request []Tag, params DomainUpsertCapsuleTagsParams) (res DomainUpsertCapsuleTagsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainUpsertCapsuleTags"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/capsules/{capsuleID}/capsule-tags"),
	}
	// Validate request before sending.
	if err := func() error {
		if request == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range request {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainUpsertCapsuleTags",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/capsules/"
	{
		// Encode "capsuleID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "capsuleID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.CapsuleID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/capsule-tags"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainUpsertCapsuleTagsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainUpsertCapsuleTags", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainUpsertCapsuleTagsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainUpsertFact invokes domainUpsertFact operation.
//
// Create a new fact. The fact type must have been previously registered using
// `/control/facts/{factType}`. If an identical fact exists (having the same value for all fields),
// this call is a no-op and returns the same ID.
//
// POST /domains/{domainID}/control/facts/{factType}/new
func (c *Client) DomainUpsertFact(ctx context.Context, request *NewFact, params DomainUpsertFactParams) (DomainUpsertFactRes, error) {
	res, err := c.sendDomainUpsertFact(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainUpsertFact(ctx context.Context, request *NewFact, params DomainUpsertFactParams) (res DomainUpsertFactRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainUpsertFact"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/facts/{factType}/new"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainUpsertFact",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/facts/"
	{
		// Encode "factType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "factType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.FactType); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/new"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainUpsertFactRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainUpsertFact", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainUpsertFactResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainUpsertIdentityProvider invokes domainUpsertIdentityProvider operation.
//
// Create or configure an identity provider.
//
// PUT /domains/{domainID}/control/identities/{identityProviderName}
func (c *Client) DomainUpsertIdentityProvider(ctx context.Context, request DomainIdentityProviderDetails, params DomainUpsertIdentityProviderParams) (DomainUpsertIdentityProviderRes, error) {
	res, err := c.sendDomainUpsertIdentityProvider(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainUpsertIdentityProvider(ctx context.Context, request DomainIdentityProviderDetails, params DomainUpsertIdentityProviderParams) (res DomainUpsertIdentityProviderRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainUpsertIdentityProvider"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/identities/{identityProviderName}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainUpsertIdentityProvider",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/identities/"
	{
		// Encode "identityProviderName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "identityProviderName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.IdentityProviderName); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainUpsertIdentityProviderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainUpsertIdentityProvider", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainUpsertIdentityProviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainUpsertReadContext invokes domainUpsertReadContext operation.
//
// Update or create a read context.
//
// PUT /domains/{domainID}/control/read-context/{contextName}
func (c *Client) DomainUpsertReadContext(ctx context.Context, request *AddReadContext, params DomainUpsertReadContextParams) (DomainUpsertReadContextRes, error) {
	res, err := c.sendDomainUpsertReadContext(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainUpsertReadContext(ctx context.Context, request *AddReadContext, params DomainUpsertReadContextParams) (res DomainUpsertReadContextRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainUpsertReadContext"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/read-context/{contextName}"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainUpsertReadContext",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/read-context/"
	{
		// Encode "contextName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "contextName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ContextName); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainUpsertReadContextRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainUpsertReadContext", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainUpsertReadContextResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainUpsertSpanTags invokes domainUpsertSpanTags operation.
//
// Upsert span tag rollups. This is only permitted when a capsule is not sealed. It requires a
// special "capsule owner" token that is returned by create capsule. Note that the rollup
// calculations must be done on the client side. This method only permits storing the entire rollup,
// not aggregating serverside. This is idempotent.
//
// PUT /domains/{domainID}/capsules/{capsuleID}/span-tags
func (c *Client) DomainUpsertSpanTags(ctx context.Context, request *UpsertSpanTagsRequest, params DomainUpsertSpanTagsParams) (DomainUpsertSpanTagsRes, error) {
	res, err := c.sendDomainUpsertSpanTags(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainUpsertSpanTags(ctx context.Context, request *UpsertSpanTagsRequest, params DomainUpsertSpanTagsParams) (res DomainUpsertSpanTagsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainUpsertSpanTags"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/capsules/{capsuleID}/span-tags"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainUpsertSpanTags",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/capsules/"
	{
		// Encode "capsuleID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "capsuleID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.CapsuleID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/span-tags"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainUpsertSpanTagsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainUpsertSpanTags", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainUpsertSpanTagsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainUpsertWriteContext invokes domainUpsertWriteContext operation.
//
// Create or update an existing write context. If the config is omitted, it will be left as-is
// (existing write contexts) or created as blank (new write contexts).
//
// PUT /domains/{domainID}/control/write-context/{contextName}
func (c *Client) DomainUpsertWriteContext(ctx context.Context, request *AddWriteContext, params DomainUpsertWriteContextParams) (DomainUpsertWriteContextRes, error) {
	res, err := c.sendDomainUpsertWriteContext(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainUpsertWriteContext(ctx context.Context, request *AddWriteContext, params DomainUpsertWriteContextParams) (res DomainUpsertWriteContextRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainUpsertWriteContext"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/write-context/{contextName}"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainUpsertWriteContext",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/write-context/"
	{
		// Encode "contextName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "contextName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ContextName); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainUpsertWriteContextRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainUpsertWriteContext", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainUpsertWriteContextResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DomainUpsertWriteContextConfiguration invokes domainUpsertWriteContextConfiguration operation.
//
// Update a write context configuration. The write context must already exist.
//
// PUT /domains/{domainID}/control/write-context/{contextName}/config
func (c *Client) DomainUpsertWriteContextConfiguration(ctx context.Context, request *WriteContextConfigInfo, params DomainUpsertWriteContextConfigurationParams) (DomainUpsertWriteContextConfigurationRes, error) {
	res, err := c.sendDomainUpsertWriteContextConfiguration(ctx, request, params)
	return res, err
}

func (c *Client) sendDomainUpsertWriteContextConfiguration(ctx context.Context, request *WriteContextConfigInfo, params DomainUpsertWriteContextConfigurationParams) (res DomainUpsertWriteContextConfigurationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("domainUpsertWriteContextConfiguration"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/domains/{domainID}/control/write-context/{contextName}/config"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DomainUpsertWriteContextConfiguration",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/control/write-context/"
	{
		// Encode "contextName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "contextName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ContextName); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/config"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDomainUpsertWriteContextConfigurationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:DomainIdentity"
			switch err := c.securityDomainIdentity(ctx, "DomainUpsertWriteContextConfiguration", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"DomainIdentity\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDomainUpsertWriteContextConfigurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StarredDomainAdd invokes starredDomainAdd operation.
//
// Adds the domain to the list of starred domains for the user.
//
// PUT /global/starred-domains/{domainID}
func (c *Client) StarredDomainAdd(ctx context.Context, request *StarredDomainAddReq, params StarredDomainAddParams) (StarredDomainAddRes, error) {
	res, err := c.sendStarredDomainAdd(ctx, request, params)
	return res, err
}

func (c *Client) sendStarredDomainAdd(ctx context.Context, request *StarredDomainAddReq, params StarredDomainAddParams) (res StarredDomainAddRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("starredDomainAdd"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/global/starred-domains/{domainID}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "StarredDomainAdd",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/global/starred-domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStarredDomainAddRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuthToken"
			switch err := c.securityOAuthToken(ctx, "StarredDomainAdd", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuthToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeStarredDomainAddResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StarredDomainList invokes starredDomainList operation.
//
// Returns a list of domains that the user has starred. This is a list of domain IDs, not domain
// names. The user must be authenticated to call this method.
//
// GET /global/starred-domains
func (c *Client) StarredDomainList(ctx context.Context) (StarredDomainListRes, error) {
	res, err := c.sendStarredDomainList(ctx)
	return res, err
}

func (c *Client) sendStarredDomainList(ctx context.Context) (res StarredDomainListRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("starredDomainList"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/global/starred-domains"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "StarredDomainList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/global/starred-domains"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuthToken"
			switch err := c.securityOAuthToken(ctx, "StarredDomainList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuthToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeStarredDomainListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StarredDomainRemove invokes starredDomainRemove operation.
//
// Removes the domain from the list of starred domains for the user.
//
// DELETE /global/starred-domains/{domainID}
func (c *Client) StarredDomainRemove(ctx context.Context, params StarredDomainRemoveParams) (StarredDomainRemoveRes, error) {
	res, err := c.sendStarredDomainRemove(ctx, params)
	return res, err
}

func (c *Client) sendStarredDomainRemove(ctx context.Context, params StarredDomainRemoveParams) (res StarredDomainRemoveRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("starredDomainRemove"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/global/starred-domains/{domainID}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "StarredDomainRemove",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/global/starred-domains/"
	{
		// Encode "domainID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "domainID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.DomainID); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuthToken"
			switch err := c.securityOAuthToken(ctx, "StarredDomainRemove", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuthToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeStarredDomainRemoveResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
